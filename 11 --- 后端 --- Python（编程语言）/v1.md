[TOC]

# Python

# 1，简介

## 1.这是啥

（前提，我是有 Java 基础的了，很多重复的东西我可就忽略了咯）

一个语法简洁到恶心的高级编程语言。

但不得不说的确方便。

尤其在大数据和 AI 上面的环境与支持，完全不是 Java 这类语言能碰的。

# 2，基本内容

## 1.注释

不用解释了吧。

```python
# 单行注释
```

```python
"""
	多行注释
"""
```

## 2.字面量

代码中手敲的值叫字面量。

```python
# 这样直接敲出来的叫字面量
print(10)
print(1.14)
print("abc")
```

## 3.标识符

变量名，方法名，类名啥的都叫标识符。

命名只允许出现：英文，中文，数字，下划线。

不能以数字开始。

```python
name = 1
name_A = 1
# 1name = 1 报错
# name! = 1 报错
```

且 Python 大小写敏感。

```python
name = 1
# name = 1 不建议重名
Name = 1
```

同样占用关键字也是不能用的（百度去）。

```python
# and = 1 报错
```

最后，尽量见名知意。

且尽量不要使用大写字母。

## 4.变量

也不用解释了吧。

这玩意的变量直接起名字就行了。

没有 Java 的强制定义数据类型，甚至 Python 的语句连结尾的 `;` 都不用给。

```python
a = 10
print(a)
```

顺便小提一嘴。

Python 这玩意的输出语句可以直接一起喷好几个值。

```python
print("gjh还剩", 100, "块钱")
# 输出‘gjh还剩 100 块钱’
```

## 5.数据类型

### 列举

 Python 中，有6种数据类型。

| 类型               | 描述                                                         | 说明                                                         |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 数字（Number）     | 整数（int）<br />浮点数（float）<br />复数（complex）<br />布尔（bool） | 如10，-10<br />如1.14，-2.31<br />如4+3j，j 结尾表示复数<br />真（true / 1）假（false / 0） |
| 字符串（String）   | 用于描述文本                                                 | 由任意熟练的字符组成                                         |
| 列表（List）       | 有序的可变序列                                               | 有序记录一堆数据                                             |
| 元组（Tuple）      | 有序的不可变序列                                             | 有序记录一堆不可变的数据集合                                 |
| 集合（Set）        | 无序的不重复集合                                             | 无序记录一堆不可变的数据集合                                 |
| 字典（Dictionary） | 无序的键值集合                                               | 无序记录一堆键值集合                                         |

### 检查

可以用 `type()` 检查类型。

丢个变量进去也是可以检查的。

这里干脆一起见识一下所有数据类型长啥样。

```python
int_num = 10
print(type(int_num))

float_num = 1.14
print(type(float_num))

complex_num = 4 + 3j
print(type(complex_num))

bool_val = True
print(type(bool_val))

string_val = "abc"
print(type(string_val))

list_val = [1, 2, 3]
print(type(list_val))

tuple_val = (1, 2, 3)
print(type(tuple_val))

set_val = {1, 2, 3}
print(type(set_val))

dict_val = {"name": "Alice", "age": 25}
print(type(dict_val))
"""
	理应输出：
	<class 'int'>
    <class 'float'>
    <class 'complex'>
    <class 'bool'>
    <class 'str'>
    <class 'list'>
    <class 'tuple'>
    <class 'set'>
    <class 'dict'>
"""
```

### 转换

把不需要的类型变成需要的类型。

任何类型都能变成字符串。

字符串不能转数字

浮点数转整数会丢精度（小数吃掉了）。

```python
# int(x) 转成整数
# float(x) 转成浮点数
# str(x) 转成字符串

print(type(int(1.14)))
print(type(str(1.14)))
print(type(int("abc")))
"""
	理应输出：
	<class 'int'>
	<class 'str'>
	最后一个报错，字符串不能变成整数
"""
```

## 6.运算符

### 算数运算符

| 运算符 | 描述   |
| ------ | ------ |
| +      | 加     |
| -      | 减     |
| *      | 乘     |
| /      | 除     |
| //     | 取整除 |
| %      | 取余   |
| **     | 指数   |

```python
print("1 + 1 =", 1 + 1)
print("1 - 1 =", 1 - 1)
print("2 * 2 =", 2 * 2)
print("10 / 2 =", 10 / 2)
print("11 // 2 =", 11 // 2)
print("9 % 2 =", 9 % 2)
print("2 ** 2 =", 2 ** 2)
"""
	理应输出：
	1 + 1 = 2
    1 - 1 = 0
    2 * 2 = 4
    10 / 2 = 5.0
    11 // 2 = 5
    9 % 2 = 1
    2 ** 2 = 4
"""
```

### 赋值运算符

| 运算符 | 描述                   |
| ------ | ---------------------- |
| =      | a = b                  |
| +=     | a += b : a = a + b     |
| -=     | a -= b : a = a - b     |
| *=     | a *= b : a = a * b     |
| /=     | a /=  b : a = a / b    |
| %=     | a %= b : a = a % b     |
| **=    | a **= b : a = a \*\* b |
| //=    | a //= b : a // b       |

```python
a = 10
b = 3

a = b
print("a = b =", a)
a += b
print("a += b =", a)
a -= b
print("a -= b =", a)
a *= b
print("a *= b =", a)
a /= b
print("a /= b =", a)
a %= b
print("a %= b =", a)
a **= b
print("a **= b =", a)
a //= b
print("a //= b =", a)
"""
	理应输出：
	a = b = 3
    a += b = 6
    a -= b = 3
    a *= b = 9
    a /= b = 3.0
    a %= b = 0.0
    a **= b = 0.0
    a //= b = 0.0
"""
```

### 比较运算符

| 运算符 | 描述                     |
| ------ | ------------------------ |
| ==     | 判断内容是否相等         |
| !=     | 判断内容是否不相等       |
| >      | 判断左侧是否大于右侧     |
| <      | 判断左侧是否小于右侧     |
| >=     | 判断左侧是否大于等于右侧 |
| <=     | 判断左侧是否小于等于右侧 |

```py
a = 10
b = 3

print("a == b =", a == b)  # 判断a是否等于b
print("a != b =", a != b)  # 判断a是否不等于b
print("a > b =", a > b)    # 判断a是否大于b
print("a < b =", a < b)    # 判断a是否小于b
print("a >= b =", a >= b)  # 判断a是否大于等于b
print("a <= b =", a <= b)  # 判断a是否小于等于b
"""
	理应输出：
	a == b = False
    a != b = True
    a > b = True
    a < b = False
    a >= b = True
    a <= b = False
"""
```

## 7.字符串

### 为啥单独抓出来讲

主要是这玩意用的最多，先重点讲一下这玩意。

毕竟是 Python 极速版，抓着重要的（且基础的）部分来就好。

### 定义

三种方法。

Python 这玩意可以用注释声明字符串：）

且用注释声明的字符串会连着换行空格啥的一起输出。

`"""` 被输出后本身会有一个换行的效果。

```python
a = 'a'
b = "b"
c = """
	c
	b
"""

"""
	理应输出：
	a
	b

    	cb

"""
```

### 拼接与格式化

#### 直接拼接

最直接的拼接就是用 `+`。

变量也能接。

注意这种方法不能拼接非字符串类型。

```python
a = "Hello"
b = 1

print("Hello" + " World")
print(a + " World")
# print(b + " World") 报错
# print(1 + " World") 报错
```

#### 常规格式化

其实也算是拼接。

但可以解决上面的常规拼接丑陋，且只能拼字符串的问题。

```python
a = "World"
b = 1
print("hello %s" % a)
print("hello %s" % b)
print("hello %s" % 1)
```

拼接多个时，用括号包裹值组。

```python
a = "World"
b = 1
print("hello %s %s %s" % (a, b, 123))
```

关于占位符（就是 `%S`），一般就是三种。

| 占位符 | 描述       |
| ------ | ---------- |
| %s     | 转为字符串 |
| %d     | 转为整数   |
| %f     | 转为浮点   |

#### 精度控制

其实也是在格式化时用的。

```python
a = 11.14
print("hello %f" % a)
# 输出：hello 11.140000
```

转为浮点输出时，精度会炸开。

用 `m.n` 控制精度。

`m` 控制整数位数（不足的自动补空格），填入整数。

`n` 控制小数位数（四舍五入截断），填入整数。

```python
a = 10
b = 11.145

print("hello %5d" % a)
print("hello %5.2f" % b)
"""
	理应输出：
    hello    10
    hello 11.14
"""
```

#### 直接插入

比前面的又简化了一点。

这种方法不会管啥类型，也不会管精不精度。

记得在输出语句开头加个 `f`。

```python
a = 10
b = 11.145
c = " World"

print(f"Hello{c},  {a},  {b}")
# 输出：Hello World,  10,  11.145
```

#### 表达式格式化

表达式不用讲是啥了吧。

反正就是可以省略一些代码。

悠着点用。

还是以可读性和可维护性至上。

（碰到死人领导或黑心老板干着自己不喜欢的事就另提）

```python
a = 1
b = 3

print("2x2=%d" % (2 * 2))
print(f"2x2={2 * 2}")
print("%s" % type("str"))
print(a + b)
```

## 8.控制台输入

`print` 见多了吧，就是控制台输出。

`input` 就是控制台输入了。

控制台敲完字，回车就好。

注意，这玩意不管输入什么，统一当成字符串看待。

```python
# 直接输入
name = input()
print(name)

# 也能加上提示语
name = input("输入姓名：")
print(name)
```

# 3，结构语句

## 1.判断语句

### 如果

如果怎样，就怎样。

```python
a = 10
b = 3

if a > b:
    print("yes")
    print("成立")
```

### 如果，否则

如果怎样，就怎样，否则怎样。

```python
a = 10
b = 3

if a < b:
    print("yes")
    print("成立")
else:
    print("no")
    print("不成立")
```

### 如果，否则如果，否则

如果怎样，就怎样，否则如果怎样，就怎样，否则怎样。

```python
a = 10
b = 3

if a < b:
    print("a小于b")
    print("成立")
elif a > b:
    print("a小于b")
    print("不成立")
else:
    print("有问题")
```

### 嵌套

如果又如果，多层判断（IDEA 只会提示代码，PYC 还会提示打印的文本）。

```python
a = 10
b = 3
c = 5

if a > b:
    print("a is greater than b")
    if a > c:
        print("a is greater than c")
    else:
        print("a is less than c")
else:
    print("a is less than b")
```

## 2.循环语句

### 序列

先认识这玩意。

序列就是可以把值逐个取出的。

如字符串，列表，元组等。

`range()`方法就可以用来获取一段数字序列。

```python
# 获取0-9的数字序列
for i in range(10):
    print(i)

# 获取5-9的数字序列
for i in range(5, 10):
    print(i)

# 获取5-9，步长为2（B = A + 2）的数字序列
for i in range(5, 10, 2):
    print(i)
```

### 未知次数循环

不知道循环几次时用的。

需定义停止条件与迭代条件。

```python
a = 1
b = 3
while a <= b:
    print(a)
    a += 1
```

### 未知次数嵌套循环

不知道循环几次，且循环里还要套循环。

如遍历所有学生，再遍历每个学生的所有信息。

也需定义停止条件与迭代条件（每个循环都要定义）。

```python
a = 1
b = 1
sum = 0

while a <= 5:
    sum += a
    a += 1
    print("a")
    while b <= 2:
        print("b")
        b += 1
    b = 1
```

### 确定次数循环

确定要循环的次数用这个。

需要定义临时变量与指定待处理数据集（序列）。

```python
a = {1, 2, 3, 4, 5, 6, 7, 8, 9}

for i in a:
    print(i)
```

### 确定次数嵌套循环

也是上面那玩意自己套自己。

也是需要定义临时变量与指定待处理数据集（序列）。

```python
a = {1, 2, 3, 4, 5, 6, 7, 8, 9}
b = {0}

for i in a:
    print(i)
    for j in b:
        print(j)
```

### 中断与退出

使用 `continue` 中断单次迭代，循环本身继续跑。

```python
a = {1, 2, 3, 4, 5, 6, 7, 8, 9}

for i in a:
    if i == 5:
        continue
    print(i)
```

而 `break` 可以结束循环。

```python
a = {1, 2, 3, 4, 5, 6, 7, 8, 9}

for i in a:
    if i == 5:
        break
    print(i)
```

## 3.小结

### 判断整数正负

控制台接收用户输入。

判断数字为正数，负数或0。

```python
num = input("输入一个整数：")
if int(num) == 0:
    print("输入是，0")
else:
    if int(num) > 0:
        print("输入是，正整数")
    else:
        print("输入是，负整数")
```

### 1-100累加和

累加 1 - 100 的和。

```python
a = 1
sum = 0

while a <= 100:
    sum += a
    a += 1

print(sum)
```

### 乘法表

控制台输出乘法表。

```python
for i in range(1, 10):
    print(f"{i}x1=", i, end="\t")
    for j in range(2, i + 1):
        print(f"{i}x{j}=", j * i, end="\t")
    print()
```

### 猜数字

没学随机数，先用变量自己定义。

控制台接收用户输入。

判断大于，小于，或猜到了。

```python
a = 15
inputNum = int(input("输入数字："))

while inputNum != a:
    if inputNum > a:
        print("大了")
    elif inputNum < a:
        print("小了")
    inputNum = int(input("输入数字："))

print("对了")
```

# 4，函数

## 1.定义

函数就是提前写好的，可重复使用的代码块。

记得先定义再使用。

函数定义后，建议保留两行空行（python 喜欢罢了）。

方法名建议小写，单词间用下划线间隔（也是 python 喜欢罢了）。

```python
# 方法声明 “ def 函数名([形参]): ”
def hi():
    # 代码块
    print("hi")
    # [返回值]
    return


# 调用
hi()
```

## 2.参数

### 单个传递

函数接收的，外部的，供给函数使用数据。

```python
# 计算某数乘自己
def out_num(num):
    print(num * num)

    
outNum(4)
```

### 多个传递

可以传多个参数。

```python
# 计算两数和
def get_sum(num_a, num_b):
    print(num_a + num_b)

    
sum(1, 2)
```

### 关键字传递

上面的需要保证顺序，关键字传递允许打乱书写顺序。

```python
def test(a, b, c):
    print(a, b, c)


test(b=2, c=3, a=1)
```

### 默认参数

python 越来越让我惊喜了：）

就是可以给方法参数赋予默认值。

```python
def test(a, b, c=3):
    print(a, b, c)


test(1, 2)
```

### 不定数量参数

可以允许不确定数量的参数。

args 是个元组。

想操作这个参数组就用元组的方法。

```python
def test(*args):
    print(args)


test(1, 2, "asd")
```

### 函数参数

是的。

函数也能做参数。

传递函数不是调用函数。

不用加小括号。

```python
def test(sum):
    result = sum(1, 2)
    print(result)


def sum(a, b):
    return a + b


test(sum)
```

## 3.返回值

### 正常情况

就是函数运行完之后的结果。

返回值可以直接使用，也能接收保存。

返回后，方法的剩余部分均不会执行，方法就直接退出了。

```python
# 计算传入字符串长度
def string_length(data):
    length = 0
    for i in data:
        length += 1
    return length


print(string_length("78465132"))
# or
num = string_length("78465132")
print(num)
```

### 空返回

如只是想退出方法。

或方法逻辑中有需要返回的情况，同时又有不需要返回的情况。

可以用 `None` 定义空返回。

在保留 `return` 关键字与其作用的同时，不会真正返回什么东西（None 倒是会变成字符串喷出去）。

```python
# 计算传入字符串长度
def string_length(data):
    length = 0
    for i in data:
        length += 1
    return None


print(string_length("78465132"))
# or
num = string_length("78465132")
print(num)
```

### 多返回

python 竟然可以一次返回多个值：）

也算是解决了 Java 的痛点之一。

Java 也就是同时声明多个变量，就这还不能一句代码分别赋值。

这玩意，同时声明，同时赋值，多个返回。

好得很。

```python
def test():
    return 1, 2


x, y = test()
print(x)
print(y)
```

## 4.函数注释

用于注释整个函数的注释。

鼠标悬在方法名上会显示的注释。

就是多行注释换了地方，就变了作用。

`param` 用于描述形参。

`return` 用于描述返回值。

```python
def string_length(data):
    """
    计算传入字符串长度
    :param data: 需要计算的字符串
    :return: 字符串的长度
    """
    length = 0
    for i in data:
        length += 1
    return None
```

## 5.函数嵌套

感觉没啥好说的。

就是函数 A 调用函数 B。

但如果是函数 A 调用自己，那就算是递归，一个头大但厉害好用的东西了（这里不讲）。

```python
def a():
    print('a')
    b()


def b():
    print('b')


a()
```

## 6.匿名函数

使用 `lambda` 声明。

别和 Java 里面的 `lambda` 搞混。

就用上面传递函数作参数的例子。

```python
def test(sum):
    result = sum(1, 2)
    print(result)


# lambda 参数: 方法体
test(lambda x, y: x + y)
```

## 7.变量作用域

文件内的变量只能被文件内获取使用。

函数内的变量只能被函数内获取使用。

循环内的变量只能被循环内获取使用。

## 8.类型提示

给变量或方法参数与返回值用的，定义他们的数据类型。

虽然Python不强制定义类型，且运行时类型是可变的。

所以这玩意也就是在敲代码时让人看看了。

看的顺眼直观点。

```python
# 标记变量类型
a:int = 1
s:str = "str"
st:list[int] = [1, 2, 3]
y:tuple[int, str, list] = (1, "1", st)
u:int | str = 1 # 或"1"



# 标记方法参数类型与返回值类型（也能定义或者是某个类型）
# 方法也能做参数，所以也有一个专门的类型
def sum(a:int, b:int, func:Callable) -> int | None:
    return func(a+b)
```

## 9.小结

### 计算平面矩形面积

小学题，不用解释吧。

```python
def calculate_area(width, height):
    return "面积为：" + str(width * height)


print(calculate_area(10, 10))
```

# 5，数据容器

## 1.列表

### 定义

存储的成员可以是不同类型。

```python
# 字面量
a = [1, "a", 3]

# 定义变量
num_a = 1
num_b = 2
num_c = 3
b = [num_a, num_b, num_c]

# 定义空列表
c = []
d = list()

# 嵌套
e = [[1, 2], [3, 4]]
```

### 获取

使用下标（应该很熟悉了吧）。

记得从0开始的。

不过 python 下标允许负值。

下标范围为：负列表长度 至 列表长度 - 1。

```python
# 可取下标为 -3 至 2
a = [3, 4, 5]
print(a[0])
print(a[1])
print(a[-1])
print(a[-3])
```

### 方法

#### 获取某元素的下标

```python
a = ["Asd", "dd", "plk,"]
print(a.index("dd"))
# 理应输出：1
```

#### 修改下标元素

```python
a = ["Asd", "dd", "plk,"]
print(a[1])
a[1] = "a"
print(a[1])
"""
	理应输出：
	dd
	a
"""
```

#### 在指定下标插入元素

```python
a = ["Asd", "dd", "plk,"]
a.insert(1, "6")
print(a)
"""
	理应输出：
	['Asd', '6', 'dd', 'plk,']
"""
```

#### 追加元素至末尾

追加单个值。

```python
a = ["Asd", "dd", "plk,"]
a.append("asdfgh")
print(a)
"""
	理应输出：
	['Asd', 'dd', 'plk,', 'asdfgh']
"""
```

追加其它列表。

```python
a = ["Asd", "dd", "plk,"]
b = ["a", "b", "c"]
a.extend(b)
print(a)
"""
	理应输出：
	['Asd', 'dd', 'plk,', 'a', 'b', 'c']
"""
```

#### 删除下标元素

```python
a = ["Asd", "dd", "plk,"]
del a[2]
print(a)
"""
	理应输出：
	['Asd', 'dd']
"""
```

#### 删除匹配项

```python
a = ["Asd", "dd", "plk,"]
a.remove("Asd")
print(a)
"""
	理应输出：
	['dd', 'plk,']
"""
```

#### 清空列表

```python
a = ["Asd", "dd", "plk,"]
a.clear()
print(a)
"""
	理应输出：
	[]
"""
```

### 遍历

使用 `while` 循环。

```python
a = ["Asd", "dd", "plk,"]
index = 0
while index < len(a):
    print(a[index])
    index += 1
"""
	理应输出：
	Asd
    dd
    plk,
"""
```

使用 `for` 循环。

```python
a = ["Asd", "dd", "plk,"]
for i in a:
    print(i)
"""
	理应输出：
	Asd
    dd
    plk,
"""
```

## 2.元组

### 定义

类似列表。

不过是不可修改元素的列表。

但是在元组里面塞个列表啥的，里面这个列表的元素可以修改。

注意这玩意哪怕只有一个元素也要加逗号。

```python
# 字面量
a = (1, 2, 3)
# a = (1,)

# 定义变量
q = 1
w = 2
e = 3
b = (q, w, e)

# 定义空元组
c = ()
d = tuple()

# 嵌套
e = ((1, 2), (3, 4))
```

### 获取

也能用下标。

用法和列表一样。

```python
a = (1, 2)
print(a[1])
```

### 方法

#### 获取某元素下标

```python
a = (1, 2)
print(a.index(1))
"""
	理应输出：
	0
"""
```

#### 统计某元素出现次数

```python
a = (1, 2, 1, 1)
print(a.count(1))
"""
	理应输出：
	3
"""
```

### 遍历

似乎，和列表的遍历一模一样。

使用 `while` 循环。

```python
a = (1, 2, 3)
index = 0
while index < len(a):
    print(a[index])
    index += 1
"""
	理应输出：
	1
    2
    3
"""
```

使用 `for` 循环。

```python
a = (1, 2, 3)
for i in a:
    print(i)
"""
	理应输出：
	1
    2
    3
"""
```

## 3.字符串

### 定义

字符的容器。

所以愣是也可以和数据容器在一起。

字符串声明还用说？

不用的吧：）

### 获取

是的。

字符串也是可以用下标的。

就当作每个字符就是一个元素。

```python
a = "asd"
print(a[1])
"""
	理应输出：
	s
"""
```

### 方法

#### 查找首个匹配下标

```python
a = "asda"
print(a.index(a))
"""
	理应输出：
	0
"""
```

#### 替换字符

```python
a = "asda"
print(a.replace("a", "0"))
"""
	理应输出：
	0sd0
"""
```

#### 分割字符串

```python
a = "asda"
print(a.split("s"))
"""
	理应输出：
	['a', 'da']
"""
```

#### 移除首尾空格换行

```python
a = " a sda \n"
print(a.strip())
"""
	理应输出：
	a sda
"""
```

#### 统计指定字符出现次数

```python
a = " a sda \n"
print(a.count("a"))
"""
	理应输出：
	2
"""
```

## 4.序列

### 定义

列表，元组，字符串啥的就算是序列。

代表内容连续，有序，可以用下标索引的数据容器。

### 序列切片

截出序列中的某段。

```python
# 序列名[起始下标（包括）:结束下标（不包括）:步长（默认1）]
a = [1, 2, 3, 4, 5]
b = a[0:3:1]
print(b)
"""
	理应输出：
	[1, 2, 3]
"""
```

## 5.集合

### 定义

集合可以当作不允许出现重复元素且无序的序列。

且不能嵌套（这一点不如 Java）。

还因为集合是无序的，所以不支持下标。

修改还是可以的。

```python
# 字面量
a = {1, 2, 3}

# 定义变量
q = 1
w = 2
e = 3
b = {q, w, e}

# 定义空元组
c = set()
```

### 方法

#### 添加一个元素

```python
a = {1, 2, 3}
a.add(4)
print(a)
"""
	理应输出：
	{1, 2, 3, 4}
"""
```

#### 移除指定元素

```python
a = {1, 2, 3}
a.remove(3)
print(a)
"""
	理应输出：
	{1, 2}
"""
```

#### 清空集合

```python
a = {1, 2, 3}
a.clear()
print(a)
"""
	理应输出：
	set()
"""
```

#### 获取两集合差集

```python
a = {1, 2, 3}
b = {0, 1, 3}
print(a.difference(b))
"""
	理应输出：
	{2}
"""
```

#### 合并集合

```python
a = {1, 2, 3}
b = {4}
print(a.union(b))
"""
	理应输出：
	{1, 2, 3, 4}
"""
```

## 6.字典

### 定义

键值对存储。

键不可重复，但值允许重复的。

不过这玩意竟然允许嵌套：）

就是 Java 中的 Map 集合。

```python
# 字面量
a = {"a": 1, "b": 2, "c": 3}

# 定义变量
q = 1
w = 2
e = 3
b = {"a": q, "b": w, "c": e}

# 定义空元组
c = {}
d = dict()

# 嵌套
a = {"a": 1, "b": 2, "c": {"ca": 1, "cb": 2}}
```

### 获取

字典不使用下标获取，而是使用键获取。

```python
a = {"a": 1, "b": 2, "c": {"ca": 1, "cb": 2}}
print(a["c"])
"""
	理应输出：
	{'ca': 1, 'cb': 2}
"""
```

嵌套字典当然就要使用嵌套键。

```python
# 字面量
a = {"a": 1, "b": 2, "c": {"ca": 1, "cb": 2}}
print(a["c"]["ca"])
"""
	理应输出：
	1
"""
```

### 方法

#### 添加或更新键值对

```python
a = {"a": 1, "b": 2, "c": 3}
a["a"] = 10
print(a)
"""
	理应输出：
	{'a': 10, 'b': 2, 'c': 3}
"""
```

#### 按键取值并删除

```python
a = {"a": 1, "b": 2, "c": 3}
print(a.pop("a"))
print(a)
"""
	理应输出：
	1
	{'b': 2, 'c': 3}
"""
```

#### 清空字典

```python
a = {"a": 1, "b": 2, "c": 3}
a.clear()
print(a)
"""
	理应输出：
	{}
"""
```

#### 获取全部键

```python
a = {"a": 1, "b": 2, "c": 3}
print(a.keys())
"""
	理应输出：
	dict_keys(['a', 'b', 'c'])
"""
```

### 遍历

似乎，不太适合用 `while` 循环。

最好还是使用 `for` 循环。

倒是会区分遍历键或值。

#### 遍历键

```python
a = {"a": 1, "b": 2, "c": 3}
for key in a:
    print(key)
"""
	理应输出：
	a
    b
    c
"""
```

#### 遍历值

```python
a = {"a": 1, "b": 2, "c": 3}
for value in a.values():
    print(value)
"""
	理应输出：
    1
    2
    3
"""
```

#### 遍历键值对

```python
a = {"a": 1, "b": 2, "c": 3}
for key, value in a.items():
    print(key, value)
"""
	理应输出：
    a 1
    b 2
    c 3
"""
```

## 7.小结

### 真正的小结

#### 三种特性支持

关于索引支持：

- 支持：列表，元组，字符串（序列类型）
- 不支持：集合，字典（非序列类型）

关于重复元素支持：

- 支持：列表，元组，字符串（序列类型）
- 不支持：集合，字典（非序列类型）

关于修改支持：

- 支持：列表，集合，字典
- 不支持：元组，字符串

#### 数据容器通用方法

##### 获取元素数量

```python
# len(任意容器)
a = {"a": 10, "b": 2, "c": 3}
print(len(a))
```

##### 转为列表

```python
a = {"a": 10, "b": 2, "c": 3}
print(list(a))
```

##### 转为元组

```python
a = {"a": 10, "b": 2, "c": 3}
print(tuple(a))
```

##### 转为字符串

```python
a = {"a": 10, "b": 2, "c": 3}
print(str(a))
```

##### 转为集合

```python
a = {"a": 10, "b": 2, "c": 3}
print(set(a))
```

##### 排序

```python
# reverse=True 为倒序
a = {"a": 10, "b": 2, "c": 3}
print(sorted(a, reverse=True))
```

### 练习题

#### 信息管理

使用字典管理学生信息。每个学生的信息包括姓名、年龄和成绩。程序需要实现以下功能：

- 添加学生信息
- 删除学生信息
- 查询学生信息
- 显示所有学生信息

```python
stu = {}
def add_student():
    name = input("新学生名字：")
    age = input("新学生年龄：")
    score = input("新学生分数：")
    stu[len(stu)] = {"name": name, "age": int(age), "score": int(score)}
    return


def del_student():
    id = input("要删除的学生编号：")
    stu.pop(int(id))
    return


def sel_student():
    id = input("要搜索的学生编号：")
    print(stu[int(id)])
    return


def show_student():
    print(stu)
    return


while 1 > 0:
    str = input("输入操作（1添加，2删除，3搜索，4展示，5退出）：")
    if str == "1":
        add_student()
    elif str == "2":
        del_student()
    elif str == "3":
        sel_student()
    elif str == "4":
        show_student()
    elif str == "5":
        break
    else:
        print("无效操作")
```

#### 购物清单管理

使用列表管理购物清单。程序需要实现以下功能：

- 添加商品到购物清单
- 从购物清单中删除商品
- 显示购物清单
- 统计购物清单中商品的数量

```python
car = []


def add_car():
    name = input("商品名：")
    car.append(name)
    return


def del_car():
    name = input("商品名：")
    car.remove(name)
    return


def show_car():
    print(car)
    return


def count_car():
    print(len(car))
    return


while 1 > 0:
    str = input("输入操作（1添加，2删除，3展示，4商品数量，5退出）：")
    if str == "1":
        add_car()
    elif str == "2":
        del_car()
    elif str == "3":
        show_car()
    elif str == "4":
        count_car()
    elif str == "5":
        break
    else:
        print("无效操作")
```

# 6，文件操作

## 1.读取

首先说一下。

这一章似乎就是 Java 里面的 IO 流的说。

### 获得文件对象

`'r'` 只读。

```python
# 变量 = open(file, mode, encoding)
file_object = open("C:\\Users\\李进峰\\Desktop\\kl.txt", "r", encoding="utf-8")
print(file_object, "\n")
```

### 获取文件全部内容

直接认识以下 `with` 算了。

专门用于打开文件，结束时会自己关闭。

```python
# 文件对象.read() 读取全部
# 文件对象.read(num) 读取指定长度字节
with open("C:\\Users\\李进峰\\Desktop\\kl.txt", "r", encoding="utf-8") as file:
    content = file.read()
    print("文件全部内容：")
    print(content)
```

### 获取文件所有行

上面的一次拿完。

这个分行拿。

```python
# 文件对象.readlines()
with open("C:\\Users\\李进峰\\Desktop\\kl.txt", "r", encoding="utf-8") as file:
    lines = file.readlines()
    print("\n文件所有行：")
    for line in lines:
        print(line.strip())
```

## 2.写入

也是用 `open` 方法。

操作模式换一下就行。

### 全覆盖写入

```python
# 给个 `w`
with open("write_example.txt", "w", encoding="utf-8") as file:
    file.write("Hello, World!\n")
    file.write("这是第二行内容。\n")
```

### 追加写入

这玩意若没有文件会创建文件。

```python
# 给个 `a`
with open("write_example.txt", "a", encoding="utf-8") as file:
    file.write("Hello, World!\n")
    file.write("这是第二行内容。\n")
```

## 3.小结

### 日志管理

设计一个简单的日志管理系统，能够实现以下功能：

- 添加新的日志记录（包括时间、事件类型、描述等信息）
- 查看所有日志记录
- 根据事件类型筛选日志
- 清空日志文件

```python
def add_log():
    log_time = input("Enter the time of log: ")
    log_type = input("Enter the type of log: ")
    log_content = input("Enter the content of log: ")
    with open(file_address, "a", encoding="utf-8") as f:
        f.write(f"{log_time}:\nlog type:{log_type}\nlog content:{log_content}\n\n")


def show_log():
    with open(file_address, "r", encoding="utf-8") as f:
        print(f.read())


def select_log():
    log_type = input("Enter the time of log: ")
    log_line_list = ()
    with open(file_address, "r", encoding="utf-8") as f:
        lines = f.readlines()
        for index, line in enumerate(lines):
            if f"log type:{log_type}" in line.strip():
                if index > 0:
                    print(lines[index - 1].strip())
                print(line.strip())
                if index + 1 < len(lines):
                    print(lines[index + 1].strip())
                print()


def del_log():
    with open(file_address, "w", encoding="utf-8") as f:
        f.write("")


file_address = "test.txt"
while 1 > 0:
    input_str = input("Enter a number(1:add, 2:show, 3:select, 4:clear, 5:exit): ")
    if input_str == "1":
        add_log()
    elif input_str == "2":
        show_log()
    elif input_str == "3":
        select_log()
    elif input_str == "4":
        del_log()
    elif input_str == "5":
        break
    else:
        print("Invalid input")
```

# 7，异常

## 1.捕获

一般程序出现BUG会有两种情况。

- 整个程序因为这个BUG停止运行。
- 提示或压制BUG，程序继续运行。

一般都会出现第一种情况。

异常处理就是为了让第一种情况变成第二种情况。

### 全部捕获

下面就是试图打开不存在的文件，然后捕获并作出反应。

```python
try:
    file = open("a.txt", "r")
    # 可能出现问题的语句
except:
    # 出现问题后要干嘛
    print("error")
```

### 指定单个捕获

如果只需要揪着某个错误不放就用这个。

```python
try:
    # file = open("a.txt", "r") 因为不是‘NameError’所以还是会报错
    print(name)
    # except 错误名 as 别名
except NameError as e:
    print("error")
```

### 指定多个捕获

揪着好几个不放。

```python
try:
    file = open("a.txt", "r")
    print(name)
except (FileNotFoundError, NameError):
    print("error")
```

### 异常否则块

就是没有异常就干嘛。

和 Java 里面的 finally  块有点不一样的。

finally 块是不论怎样一定执行，这里的 else 块是正常才执行。

```python
try:
    name = "name"
    print(name)
except NameError:
    print("error")
else:
    print("normal")
```

### 异常终结块

这和 Java 的 finally 就是一样的了。

都是不管报不报错都要执行的。

```python
try:
    name = "name"
    print(name)
except NameError:
    print("error")
else:
    print("normal")
finally:
    print("finally")
```

## 2.异常传递

没有捕获的异常会向上级抛出。

若一路都没有拦截捕获那程序就干脆摆烂了。

下面就因为一路都没有捕获异常，结果异常直接把程序干沉默了。

```python
def test_a():
    print("come to A")
    print(name)


def test_b():
    print("come to B")
    test_a()


test_b()
```

而下面的三种方法均拦截了异常（不管在哪里拦的，拦到就行）。

```python
def test_a():
    print("come to A")
    try:
        print(name)
    except:
        print("catch")


def test_b():
    print("come to B")
    test_a()


test_b()
```

```python
def test_a():
    print("come to A")
    print(name)


def test_b():
    print("come to B")
    try:
        test_a()
    except:
        print("catch")


test_b()
```

```python
def test_a():
    print("come to A")
    print(name)


def test_b():
    print("come to B")
    test_a()


try:
    test_b()
except:
    print("catch")
```

# 8，模块

## 1.导入

这里的模块就类似 Java 里的 jar 包。

都可以定函数（方法），类，变量，可执行代码啥的。

一般用 .py 结尾。

下面就是导入了 time 模块，并使用了里面的 sleep 方法。

```python
# [from 模块名] import [模块 | 类 | 变量 | 函数 | *] [as 别名]
import time

print(1)
# 只导入了模块，这里用的方法要指定模块取出来
time.sleep(1)
print(2)
```

这个又是导入来源 time 模块中的所有东西。

```python
from time import *

print(1)
# 导入了模块里面的东西，可以直接用
sleep(1)
print(2)
```

或者给它们取个别名（感觉不会怎么用到）。

```python
import time as test

print(1)
test.sleep(1)
print(2)
```

## 2.自定义模块

其实就是引用其它类罢了（反正 java 里面叫类）。

工具类（文件）。

```python
def sum(a, b):
    return a+b
```

使用。

```python
import newPack

print(newPack.sum(1, 1))
```

注意在同时引用多个模块且同名时，最后引用的会覆盖前面的。

```python
import newPack as a
import time as a

# 这里因为最后是time模块覆盖了，所以没有这个sum方法
print(a.sum(1, 1))
```

## 3.隔离调试语句

还是上面的例子。

若这个提供方法的模块里面有一些调试语句。

但正式运行时不想要这个调试语句被运行。

那就可以用这玩意。

```python
def sum(a, b):
    return a+b


# 这里的调试语句在方法被调用时就会运行
print("a")
```

```python
def sum(a, b):
    return a+b


# 加上这个判断只有在右键直接运行这个类时才会窒执行里面的语句
if __name__ == '__main__':
    print("a")
```

## 4.隔离专有元素

当某个模块中的某些元素不想被其它地方使用时可以用。

不过这种方法只有在使用 `from 模块名 import *` 语法导入时管用的样子。

```python
from newPack import *

print(sum(1, 1))
print(sum_pro(1, 1))
```

```python
# 这两个方法均可被使用
def sum(a, b):
    return a+b


def sum_pro(a, b):
    return a+b+1
```

```python
# 这里限制仅sum可以被外部使用
__all__ = ['sum']


def sum(a, b):
    return a+b


def sum_pro(a, b):
    return a+b+1
```

# 9，包

## 1.包是啥

包其实就是一个装了好多个其它模块的，叫 `__init__.py` 的文件与那些包组成的文件夹。

反正就是文件夹！

和 Java 项目里面的包差不多的。

文件夹右下角多个小圆圈的图表就是包。

`__init__.py` 文件其实也就是装一个上面提到的隔离元素的玩意。

顺便可以在包内模块被调用时，先执行一下`__init__.py` 里面的代码（默认就会跑的）。

想在这个包的任意模块被调用前干点啥就能写在这里面。

限制一下包里面有那些东西可以被外部使用。

## 2._ _ init _ _

简单说就是指定包中允许外部可见的模块或方法，定义包中成员被使用前的必定执行逻辑。

```python
# 工具方法
def sum_self(a, b):
    return a + b

def sub_self(a, b):
    return a - b





# __init__
__all__ = ['sum_self', 'sub_self']

from a.util import *

print("come in")





# 调用工具方法
from a import *

print(sum_self(1, 1))
print(sub_self(4, 1))
```

可以全导或者隔离。

上面就是选择性隔离，指定了哪些就只能用哪些方法。

如果就是全部模块都整出去，不管什么隔不隔离的，那么不加all就行。

```python
# __all__ = ['sum_self', 'sub_self'] 不用这个了

from a.util import *
from a.hello import *

print("come in")
```

## 3.更多导入

一般就是这四种方法。

其它别人写的包也是这么导入的。

```python
import *

import packageName

from packageName import modelName/functionName

from packageName import *
```

## 4.三方包

非官方的，牛逼家伙写的，专门用于处理某些问题情况的，装了一堆 .py 文件的文件夹。

一般 Python 常用的三方包有（Python 一般也就是干这些活的）：

- 科学计算：numpy
- 数据分析：pandas
- 大数据计算：pyspark，apache-flink
- 图形可视化：matplotlib，pyecharts
- 人工智能：tensorflow

用 PyCharm 右下角的解释器设置直接搜索下载就行了。

## 5.小结

创建一个自定义包，名称为：my_utils。

在包内提供2个模块。

- str_util.py（字符串相关工具）
  - 函数：str_reverse(s)，接受传入字符串，将字符串反转返回。
  - 函数：substr(s，x，y)，按照下标x和y，对字符串进行切片。

- file_util.py（文件处理相关工具）
  - 函数：print fileinfo(file name)，接收传入文件的路径，打印文件的全部内容，如文件不存在则捕获异常，输出提示信息，通过finally关闭文件对象。
  - 函数:append tofile(file name，data)，接收文件路径以及传入数据，将数据追加写入到文件中。

最后调用这个包中的四个方法。

```python
# Main.py
import my_utils

print(my_utils.str_reverse("123"))
print(my_utils.substr("123456", 2, 6))

my_utils.print_fileinfo("Main.py")
my_utils.append_tofile("Main.py", "Hello World")
```

```python
# str_util.py
def str_reverse(s):
    str = ""
    length = len(s)
    while length > 0:
        str += s[length - 1]
        length -= 1
    return str


def substr(s, x, y):
    x = x - 1
    str = ""
    while x <= y:
        if x == y:
            break
        str += s[x]
        x += 1
    return str
```

```python
# file_util.py
def print_fileinfo(file_path):
    try:
        file = open(file_path, "r", encoding="utf-8")
    except FileNotFoundError:
        print("File not found")
    else:
        content = file.read()
        print(content)
    finally:
        file.close()


def append_tofile(file_path, data):
    with open(file_path, "a", encoding="utf-8") as file:
        file.write(data)
```

# 10，对象

## 1.认识对象

不细说了，和 Java 中的对象意义与作用几乎一样。

还是个数据结构，用于方便组织和使用数据。

结构几乎也是和 Java 中的对象一样。

这里的 self 就像 Java 中的 this。

```python
# 也是用class定义，最少要有成员属性
class Person:
    name = None
    age = None
    sex = None
    # 成员方法
    def say_hello(self):
    print("Hello my name is " + self.name)

# 实例对象
zs = Person()
# 赋值（似乎不给get，set）
zs.name = "张三"
zs.age = 18
zs.sex = "男"

# 输出对象值
print(zs.name)
# 调用对象的方法
zs.say_hello()
```

## 2.构造器

不过这玩意似乎只能给有参构造器。

且给了构造器就不能空实例了。

```python
class Person:
    name = None
    age = None
    sex = None
    # 构造器
    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex


zs = Person("张三", 18, "男")
print(zs.name)
```

## 3.“toString”方法

就是和 Java 中的 toString 一样作用的。

```python
class Person:
    name = None
    age = None
    sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex
    # 输出完整对象（可以自己定义输出内容的）
    def __str__(self):
        return f"Person: [name:{self.name}, age:{self.age}, sex:{self.sex}]"


zs = Person("张三", 18, "男")
print(zs)
```

## 4.完整对象

```python
class Person:
    name = None
    age = None
    sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.sex = sex

    def __str__(self):
        return f"Person: [name:{self.name}, age:{self.age}, sex:{self.sex}]"

    def say_hello(self):
        print("Hello my name is " + self.name)
```

## 5.私有成员

加上 `__` 就算是私有成员了。

私有成员不能直接访问的。

只能是通过对象提供的方法访问。

```python
class Person:
    name = None
    age = None
    __sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.__sex = sex

    def __say_hello(self):
        print("Hello my name is " + self.name)

    def say(self):
        print(self.__sex)


zs = Person("张三", 18, "男")
# 报错 print(zs.sex)
# 报错 zs.__say_hello()
zs.say()
```

## 6.空对象

就是啥都没有的对象。

因为死人 Python 没有漂亮好用的 `{}`，所以烦得很。

```python
class Student:
    pass
```

# 11，OOP

## 1.封装

反正就是隐藏了内部细节，将数据与操作数据的方法放在一起。

且尽量保证功能专一。

没啥好说的样子。

## 2.继承

### 单继承

面向对象的概念都是通用的嘛。

这里也是一样的。

```python
class Person:
    name = None
    age = None
    __sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.__sex = sex

    def say_hello(self):
        print("Hello my name is " + self.name)


# Python 好多玩意都不用给关键字，写的怪怪的
# 类名(父类名)
class Student(Person):
    def __init__(self, name, age, sex):
        # 继承构造方法，就是类似 super
        # 但这种写法更像调用
        Person.__init__(self, name, age, sex)


zs = Student("张三", 18, "男")
zs.say_hello()
```

### 多继承

若有多继承时，不同父类有同名成员。

以左边（先继承的）优先级最高。

```python
class Person:
    name = None
    age = None
    __sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.__sex = sex


class Monitor:
    def say(self):
        print("I am a monitor")


class Student(Person, Monitor):
    def __init__(self, name, age, sex):
        Person.__init__(self, name, age, sex)


zs = Student("张三", 18, "男")
zs.say()
```

### 方法重写

也是一样的。

```python
class Person:
    name = None
    age = None
    __sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.__sex = sex


class Monitor:
    def say(self):
        print("I am a monitor")


class Student(Person, Monitor):
    def __init__(self, name, age, sex):
        Person.__init__(self, name, age, sex)

    def say(self):
        print("I am a student, and I am a monitor")


zs = Student("张三", 18, "男")
zs.say()
```

### 回用父类方法

也就是子类重写完父类方法，但又要用回父类方法。

方法2好用，方便传参。

```python
class Person:
    name = None
    age = None
    __sex = None

    def __init__(self, name, age, sex):
        self.name = name
        self.age = age
        self.__sex = sex


class Monitor:
    def say(self):
        print("I am a monitor")


class Student(Person, Monitor):
    def __init__(self, name, age, sex):
        Person.__init__(self, name, age, sex)

    def say(self):
        print("I am a student, and I am a monitor")
        # 方法1：父类名.方法名（self）
        Monitor.say(self)
        # 方法2：super().方法名()
        print(super().say())


zs = Student("张三", 18, "男")
zs.say()
```

## 3.类型注解

用来定义预期数据类型（不是 Java 那个@的注解）。

麻烦得很。

（飞舞Python，喜欢弱类型，看人家Java强定义类型就没这破事）。

（Python越学越看不懂语法，乱七八糟，七零八碎）。

类型注解只是提示建议，不会强制限制。

### 变量，方法注解

```python
from typing import List, Dict, Tuple, Set

# 变量类型注解
# 限制存放int与str类型
var_1: int = 10
var_2: str = "abc"
# 限制存放 列表 类型
numbers: List[int] = [1, 2, 3]
# 限制存放 字典 类型
person: Dict[str, str] = {"name": "Alice", "city": "Beijing"}
# 限制存放 元组 类型
coordinates: Tuple[int, int] = (10, 20)
# 限制存放 集合 类型
unique_numbers: Set[int] = {1, 2, 3}


# 方法类型注解
# 限制接收参数为str类型
def greet(name: str):
    return f"Hello, {name}!"
```

### 不定类型

但不是完全不定。

只是允许某种类型加个 None（空）而已。

```python
from typing import Optional


# 限制返回为None或str类型
def get_name() -> Optional[str]:
    return None


print(get_name())
```

### 联合类型

这才是允许多种类型。

（这个感觉还算是有点用处）。

```python
from typing import Union


# 限制接收参数为int,str,或None类型
def get_name(data: Union[int, str, None]):
    return data


print(get_name(None))
```

## 4.多态

不同对象对同一消息做出不同回应。

下面用 Java 学习时几乎都会见到的例子举例。

```python
# 一个动物抽象类，表示所有动物
# 所有动物都会叫（至少猫狗会叫）
class Animal:
    def speak(self):
        pass


# 一个狗类，继承Animal，表示属于它
class Dog(Animal):
    def speak(self):
        print("I am a Dog")


# 一个猫类，继承Animal，表示属于它
class Cat(Animal):
    def speak(self):
        print("I am a Cat")


# 狗和猫均继承Animal，且实现不同的叫声
# 同一个东西，不同的反应，就算是多态（吧）
cat = Cat()
dog = Dog()

cat.speak()
dog.speak()
```

# 12，补充：图形可视化开发

## 1.Python 中的 Json

json是啥不再讲了。

python可以导入json包（自带的）进行操作。

json只是格式，转为json后类型变成字符串。

```python
import json


data = [{"name": "zs", "age": 18}, {"name": "ls", "age": 20}]
data = json.dumps(data) # 转为json
print(type(data)) # <class 'str'>
data = json.loads(data) # 转为python
print(type(data)) # <class 'list'>
```

## 2.pyecharts折线图

pyecharts去PyCharm右下角找这个包直接安装就好。

```python
from pyecharts.charts import Line

# 创建折线图对象
line = Line()
# 添加X轴
line.add_xaxis(["1", "2", "3"])
# 添加Y轴
line.add_yaxis("time", [10, 20, 30])
line.render()
```

运行后根目录会冒出来一个html，打开就是了。

下面是一个较为完整的例子（有一堆设置，自己去查干嘛用的）。

```python
from pyecharts.charts import Line
from pyecharts.options import TitleOpts
from pyecharts.options import LegendOpts
from pyecharts.options import ToolboxOpts
from pyecharts.options import VisualMapOpts
from pyecharts.options import DataZoomOpts
from pyecharts import options as opts

# 创建折线图对象
line = Line(
    init_opts=opts.InitOpts(
        bg_color="#f5f5f5"
    )
)
# 添加X轴
line.add_xaxis(["1", "2", "3"])
# 添加Y轴
line.add_yaxis("time", [10, 20, 30])

line.set_global_opts(
    title_opts=TitleOpts(
            title="折线图标题",
            subtitle="副标题",
            pos_left="center",
            title_textstyle_opts={"color": "red", "font_size": 20}
        ),
    legend_opts=LegendOpts(
        pos_top="bottom",
        orient="horizontal",
        textstyle_opts={"color": "black", "font_size": 14}
    ),
    toolbox_opts=ToolboxOpts(
        is_show=True,
        feature={
            "saveAsImage": {"title": "保存图片"},
            "dataView": {"title": "数据视图"},
            "dataZoom": {"title": "数据缩放"},
            "restore": {"title": "恢复"},
        }
    ),
    visualmap_opts=VisualMapOpts(
        is_show=True,
        min_=0,
        max_=100,
        orient="horizontal",
        pos_bottom="10%",
        range_color=["#D7DA8B", "#EAC763", "#D56"]
    ),
    datazoom_opts=DataZoomOpts(
        is_show=True,
        type_="inside",
        range_start=0,
        range_end=100
    )
)

# 生成
line.render()
```

# 13，闭包

用于避免汉函数内成员，如变量被外部改动，影响结果。

也可以实现不用定义全局变量而持续访问某个值。

下面这个例子使用全局变量，函数外部也可以随便改动，那么存款余额就会出问题。

```python
account = 0

def atm(num, deopsit=True):
    global account
    if deopsit:
        account += num
        print(account)
    else:
        account -= num
        print(account)


atm(100)
atm(100, False)
account += 100
atm(100)
```

而这和例子修改为了闭包实现，避免了函数外的影响。

使用包装函数包裹功能函数。

包装函数接收功能函数所需参数，返回功能函数本身。

避免了功能函数内部内随便改动的问题。

因为玩意相当于把方法实例化了，里面的功能函数和包装函数的值就是对象成员嘛。

持久存在的同时，内存当然是要牺牲一点的了。

```python
def account_create(account=0):
    def atm(num, deopsit=True):
        nonlocal account
        if deopsit:
            account += num
            print(account)
        else:
            account -= num
            print(account)
    return atm


# 先要实例包装函数
# fn = account_create([预设值])
fn = account_create()

# 然后使用包装函数给出的功能函数
# 这里传递的参数就是给了功能函数了
fn(100)
fn(100, False)
fn(100)
```

反正，闭包的基本结构就是下面这样：

```python
def 包装函数名(预设变量名=值):
    def 功能函数名(形参组):
        代码块...
    return 功能函数名
```

# 14，装饰器

@就是装饰器。

作用就像代理。

跟春天里面的AOP差不多的意思。

不动原有玩意的前提下干点坏事。

```python
# 搞一个外套函数，相当于代理函数，参数传的函数就是需要代理的函数
def outside(func):
    # 接一个内套函数，一个代理壳
    def inside(*args, **kwargs):
        # 增强逻辑...
        print("inside")
        # 调用原函数
        return func(*args, **kwargs)
    return inside

# 外套函数加@就行了，把test函数代理进outside，于inside内增强并执行
@outside
def test():
    print("other")

print(test())
```

# 15，连接mysql

打上pymysql驱动就行。

```python
from pymysql import *

# 返回这个方法即可，把连接参数甩进去
def get_conn() -> Connection:
    return connect(
        host="localhost",
        port=3307,
        user="root",
        passwd="root",
        database="java211",
        charset="utf8"
    )

print(get_conn())
```

然后试试执行语句。

```python
# 添加，带个参数
def add(data: str):
    with get_conn() as conn, conn.cursor() as cursor:
        # 定个语句
        sql = "insert into users (u_name) values (%s)"
        try:
            # 传值执行
            cursor.execute(sql, data)
            # 提交事务
            conn.commit()
        except Exception as e:
            # 报错回滚
            conn.rollback()

add("wu")





# 查询全部
def sel():
    with get_conn() as conn, conn.cursor() as cursor:
        sql = "select * from users"
        try:
            # 不用参数，直接执行
            cursor.execute(sql)
            conn.commit()
            # 将全部结果返回
            return cursor.fetchall()
        except Exception as e:
            conn.rollback()

print(sel())
```

# 16，单元测试

很简单且简陋的单元测试。

```python
import unittest

# 必须继承unittest.TestCase
class Test(unittest.TestCase):
    # 其中一个测试方法
    def test_upper(self):
        str = 'str'.upper()
        # 参数1是运行结果，参数2是期望结果
        self.assertEqual(str, 'FOO')
```

还能给测试加环绕增强逻辑。

又是跟AOP一个意思。

setup和teardown会在单元测试前和结束后执行。

```python
import unittest

class Test(unittest.TestCase):

    # 重写方法
    def setUp(self):
        print("before")

    # 重写方法
    def tearDown(self):
        print("after")

    def test_upper(self):
        str = 'str'.upper()
        self.assertEqual(str, 'FOO')
```

