[TOC]

# SpringMVC

# 1，简介

## 1. 这是啥

SpringMVC 是 Spring 框架的一部分，是基于 Java 的 Web 开发框架。

它和 Spring 加 MyBatis 就是 SSM 体系了。

## 2. MVC 架构

MVC（Model-View-Controller）是一种软件架构模式，常用于设计用户界面与业务逻辑分离的应用程序。

它将应用程序分为三个主要部分：

- 模型（Model）：
  - 应用程序的业务逻辑和数据层。
  - 它封装了应用程序的数据、业务规则以及与数据相关的操作。
    - 存储和管理应用程序的数据。
    - 实现业务逻辑和数据验证。
    - 提供数据的访问接口。
- 视图（View）：
  - 应用程序的用户界面层。
  - 它负责向用户展示数据和接收用户的输入。
    - 显示模型中的数据。
    - 提供用户交互的界面。
    - 根据模型的变化更新显示内容。
- 控制器（Controller）：
  - 应用程序的协调层。
  - 它负责处理用户请求，与模型交互，并选择适当的视图进行响应。
    - 接收和处理用户请求。
    - 调用模型的方法更新数据。
    - 选择视图进行响应。

# 2，总控 Servlet

## 1. 简介

一般指 DispatcherServlet。

算是 SpringMVC 的核心组件之一。

主要负责接收所有的HTTP请求，并将这些请求分发给相应的处理器（Controller）进行处理。

按常规方法写 Servlet 会导致一个请求配一个 Servlet，数量要起飞。

但常规总控 Servlet 又会导致单个类中 if 语句分支多的起飞。

SpringMVC 就是用了总控 Servlet 概念，搭配注解与一些配置解决了上述问题。

## 2. 使用配置文件配置

### 示例页面

先搓个页面的说（html也可以的说）。

```jsp
<%--
  Created by IntelliJ IDEA.
  User: 李进峰
  Date: 2025/5/9
  Time: 9:48
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
123
</body>
</html>
```

### 请求控制器

然后搓一个请求控制器。

用来控制请求分发的。

```java
package edu.nf.ch01.web;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HelloController {
    // 定义方法映射地址
    // 访问这个地址的请求就会被总控分发这个方法
    @RequestMapping("/hello")
    public String hello() {
        // 因为内部资源视图解析器配置了前缀与后缀，这里仅需返回文件名就可以拼接为完整路径
        return "index";
    }
}
```

### web 配置

再然后搓一个 web.xml 配置。

init-param 标签对要看情况使用的（用来指定 SpringMVC 配置位置的）。

- 若在 WEB-INF 中，有使用 “servlet-name映射名” + “-servlet” 的文件存在就不用给这个标签对。
- 若这个文件放在如 resources 文件夹内，那就不管是啥名字了，必须用这标签对指定一下。

建议遵从约定，放在 WEB-INF 里面，也省了写这四行配置的功夫。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"
         version="4.0">

    <!--  配置请求总控（DispatcherServlet）地址映射  -->
    <servlet>
        <servlet-name>dispatcher</servlet-name>
        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
<!--        <init-param>-->
<!--            <param-name>contextConfigLocation</param-name>-->
<!--            <param-value>classpath:SpringMVC.xml</param-value>-->
<!--        </init-param>-->
    </servlet>
    <servlet-mapping>
        <servlet-name>dispatcher</servlet-name>
        <url-pattern>/</url-pattern>
    </servlet-mapping>
</web-app>
```

### SpringMVC 配置

下面最长的哪个用于配置视图解析器的，用于转发内部视图。

一般如 jsp 这种视图，虽说是页面，但也算一个类，理应不能直接通过 url 访问。

所以理应放进 WEB-INF 这里面藏起来。

所以需要转发进这个相对于用户的隐藏区域。

两段路径就是用来拼接完整访问路径的。

如上面请求控制器中的方法被总控 Servlet 指定使用后会返回 index 嘛。

那么最终的访问目标就是 “ 前缀 + index（方法返回）+ 后缀 ”。

这里就是 /WEB-INF/jsp/index.jsp（webapp 就是资源的根目录嘛）。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd">

    <!--  扫包  -->
    <context:component-scan base-package="edu.nf.ch01"/>
    <!--  启用 mvc 注解驱动  -->
    <!--  annotation-driven 必须用 mvc 结尾的那个引用  -->
    <mvc:annotation-driven/>
    <!--  配置内部资源视图解析器  -->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <!--  访问资源的前缀路径  -->
        <property name="prefix" value="/WEB-INF/jsp/"/>
        <!--  访问资源的后缀格式  -->
        <property name="suffix" value=".jsp"/>
    </bean>

</beans>
```

## 3. 使用配置类配置

配置文件已经过时啦：）

建议使用配置类。

### 示例页面

和上面一样即可。

不用动的说。

### 请求控制器

这个也是一样的。

只是总控用于分发请求的。

### 主配置类

也就是指定一下扫包地址。

然后把其它子配置类进入这里。

```java
package edu.nf.ch02.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

// 不用解释了吧
@Configuration
// 也是不用解释了吧
@ComponentScan(basePackages = "edu.nf.ch02")
// 引入子配置嘛
@Import({MVCConfig.class})
public class RootConfig {
}
```

### 子配置类

启动一下注解驱动，再启动一下视图解析器。

```java
package edu.nf.ch02.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
// 启用注解驱动
@EnableWebMvc
// 要重写这个类的这个方法
public class MVCConfig implements WebMvcConfigurer {
    // 启用视图解析器
    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        InternalResourceViewResolver internalResourceViewResolver = new InternalResourceViewResolver();
        // 就是前后两端
        internalResourceViewResolver.setPrefix("/WEB-INF/jsp/");
        internalResourceViewResolver.setSuffix(".jsp");
        // 注册一下解析器
        registry.viewResolver(internalResourceViewResolver);
    }
}
```

### 配置配置类

en。

算是注册配置类让起生效？

设置主配置类的位置不用给东西。

反而是设置子配置类的位置要放主配置类。

就是为了避免两层容器套娃。

父容器不给创建，在主配置类中导入其它配置类，在子容器的位置实现主配置类。

最后设置一下总控 Servlet 的映射。

给个杠，接受所有请求。

```java
package edu.nf.ch02.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    // 设置主配置类（父容器）
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    // 设置 mvc 配置类（子容器）
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    // 设置 DispatcherServlet 映射路径
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

## 4. 静态资源访问

webapp 下有个 static 文件夹。

这里一般放如 html，css，js 等静态资源。

这个文件夹内的静态资源一般是不能直接访问的。

所以要用一点特殊手段。

### 示例页面

在 webapp 下创建 static 文件夹。

里面再放一个 html 文件。

### 创建配置类

静态文件夹内的东西一般是 web 容器默认识别的。

但使用框架时，" / " 路径会被覆盖，导致无法访问静态资源。

所以需要重新配置一下。

有两种方法，重新接回容器，或手动处理。

建议是用第二种方法的。

其实就是相当于给 static 目录映射了一个新名字。

```java
package edu.nf.ch03.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ResourceHandlerRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@EnableWebMvc
public class MvcConfig implements WebMvcConfigurer {
    // 方法1：
    // 使用 Web 容器的默认 Servlet 处理器
//    @Override
//    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
//        configurer.enable();
//    }

    // 方法2：
    // 让框架自己处理
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // 页面访问 page 时
        // 导向至 static 目录，与内部的 js 和 css 共三个目录
        registry.addResourceHandler("/page/**").addResourceLocations("static/", "static/js/", "static/css/");
    }
}
```

### 配置配置类

因为这个例子没有（也不用）主配置类。

方便一点，直接就单给了一个 web 配置类。

只导这一个就行。

然后就是构建工件，启动 tomcat。

理应可以访问 index.html 了。

```java
package edu.nf.ch03.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{MvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

## 5. 参数映射

这里展示了一个页面提交表单，表单数据被总控 Servlet 分发至 controller 中的相应方法。

然后将数据映射进总控，分发至对应方法。

### 页面

创建两个页面。

一个表单页模拟登录，一个模拟主页。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>
<h2>添加用户</h2>
<form action="/add2" method="post">
    username：<input type="text" name="name" value="user1"></input><br>
    age：<input type="number" name="age" value="18"></input><br>
    birthday：<input type="text" name="birthday" value="1996-05-20"></input><br>
    phone1：<input type="text" name="phones" value="14737422720"></input><br>
    phone2：<input type="text" name="phones" value="13750237022"></input><br>
    idCard：<input type="text" name="card.id" value="123456789012345678"></input><br>
    addressCity1：<input type="text" name="addresses[0].city" value="广东"></input><br>
    addressStreet1：<input type="text" name="addresses[0].street" value="深圳"></input><br>
    addressCity2：<input type="text" name="addresses[1].city" value="广东"></input><br>
    addressStreet2：<input type="text" name="addresses[1].street" value="惠州"></input><br>
    <input type="submit" value="提交"></input>
</form>
</body>
</html>
```

```jsp
<%--
  Created by IntelliJ IDEA.
  User: 李进峰
  Date: 2025/5/12
  Time: 9:05
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
<head>
    <title>Title</title>
</head>
<body>
home page
</body>
</html>
```

### 创建配置类

创建一个 web 配置类。

定义一下路径并注册。

```java
package edu.nf.ch04.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

// 配置文件注解
@Configuration
// 启用注解驱动
@EnableWebMvc
// 扫包
@ComponentScan(basePackages = "edu.nf.ch04")
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }

    @Override
    public void configureViewResolvers(ViewResolverRegistry registry) {
        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();
        viewResolver.setPrefix("/WEB-INF/jsp/");
        viewResolver.setSuffix(".jsp");
        registry.viewResolver(viewResolver);
    }
}
```

### 配置配置类

不用讲了吧。

```java
package edu.nf.ch04.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{MvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

### 创建对象

创建三个测试用的对象。

用户，ID卡和地址三个对象。

用户包含ID卡对象，和地址对象集合。

```java
package edu.nf.ch04.entity;

import java.util.List;

public class User {
    private String name;
    private Integer age;
    private List<String> phones;
    private IdCard card;
    private List<Address> addresses;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public List<String> getPhones() {
        return phones;
    }

    public void setPhones(List<String> phones) {
        this.phones = phones;
    }

    public IdCard getCard() {
        return card;
    }

    public void setCard(IdCard card) {
        this.card = card;
    }

    public List<Address> getAddresses() {
        return addresses;
    }

    public void setAddresses(List<Address> addresses) {
        this.addresses = addresses;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phones=" + phones +
                ", card=" + card +
                ", addresses=" + addresses +
                '}';
    }
}
```

```java
package edu.nf.ch04.entity;

public class IdCard {
    private String id;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "IdCard{" +
                "id='" + id + '\'' +
                '}';
    }
}
```

```java
package edu.nf.ch04.entity;

public class Address {
    private String city;
    private String street;

    public String getCity() {
        return city;
    }

    public void setCity(String city) {
        this.city = city;
    }

    public String getStreet() {
        return street;
    }

    public void setStreet(String street) {
        this.street = street;
    }

    @Override
    public String toString() {
        return "Address{" +
                "city='" + city + '\'' +
                ", street='" + street + '\'' +
                '}';
    }
}
```

### 创建 Controller（分发）类

最后就是给总控配置分发规则了。

```java
package edu.nf.ch04.web;

import edu.nf.ch04.entity.User;
import org.springframework.format.datetime.DateFormatter;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.WebDataBinder;
import org.springframework.web.bind.annotation.*;

import java.util.Arrays;

@Controller
// 这个也可以放在类上，用于区分路径前缀
@RequestMapping(value = "/controller")
public class UserController {
    // 映射请求路径，按不同请求方法区分不同注解
    @PostMapping("/add")
//    @GetMapping("/add")
//    @PutMapping("/add")
    // ...
    // 接收请求参数
    public String add(@RequestParam("name") String name,
                      @RequestParam("age") int age,
                      @RequestParam("phones") String[] tels) {
        System.out.println(name);
        System.out.println(age);
        System.out.println(Arrays.toString(tels));
        return "index";
    }

    // 向 WebDataBinder 传递一个自定义的格式化器
    // 用于将字符串转换为日期对象
    @InitBinder
    public void regFormatter(WebDataBinder binder) {
        binder.addCustomFormatter(new DateFormatter("yyyy-MM-dd"));
    }

    // 接收 User 对象
    @PostMapping("/add2")
    public String add2(User user) {
        System.out.println(user);
        return "index";
    }
}
```

## 6. 传递至作用域

就是用于将某些数据传递到请求作用域（或其它作用域也行）。

让后续可以通过相应的作用域获取这些数据。

### 页面

基本也是不用动的。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>
<h2>添加用户</h2>
<form action="/model_1" method="post">
    username：<input type="text" name="name" value="user1"></input><br>
    age：<input type="number" name="age" value="18"></input><br>
    birthday：<input type="text" name="birthday" value="1996-05-20"></input><br>
    phone1：<input type="text" name="phones" value="14737422720"></input><br>
    phone2：<input type="text" name="phones" value="13750237022"></input><br>
    idCard：<input type="text" name="card.id" value="123456789012345678"></input><br>
    addressCity1：<input type="text" name="addresses[0].city" value="广东"></input><br>
    addressStreet1：<input type="text" name="addresses[0].street" value="深圳"></input><br>
    addressCity2：<input type="text" name="addresses[1].city" value="广东"></input><br>
    addressStreet2：<input type="text" name="addresses[1].street" value="惠州"></input><br>
    <input type="submit" value="提交"></input>
</form>
</body>
</html>
```

### Controller 类

第一种方法太多了，可以直接传入 Model 对象进行封装传递。

如第二种就是使用了 Model 对象。

前两种均为传递至请求作用域。

第三种方法可以传递至会话作用域。

会话作用域嘛，传入一个 Session 对象就好。

最后就是关于 Controller 类中方法的返回值，均为目标资源名。

这里目标是一个页面，所以都给个 index 就行。

完整地址还是在配置类中（就是视图解析器）。

```java
package edu.nf.ch04.web;

import jakarta.servlet.http.HttpSession;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class ModelController {
    // 传递请求作用域
//    @PostMapping ("/model_1")
//    public ModelAndView test_1() {
//        // 创建模型-视图对象，并定义视图名
//        ModelAndView modelAndView = new ModelAndView("index");
//        // 然后总控（DispatcherServlet）会把对象保存至 model（请求作用域）中
//        modelAndView.addObject("name", "user_1");
//        return modelAndView;
//    }

    // 传递请求作用域
    @PostMapping ("/model_2")
    public String test_2(Model model) {
        model.addAttribute("name", "user_2");
        return "index";
    }

    // 传递会话作用域
    @PostMapping ("/session")
    public String test_2(HttpSession session) {
        session.setAttribute("name", "user_3");
        return "index";
    }
}
```

### 获取

就用个 jsp 获取吧。

这个 jsp 就叫 index.jsp 的咯。

```jsp
<%--
  Created by IntelliJ IDEA.
  User: 李进峰
  Date: 2025/5/12
  Time: 9:05
  To change this template use File | Settings | File Templates.
--%>
<%@ page contentType="text/html;charset=UTF-8" language="java" %>
<html>
    <head>
        <title>Title</title>
    </head>
    <body>
<%--  请求作用域接收  --%>
<%--        name：${requestScope.name}--%>
<%--  会话作用域接收  --%>
        name：${sessionScope.name}
    </body>
</html>
```

## 7. 视图对象（VO）

一般用于方便前端对接的一种数据格式吧。

就一团 JSON 的样子。

对象中至少包含：

- 状态码
- 消息
- 值

### 依赖

这个例子需要使用序列化，去 maven 搞个可以操作 json 的包。

```xml
<!-- https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind -->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.19.0</version>
</dependency>
```

### 创建 VO 对象

```java
package edu.nf.ch05.web.vo;

// 结果集对象（统一响应视图对象）
public class ResultVO<T> {
    // 状态码
    private Integer code;
    // 消息内容
    private String message;
    // 数据
    private T data;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```

### 创建用户对象

```java
package edu.nf.ch05.entity;

public class User {
    private Integer id;
    private String name;
    private Integer age;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }
}
```

### 配置类

```java
package edu.nf.ch05.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "edu.nf.ch05")
public class MvcConfig {
}
```

```java
package edu.nf.ch05.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{MvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

### 基本 Controller 类

所有 Controller 的模板。

Controller 一般就建议使用 VO 对象进行返回。

这个基本 Controller 类就是封装了将数据打包进 VO 对象的逻辑。

```java
package edu.nf.ch05.web;

import edu.nf.ch05.web.vo.ResultVO;
import org.springframework.http.HttpStatus;

public class BaseController {
    protected <T> ResultVO<T> success(T data) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(HttpStatus.OK.value());
        resultVO.setData(data);
        return resultVO;
    }

    protected <T> ResultVO<T> success() {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(HttpStatus.OK.value());
        return resultVO;
    }

    protected <T> ResultVO<T> error(int code, String message) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(code);
        resultVO.setMessage(message);
        return resultVO;
    }
}
```

### UserController 类

```java
package edu.nf.ch05.web;

import edu.nf.ch05.entity.User;
import edu.nf.ch05.web.vo.ResultVO;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;

//@Controller
// 这玩意自带一些注解，本身也属于Controller的子注解
// 如@ResponseBody也是包含了的
// 常规的@Controller就不用了
@RestController
public class UserController extends BaseController{
    @GetMapping("/user")
    // 这个注解用于自动使用 jackson 序列化对象为 gson
    // @ResponseBody
    public ResultVO<User> getUser() {
        User user = new User();
        user.setId(1);
        user.setName("zs");
        user.setAge(18);
        return success(user);
    }
}
```

最后启动项目，在 URL 中直接输入这个 controller 中方法的映射地址即可。

理应会喷一段 json 数据直接显示在页面中的。

## 8. 报错处理

这里使用一个登录场景作为例子。

展示一下用切面（AOP）处理报错。

使用自定义异常改写常规报错流程。

### 登陆页面

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>

<body>
<form action="/auth" method="post">
    name：<input type="text" name="account"></input><br>
    pass：<input type="number" name="password"></input><br>
    <input type="submit" value="提交"></input>
</form>
</body>
</html>
```

### 用户对象

```java
package edu.nf.ch06.entity;

public class User {
    private String name;
    private String pass;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPass() {
        return pass;
    }

    public void setPass(String pass) {
        this.pass = pass;
    }
}
```

### 配置类

这前面的三件不用讲了吧。

```java
package edu.nf.ch06.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.ViewResolverRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;
import org.springframework.web.servlet.view.InternalResourceViewResolver;

@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "edu.nf.ch06")
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();  // 启用默认的Servlet处理静态资源
    }
}
```

```java
package edu.nf.ch06.config;

import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{MvcConfig.class};
    }

    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

### VO 对象

```java
package edu.nf.ch06.web.vo;

// 结果集对象（统一响应视图对象）
public class ResultVO<T> {
    // 状态码
    private Integer code;
    // 消息内容
    private String message;
    // 数据
    private T data;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```

### 自定义报错

错误对象。

包含错误码与错误信息。

错误码可以自己定义，但错误信息都是字符串，没必要重新折腾一次。

所以单创建并定义错误码属性，继承错误信息属性。

```java
package edu.nf.ch06.exception;

public class GlobalException extends RuntimeException{
    private Integer errorCode;

    public GlobalException(Integer errorCode, String message) {
        super(message);
        this.errorCode = errorCode;
    }

    public Integer getErrorCode() {
        return errorCode;
    }
}
```

然后创建登录报错类，专门处理登录报错。

其它所有自定义的报错都要继承上面的错误对象。

```java
package edu.nf.ch06.exception;

public class LoginException extends GlobalException{
    // 专门处理登录报错的
    public LoginException(Integer errorCode, String message) {
        super(errorCode, message);
    }
}
```

最后就是报错控制器。

也算是AOP的体现吧。

自定义的异常类需要单独指定。

然后报错控制器发现程序出现被定义的报错时会插手。

直接掐进来，干涉常规报错流程。

这里将常规流程改为把错误码与消息写入 VO 对象并返回。

最后，不管有多少个自定义的异常类在这里被注册，必须有一个 Exception 被注册。

作为所有异常的基类，出现没有被自定义的异常时负责接盘。

```java
package edu.nf.ch06.exception;

import edu.nf.ch06.web.vo.ResultVO;
import org.springframework.http.HttpStatus;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice(basePackages = "edu.nf.ch06.web")
public class GlobalExceptionAdvice {
    // 捕获拦截全局所有的指定的异常
    @ExceptionHandler(LoginException.class)
    public <T> ResultVO<T> handleGlobalException(GlobalException e) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(e.getErrorCode());
        resultVO.setMessage(e.getMessage());
        return resultVO;
    }

    // 拦截所有异常（必须有）
    @ExceptionHandler(Exception.class)
    public <T> ResultVO<T> handleException(Exception e) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
        resultVO.setMessage("服务器繁忙");
        return resultVO;
    }
}
```

### 服务层

接口和实现。

```java
package edu.nf.ch06.service;

import edu.nf.ch06.entity.User;

public interface AuthService {
    User auth(String account, String password);
}
```

```java
package edu.nf.ch06.service.impl;

import edu.nf.ch06.entity.User;
import edu.nf.ch06.exception.LoginException;
import edu.nf.ch06.service.AuthService;
import org.springframework.stereotype.Service;

@Service
public class AuthServiceImpl implements AuthService {
    @Override
    public User auth(String account, String password) {
        if ("zs".equals(account)) {
            if ("123".equals(password)) {
                User user = new User();
                user.setName(account);
                user.setPass(password);
                return user;
            }
        }
        // 出问题就直接抛出自定义报错就好
        throw  new LoginException(10001, "账号或密码错误");
    }
}
```

### 控制层

控制层基类和常规 Controller。

```java
package edu.nf.ch06.web;

import edu.nf.ch06.web.vo.ResultVO;
import org.springframework.http.HttpStatus;

public class BaseController {
    protected <T> ResultVO<T> success(T data) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(HttpStatus.OK.value());
        resultVO.setData(data);
        return resultVO;
    }

    protected <T> ResultVO<T> success() {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(HttpStatus.OK.value());
        return resultVO;
    }
}
```

```java
package edu.nf.ch06.web;

import edu.nf.ch06.entity.User;
import edu.nf.ch06.exception.LoginException;
import edu.nf.ch06.service.AuthService;
import edu.nf.ch06.web.vo.ResultVO;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController extends BaseController{
    private AuthService authService;

    public  AuthController(AuthService authService) {
        this.authService = authService;
    }
    @PostMapping("/auth")
    public ResultVO<User> auth(@RequestParam("account") String account, @RequestParam("password") String pass) {
        // 使用服务层实现类方法（业务逻辑）
        User user = authService.auth(account, pass);
        // 使用控制层基类方法（返回VO对象）
        return success(user);
    }
}
```

## 9. 文件上传

关于这个核心组件的最后一个点就是文件上传功能。

和以往的直接用表单打进 Servlet 不同。

SpringMVC 虽然前端也是用表单发文件。

但是说后端接收方式是完全不同的说。

### MVC 配置

使用 Web 容器默认的管理器去访问静态资源。

```java
package edu.nf.ch08.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
// 启用注解驱动
@EnableWebMvc
public class MVCConfig implements WebMvcConfigurer {
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
```

### 主配置类

```java
package edu.nf.ch08.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
// 扫包
@ComponentScan(basePackages = "edu.nf.ch08.web")
// 导入 MVC 配置
@Import({MVCConfig.class})
public class RootConfig {
}
```

### 注册配置类

```java
package edu.nf.ch08.config;

import jakarta.servlet.MultipartConfigElement;
import jakarta.servlet.ServletRegistration;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    // 设置主配置类（父容器）
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    // 设置 mvc 配置类（子容器）
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    // 设置 DispatcherServlet 映射路径
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }

    // 启用 Servlet 上传功能
    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        // 创建上传配置对象（指定上传的根目录，单个文件大小（bit），总数据量大小（bit），接收指定大小时写入已接收的数据（bit））
        MultipartConfigElement configElement = new MultipartConfigElement("", 20971520, 2097152000, 2097152);
        // 注册配置
        registration.setMultipartConfig(configElement);
        // 让总控 Servlet 在启动 Web 时就初始化
        registration.setLoadOnStartup(0);
    }
}
```

### VO

响应对象，基本是跑不了这玩意的。

```java
package edu.nf.ch08.web.vo;

/**
 * @author wangl
 * @date 2025/5/13
 * 统一响应视图对象
 */
public class ResultVO<T> {
    /**
     * 响应码
     */
    private Integer code;
    /**
     * 响应的消息
     */
    private String message;
    /**
     * 响应的数据
     */
    private T data;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```

### 控制模板

所有 Controller 的模板类。

```java
package edu.nf.ch08.web;

import edu.nf.ch08.web.vo.ResultVO;
import org.springframework.http.HttpStatus;

/**
 * @author wangl
 * @date 2025/5/13
 */
public class BaseController {

    /**
     * 响应成功（带数据）
     * @param data
     * @return
     * @param <T>
     */
    protected  <T> ResultVO<T> success(T data) {
        ResultVO<T> vo = new ResultVO<>();
        vo.setCode(HttpStatus.OK.value());
        vo.setData(data);
        return vo;
    }

    /**
     * 仅响应成功
     * @return
     * @param <T>
     */
    protected <T> ResultVO<T> success() {
        ResultVO<T> vo = new ResultVO<>();
        vo.setCode(HttpStatus.OK.value());
        return vo;
    }
}
```

### 上传 Controller 类

```java
package edu.nf.ch08.web;

import edu.nf.ch08.web.vo.ResultVO;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.File;
import java.io.IOException;
import java.nio.file.FileSystem;
import java.nio.file.FileSystems;
import java.nio.file.Path;

/**
 * @author wangl
 * @date 2025/5/14
 */
@RestController
public class UploadController extends BaseController {
    @PostMapping("/upload")
    // MultipartFile 对象是 springmvc 封装的一个用于上传文件的对象
    // 这个对象包含文件名，文件类型，文件大小，文件输入流等信息
    public ResultVO upload(@RequestParam("files") MultipartFile[] files) throws IOException {
        // 获取（创建）上传目标目录
        File uploadDir = new File("D:\\upload");
        if (!uploadDir.exists()) {
            uploadDir.mkdirs();
        }
        // 循环文件数组
        for (MultipartFile file : files) {
            // 获取文件名
            String fileName = file.getOriginalFilename();
            // 获取文件大小
            long size = file.getSize();
            // 获取文件类型
            String fileType = file.getContentType();
            // 构建上传路径（目录 + 文件名）
            Path path = FileSystems.getDefault().getPath(uploadDir.getAbsolutePath(), fileName);
            // 执行上传
            file.transferTo(path);
        }
        // 响应VO
        return success();
    }
}
```

### 页面

选择文件后点击上传。
在指定目标地址理应会有上传的文件。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<form id="f1" enctype="multipart/form-data">
    <input type="file" name="files" multiple>
    <input type="button" value="upload">
</form>
<!--<script src="./js/jquery-3.3.1.min.js"></script>-->
<script src="https://code.jquery.com/jquery-2.1.1.min.js"></script>
<script>
    $(function () {
        $(':button').on('click', function() {
            // 创建 FormData
            let formDate = new FormData($('#f1')[0]);
            // 使用 AJAX 上传
            $.ajax({
                url: '/upload',
                type: 'post',
                data: formDate,
                processData: false, // 告知 JQ 不要处理发送的数据
                contentType: false, // 告知 JQ 不要设置 content-type
                success: function (result) {
                    if (result.code === 200) {
                        alert("上传成功")
                    }
                }
            })
        })
    })
</script>
</body>
</html>
```
