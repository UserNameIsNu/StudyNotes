[TOC]

# Spring

# 1，简介

## 1. 这是啥

Spring 是一个开源的 Java 开发框架。

它旨在简化企业级应用的开发，提供了一种轻量级的替代传统企业级开发方式（如 EJB）的解决方案。

## 2. 特色

主要就是 IOC 容器与 AOP 编程。

- IOC：控制反转。
  - 一种设计原则，用于减少代码之间的耦合度。
  - 将对象的创建和管理交给框架，而不是由开发者手动完成。
- AOP：面向切面编程。
  - 一种编程范式，用于将横切关注点（如日志记录、事务管理、安全检查等）与业务逻辑分离。
  - 将这些横切关注点模块化，以实现代码的复用和解耦。

IOC 负责对象的创建和管理，AOP 负责在对象之间织入横切关注点。

还有其它一些玩意：

- 非侵入式：
  - 基于 Spring 开发的应用中的对象可以不依赖于 Spring 的 API。
- 依赖注入：
  - 如动态代理等均为 IOC 的典型实现。
- 面向切面编程：
  - 切割代码，模块化开发。
- 容器：
  - 包含并管理应用对象的声明周期。
- 组件化：
  - 使用各种组件组合成一个应用。
- 一站式：
  - 提供了一系列框架，为开发中的各种问题提供解决方案。

## 3. 重要名词解释

- 组件：
  - 具有一定功能的对象。
- 容器：
  - 管理组件（创建，获取，保存，销毁）。

- IOC（控制反转）：
  - 控制：
    - 资源的控制权（创建，获取，销毁）。
  - 反转：
    - 和传统方法不同。
- DI（依赖注入）：
  - 依赖：
    - 组件的依赖关系。
  - 注入：
    - 通过 setter 方法，构造器等方式自动注入（赋值）。

## 4. 依赖

使用 spring 前，可以在项目 maven 中引入 spring 的最上层依赖。

最上层会帮你把后续所有依赖拉进来。

依赖 spring-context 就行。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>spring-study</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <modules>
        <module>ch01</module>
        <module>ch02</module>
        <module>ch03</module>
    </modules>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!-- https://mvnrepository.com/artifact/org.springframework/spring-context -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-context</artifactId>
            <version>6.2.5</version>
        </dependency>
    </dependencies>
</project>
```

# 2，Spring IOC

## 1. Bean 的装配

Bean 感觉就算是组件了。

组件被容器管理嘛。

这个例子使用 XML 进行装配。

虽然说推荐使用注解装配，后续再补充注解装配。

### 模板声明

先创建一个接口。

```java
package edu.nf.ch01.service;

public interface UserService {
    void add();
}
```

### 实现

然后就是实现接口。

Bean 有四种装配方法，就先实现四次接口。

```java
package edu.nf.ch01.service.impl;

import edu.nf.ch01.service.UserService;

public class UserServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("add user");
    }
}
```

```java
package edu.nf.ch01.service.impl;

import edu.nf.ch01.service.UserService;

public class PeopleServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("add people");
    }
}
```

```java
package edu.nf.ch01.service.impl;

import edu.nf.ch01.service.UserService;

public class StudentServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("add student");
    }
}
```

```java
package edu.nf.ch01.service.impl;

import edu.nf.ch01.service.UserService;

public class TeacherServiceImpl implements UserService {
    @Override
    public void add() {
        System.out.println("add teacher");
    }
}
```

### 构建工厂

后三种方法才需要工厂。

所以构建三个工厂就好了。

```java
package edu.nf.ch01.factory;

import edu.nf.ch01.service.UserService;
import edu.nf.ch01.service.impl.PeopleServiceImpl;

public class PeopleServiceFactory {
    public UserService create() {
        // 工厂产出的对象也会被管理
        return new PeopleServiceImpl();
    }
}
```

```java
package edu.nf.ch01.factory;

import edu.nf.ch01.service.UserService;
import edu.nf.ch01.service.impl.StudentServiceImpl;

public class StudentServiceFactory {
    public static UserService create() {
        return new StudentServiceImpl();
    }
}
```

```java
package edu.nf.ch01.factory;

import edu.nf.ch01.service.UserService;
import edu.nf.ch01.service.impl.TeacherServiceImpl;
import org.springframework.beans.factory.FactoryBean;

public class TeacherServiceFactoryBean implements FactoryBean<UserService> {
    // 获取对象本身
    @Override
    public UserService getObject() throws Exception {
        return new TeacherServiceImpl();
    }

    // 获取对象Class
    @Override
    public Class<?> getObjectType() {
        return TeacherServiceImpl.class;
    }

    // 是否以单例模式管理对象（一般就需要单例管理，默认就是单例，不给也行）
    @Override
    public boolean isSingleton() {
        return true;
    }
}
```

### 构建 Bean

在 Beans.xml 中定义 Bean。

四种方法分别是：

- 装配实现类本身。
- 装配自定义工厂。
- 装配静态自定义工厂。
- 装配 FactoryBean 工厂（一般就用这个了）。

注意将工厂本身装配为 Bean 并管理时。

工厂内产出的对象也会被一并管理。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--  id：Bean在容器中的标识  -->
    <!--  class：这个标识映射的实际类（容器保存对象，所以需要实现类做实例模板）  -->
    <bean id="userService" class="edu.nf.ch01.service.impl.UserServiceImpl"/>

    <!--  上面装配类，这次装配工厂  -->
    <bean id="peopleServiceFactory" class="edu.nf.ch01.factory.PeopleServiceFactory"/>
    <!--  id：意思一样  -->
    <!--  factory-bean：工厂Id  -->
    <!--  factory-method：工厂创建方法  -->
    <bean id="peopleService" factory-bean="peopleServiceFactory" factory-method="create"/>

    <!--  装配静态工厂  -->
    <!--  仅管理被生产的对象，不会管理工厂本身  -->
    <bean id="studentService" class="edu.nf.ch01.factory.StudentServiceFactory" factory-method="create"/>

    <!--  使用FactoryBean创建受管理的Bean对象  -->
    <bean id="teacherService" class="edu.nf.ch01.factory.TeacherServiceFactoryBean"/>
</beans>
```

### 调用测试

```java
package edu.nf.ch01.service;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {
        // 使用xml初始化容器
        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Beans.xml");
        // 获取Bean
//        UserService service = applicationContext.getBean("userService", UserService.class);
//        UserService service = applicationContext.getBean("peopleService", UserService.class);
//        UserService service = applicationContext.getBean("studentService", UserService.class);
        UserService service = applicationContext.getBean("teacherService", UserService.class);
        service.add();
    }
}
```

### name 属性

作用似乎和 id 类似。

算是别名吧。

id是bean的唯一标识，name是bean的别名组。

name可以代替id，没有id时name中的第一个别名会成为id。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <bean id="userService" name="u1,u2,u3" class="edu.nf.ch03.UserService"/>
</beans>
```

## 2. Bean 作用域

Bean 的 scope 属性用于定义作用域。

默认是单例。

- 单例：
  - 如数据源（连接池），工具类等，不用保存状态的情况使用。
- 原型：
  - 如新用户对象等，需要保存不同状态的情况使用。
- 请求：
  - 如某次请求需要的数据对象，在请求结束后销毁时使用。
- 会话：
  - 如某用户创建一次会话后，用于保存会话中状态，结束会话即销毁时使用。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--  scope：指定了Bean的作用域  -->
    <!--  singleton（单例）：表示单例管理实例  -->
    <!--  prototype（原型）：表示每次获取的均为新实例  -->
    <!--  request：表示在单次请求内存活（需要Web环境）  -->
    <!--  session：表示在单次会话内存活（需要Web环境）  -->
    <bean id="userService" class="edu.nf.ch02.service.impl.UserServiceImpl" scope="singleton"/>
</beans>
```

## 3. Bean 初始化 / 销毁 / 后置处理器

算是手动管理 Bean 的生命周期吧。

bean生命周期执行顺序：

- 构造方法（JVM执行）
- 后置处理器：postProcessBeforeInitialization方法，继承BeanPostProcessor接口
- 初始化：afterPropertiesSet方法，继承InitializingBean接口
- 初始化（自定义）：自定义init——method方法
- 后置处理器：postProcessAfterInitialization方法，继承BeanPostProcessor接口
- 销毁：destroy方法，继承DisposableBean接口
- 销毁（自定义）：自定义destroy-method方法

注意生命周期的设置仅对单例 Bean 生效。

### 配置

不管用啥方法，都要在 Bean 配置文件中进行配置。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">
    <!--  初始化  -->
    <!--  InitializingBean接口：包含afterPropertiesSet方法，也用于初始化  -->
    <!--  接口在实现类里实现  -->
    <!--  若同时存在InitializingBean接口和inti_method方法  -->
    <!--  优先实现InitializingBean接口，然后才是inti_method方法  -->
    <bean id="userService" class="edu.nf.ch04.UserService"/>
    
    <!--  自定义初始化  -->
    <!--  inti_method：当对象创建后可以再定义一个初始化方法交由spring执行  -->
	<bean id="userService" class="edu.nf.ch04.UserService" init-method="initMethod"/>

    
    


    <!--  DisposableBean接口：destroy方法也用于销毁  -->
    <bean id="userService" class="edu.nf.ch04.UserService"/>
    
    <!--  自定义销毁  -->
    <!--  destroy-method：容器关闭时销毁  -->
    <bean id="userService" class="edu.nf.ch04.UserService" destroy-method="destroyMethod"/>


    
    
    
    <!--  后置处理器  -->
    <bean id="serviceProcessor" class="edu.nf.ch04.ServicePostProcessor"/>
</beans>
```

### 定义初始化与销毁

首先为了可以实例这个类（Bean 对象也是要实例目标类的），构造方法必须要有的。

然后为了实现上面的自动初始化与销毁。

类中需要实现 InitializingBean 接口与 DisposableBean 接口。

而自定义的初始化与销毁只需要自己建方法就好。

```java
package edu.nf.ch04;

import org.springframework.beans.factory.DisposableBean;
import org.springframework.beans.factory.InitializingBean;

public class UserService implements InitializingBean, DisposableBean {
    // 构造方法
    public UserService() {
        System.out.println("Bean的构造方法");
    }
    
    
    
    // 自定义初始化方法
    public void initMethod() {
        System.out.println("spring容器执行初始化方法——1");
    }
    // 自定义销毁方法
    public void destroyMethod() {
        System.out.println("spring容器执行销毁方法——1");
    }

    
    
    // 自动初始化方法
    @Override
    public void afterPropertiesSet() throws Exception {
        System.out.println("spring容器执行初始化方法——2");
    }
    // 自动销毁方法
    @Override
    public void destroy() throws Exception {
        System.out.println("spring容器执行销毁方法——2");
    }
}
```

### 定义后置处理器

然后就是后置处理器。

这玩意需要专门给一个类。

后置处理器可以在bean装配完成后（包括依赖注入后），执行初始化方法前后执行某些逻辑。

注意后置处理器会应用于所有的 Bean。

```java
package edu.nf.ch04;

import org.springframework.beans.BeansException;
import org.springframework.beans.factory.config.BeanPostProcessor;

public class ServicePostProcessor implements BeanPostProcessor {
    // 定义执行前逻辑
    @Override
    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessBeforeInitialization");
        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);
    }

    // 定义执行后逻辑
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {
        System.out.println("postProcessAfterInitialization");
        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);
    }
}
```

### 测试

这里注意，ApplicationContext 这个接口是不提供如 close() 方法的。

一般都是自动管理这些初始化与销毁行为的。

若要手动管理就要使用 ClassPathXmlApplicationContext 实现类进行实例。

这样才有 close() 方法用。

```java
package edu.nf.ch04;

import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {
//        ApplicationContext applicationContext = new ClassPathXmlApplicationContext("Beans.xml");
        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext("Beans.xml");
        applicationContext.close();
    }
}
```

## 4. Bean 注入

若有一个电商系统。

订单模块需要调用支付模块和库存模块。

如果直接在订单类中 `new PaymentService()` 和 `new InventoryService()` 就属于是硬编码的说。

但凡如支付方式需要变更时，需要修改所有相关实现。

| 特性         | 传统方式             | Spring 依赖注入      |
| :----------- | :------------------- | :------------------- |
| 对象创建方式 | 硬编码 `new` 关键字  | 容器自动装配         |
| 组件关系     | 紧耦合（混凝土结构） | 松耦合（积木式组装） |
| 可测试性     | 难以替换依赖实现     | 轻松注入 Mock 对象   |
| 功能扩展     | 需要修改多处源码     | 仅需替换 Bean 配置   |

而注入首先就是要让程序知道这些积木（或者叫组件，Bean）在哪里。

所以就是要先配置上下文地址配置，spring 自己就给扫到的积木建立关系了。

### 应用程序上下文配置

就在 resources 里面建一个 applicationContext.xml 文件。

指定某个包为扫描目标。

检出包里的所有被注解标记的 Bean 至容器进行管理。

有了下面扫包的那一句，spring 理应就自动启用注解了。

理应就不用手动标明启用注解了。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       https://www.springframework.org/schema/context/spring-context.xsd">

    <!--  启用注解  -->
    <!--<context:annotation-config/>-->
    <!--  扫包  -->
    <context:component-scan base-package="edu.nf.ch05"/>

</beans>
```

### 依赖注入

把控制层注入至业务层。

反正推荐使用构造器注入（说是还能用字段与 set 方法注入）。

@Controller，@Service，和 @Repository 均与 @Component作用相同，就是更加好看。

都是用来把类标记为 Bean 的。

不给值时，Bean 的 id 为类名，且首字母小写。

给了值就是值了。

除了 @RequiredArgsConstructor ，也能用 @Autowired。

@Autowired 可以标注在字段、构造方法、set方法上。

不同于 @RequiredArgsConstructor ，@Autowired 需要给出实际的字段、构造方法、或set方法。

```java
package edu.nf.ch05.controller;

import edu.nf.ch05.service.UserService;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Controller;

// 标记为 Bean
@Controller
// 用于生成构造器并注入
// 生成的构造器内仅包含所有 final 标记的字段
@RequiredArgsConstructor
public class UserController {
    // 执行注入时记得把这玩意标记为常量
    private final UserService userService;

    // @Autowired
    /*public UserController(UserService userService) {
        this.userService = userService;
    }*/
    
    public void save() {
        userService.save();
    }
}
```

业务层基本一样，继续向持久层传递（注入）。

```java
package edu.nf.ch05.service;

import edu.nf.ch05.mapper.UserMapper;
import lombok.RequiredArgsConstructor;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;
import org.springframework.stereotype.Service;

@Service("userService")
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    private final UserMapper userMapper;

    @Override
    public void save() {
        userMapper.add();
    }
}
```

### 依赖冲突

若出现多个 Bean 共接一个接口。

使用 @Primary 标记优先注入。

```java
package edu.nf.ch05.mapper;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

@Repository("studentMapper")
@Primary
public class StudentMapperImpl implements UserMapper{
    @Override
    public void add() {
        System.out.println("insert into student");
    }
}
```

```java
package edu.nf.ch05.mapper;

import org.springframework.context.annotation.Primary;
import org.springframework.stereotype.Repository;

@Repository("userMapper")
public class UserMapperImpl implements UserMapper {
    @Override
    public void add() {
        System.out.println("insert into user");
    }
}
```

### 测试

```java
package edu.nf.ch05;

import edu.nf.ch05.controller.UserController;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {
        // 声明上下文对象，引入上下文配置文件
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        // 获取控制层 Bean 对象
        UserController controller = context.getBean(UserController.class);
        // 调用控制层方法，将会经由业务层至持久层进行操作。
        controller.save();
    }
}
```

## 5. JSR 的 Bean 注入

上面全是 spring 的注入方法。

这个是 Java 官方的注入方法（了解一下就行，用还是用 spring 的）。

（说是 spring 先出的，Java 发现不错就也搞了一个（有一个旧的，但不如 spring 的））。

JSR 就是 Java 规范提案。

反正就是一群家伙搞的 Java 的编写规范。

Java 的注入注解旧版说是在 JSR250，新版在 JRS330。

- JSR250：
  - 使用 @Resource。
  - 能标注在字段与set方法。
  - 可选name属性标明Bean的id。
- JSR330：
  - 使用 @Inject。
  - 能标注在字段，set方法，与构造方法。
  - 有多个实现时，需要合并 @Named 注解，用于标识需要优先注入的。
  - 类似 @Primary 的作用。

```java
package edu.nf.ch06.service;

import edu.nf.ch06.mapper.UserMapper;
import org.springframework.stereotype.Service;

import javax.inject.Inject;
import javax.inject.Named;

@Service("userService")
public class UserServiceImpl implements UserService{
    private UserMapper userMapper;

    @Inject
    @Named("stuMapper")
    public UserServiceImpl(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

//    @Resource(name = "userMapper")
    public void setUserMapper(UserMapper userMapper) {
        this.userMapper = userMapper;
    }

    @Override
    public void add() {
        System.out.println("come to service");
        userMapper.save();
    }
}
```

## 6. 集合注入

比如支付时，有好几种支付方式。

每种方式单独做一套三层麻烦死。

用一套三层，使用如 Map 之类的保存每种方式的 Bean。

使用接收的类型在 Map 中筛出目标方式的 Bean 就好。

```java
package edu.nf.ch07.controller;

import edu.nf.ch07.service.PaymentService;
import org.springframework.stereotype.Controller;

import java.util.Map;

@Controller
public class PaymentController {
    // Map<自定义的支付类型, 对应类型的Bean实例>
    private Map<String, PaymentService> paymentServiceMap;

    public PaymentController(Map<String, PaymentService> paymentServiceMap) {
        this.paymentServiceMap = paymentServiceMap;
    }

    public void payment(String type) {
        PaymentService service = paymentServiceMap.get(type);
        service.payment();
    }
}
```

```java
package edu.nf.ch07;

import edu.nf.ch07.controller.PaymentController;
import org.springframework.context.ApplicationContext;
import org.springframework.context.support.ClassPathXmlApplicationContext;

public class Main {
    public static void main(String[] args) {
        // 正常实例控制层
        ApplicationContext context = new ClassPathXmlApplicationContext("applicationContext.xml");
        PaymentController controller = context.getBean(PaymentController.class);
        // 根据不同类型选择对应的 Bean
        controller.payment("aliPay");
        controller.payment("weChatPay");
    }
}
```

## 7. 值注入

一般用于比如配置文件属性值的检出等情况。

将属性值注入至字段。

一般用 @Value 定义注入。

@Value 内使用 SPEL 表达式（${}）定义属性名。

spring 会根据属性名在配置文件内找到对应的属性，然后拉出对应值并赋予对应的字段。

```properties
url = localhost
port = 8080
```

```java
package edu.nf.ch08.service;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.PropertySource;
import org.springframework.stereotype.Service;

@Service
// classpath为编译后的resources文件夹
@PropertySource("classpath:host.properties")
public class UserService {
    @Value("${url}")
    private String url;
    @Value("${port}")
    private Integer port;

    public void print() {
        System.out.println(url);
        System.out.println(port);
    }
}
```

## 8. 作用域问题

关于上下级作用域不同产生的问题。

### 设置

这里的设置不是上面使用 xml 的设置。

而是使用注解进行设置。

给下级设置为 prototype。

```java
package edu.nf.ch09.service;

import org.springframework.context.annotation.Scope;
import org.springframework.context.annotation.ScopedProxyMode;
import org.springframework.stereotype.Service;

@Service
// 设置作用域（默认就是singleton）
@Scope(value = "prototype")
public class UserService {
    public void add() {
        System.out.println("add");
    }
}
```

### 失效

如上级标注为 singleton，而下级试图标注为 prototype。

这种情况就会出现下级的作用域设置失效。

一般因为上级内包含下级的实例，所以上级为 singleton 时，其内部的所有成员自然也是跟随这整个对象的。

所以上级内部的下级实例无论如何也无法进行多次声明。

### 解决

就说有两种解决办法：

- 修改上级作用域：

  - 让上下级作用域统一即可。

  - ```java
    package edu.nf.ch09.controller;
    
    import edu.nf.ch09.service.UserService;
    import org.springframework.context.annotation.Scope;
    import org.springframework.stereotype.Controller;
    
    @Controller
    @Scope("prototype")
    public class UserController {
        private UserService userService;
    
        public UserController(UserService userService) {
            this.userService = userService;
        }
    
        public void save() {
            System.out.println(userService);
            userService.add();
        }
    }
    ```

- 作用域代理：

  - 不用动上级。

  - 类似动态代理的意思。

  - 使用代理突破原有逻辑（强制按照上级作用域），改写行为。

  - 让下级的作用域强行生效。

  - ```java
    package edu.nf.ch09.service;
    
    import org.springframework.context.annotation.Scope;
    import org.springframework.context.annotation.ScopedProxyMode;
    import org.springframework.stereotype.Service;
    
    @Service
    // 设置作用域为 prototype，并注入代理
    @Scope(value = "prototype", proxyMode = ScopedProxyMode.TARGET_CLASS)
    public class UserService {
        public void add() {
            System.out.println("add");
        }
    }
    ```

## 9. 配置类

一般如导入外部框架之类的采用这个方法。

自己项目里的还是用配置文件方便。

配置类首先就需要加上 @Configuration 注解标记一下。

有两种装配方法：

- 手动逐个装配：
  - 使用 @Bean 标记一下，等效于 xml 中的 `<bean/>`。
  - 这样装配的 Bean 的 id 一般默认为方法名（有需要可以用 name 属性修改）。
  - 也可以加上 @Scope，标明作用域。
  - 这样装配的方法返回的对象会被直接当作 Bean 加入容器管理。
    - 可以在方法内传递需要注入的类的方法。
- 扫包自动装配：
  - 使用 @ComponentScan(basePackages = "从蓝色Java开始下追") 指定路径，扫描内部的类。
  - 发现被注入的（见本章第四节）类，将其加入容器管理。

```java
package edu.nf.ch10.config;

import edu.nf.ch10.mapper.UserMapper;
import edu.nf.ch10.mapper.UserMapperImpl;
import edu.nf.ch10.service.UserService;
import edu.nf.ch10.service.UserServiceImpl;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Scope;

@Configuration
// @ComponentScan(basePackages = "edu.nf.ch10")
public class AppConfig {
    @Bean()
    @Scope("singleton")
	// @Bean(name = "abc") 不推荐
    public UserService userService() {
        // 注入UserMapper
        return new UserServiceImpl(userMapper());
    }

    @Bean
    public UserMapper userMapper() {
        return new UserMapperImpl();
    }
}
```

## 10. 配置类的代理

主要还是关于配置类的 @Configuration() 注解的必要性。

这个注解就是让spring代理这里面所有的被@Bean标注的东西。

虽然不给这个注解，spring 也能识别并产生Bean对象，但这些对象不会被容器管理。

而 @Configuration() 注解中有一个 proxyBeanMethods 属性，默认为 true。

代表开启代理并管理组件。

若不给 proxyBeanMethods 属性就相当于没有启动代理并管理。

所以说，开启后试图获取 Bean 时，spring 就会在容器里给你找它。

但关闭的话 spring 就不管了，不给你在容器里找了（容器里也没有），用一个就原地声明一个。

```java
package edu.nf.ch11.config;

import edu.nf.ch11.dao.UserDao;
import edu.nf.ch11.service.UserService;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 默认为true开启代理，false就是关闭代理
// 取值为false就是非代理模式（Lite模式）
// 取值为true就是代理模式（Full模式）
@Configuration()
// @Configuration(proxyBeanMethods = false)
public class AppConfig {
    @Bean
    public UserDao userDao() {
        return new UserDao();
    }

    @Bean
    public UserService userService() {
        UserDao userDao = userDao();
        System.out.println(userDao);
        UserDao userDao_2 = userDao();
        System.out.println(userDao_2);
        return new UserService(userDao);
    }
}
```

## 11. 配置类的导入

使用 @Import 进行导入。

一般应用于配置类的玩意。

用来给配置类里导入一些外部的东西。

### 单一指定导入

直接点名某个 Bean 导进来（一般不用）。

```java
package edu.nf.ch12.config;

import edu.nf.ch12.service.UserService;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@Import(UserService.class)
public class AppConfig {
}
```

### 组文件导入

指定一组配置类啥的导进来。

写配置的时候分模块写更好。

写完把这些分家的模块合并到一个主配置类。

这方法要先扫包的。

```java
package edu.nf.ch12.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@ComponentScan(basePackages = "edu.nf.ch12")
@Import({MvcConfig.class, MyBatisConfig.class})
public class AppConfig {
}
```

### 注解指定导入

使用注解标记需要导入的类。

然后扫包。

有发现被标记的就导进来。

注解随便定一个空的都行。

```java
package edu.nf.ch12.anno;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.TYPE)
public @interface MyAnno {
}
```

然后定义导入容器。

若扫出来的类有被自定义注解标记，那就给它丢进容器管理一下。

```java
package edu.nf.ch12.config;

import edu.nf.ch12.anno.MyAnno;
import edu.nf.ch12.service.UserService;
import org.springframework.context.annotation.ImportSelector;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.util.StringUtils;

import java.util.ArrayList;

public class AnnoImportSelector implements ImportSelector {
    @Override
    public String[] selectImports(AnnotationMetadata importingClassMetadata) {
        ArrayList<String> list = new ArrayList<>();
        // 最好还是做扫包，这里仅为示例，不扫了
        if (UserService.class.isAnnotationPresent(MyAnno.class)) {
            list.add(UserService.class.getName());
        }
        return StringUtils.toStringArray(list);
    }
}
```

然后导就行了。

```java
package edu.nf.ch12.config;

import edu.nf.ch12.service.UserService;
import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

@Configuration
@ComponentScan(basePackages = "edu.nf.ch12")
@Import(AnnoImportSelector.class)
public class AppConfig {
}
```

# 3，Spring AOP

## 1. 描述

似乎，算是面向对象的补充。

试图解决一些面向对象不好解决的问题。

这鬼玩意也是基于动态代理实现。

它一般就是应用于如日志，权限管理等非核心功能。

这种不完全属于程序主要逻辑流（程序的主要的功能组组成的整套逻辑循环）的功能可以交给 AOP 处理。

如日志，它需要时不时的，或在出现问题时做记录。

但这功能明显不属于程序的主逻辑流。

更像一个临时的，侵入式的。

而不是与程序主逻辑衔接流畅的，通顺的。

这种侵入的，切入的功能可以提出，用 AOP 代管。

使这些侵入功能模块化，分离出主循环。

抹平主循环的疙瘩。

## 2. 切面，增强（通知）

用于编写增强逻辑的类叫切面（切面就是 AOP）。

增强逻辑就是上面提的如日志，权限管理等玩意。

就是对目标加上额外的代码，补充甚至修改目标功能。

- 前置通知：
  - 目标调用前执行。
- 后置通知：
  - 目标返回后执行。
- 环绕通知：
  - 目标调用前后执行。
- 异常通知：
  - 目标异常时执行，且异常被出发后不会再执行后置。
- 最终通知：
  - 不管有没有异常都会执行。

## 3. 切入点

找到目标的那些方法需要被切入增强。

可以使用表达式描述。

## 4. 连接点

被切入的方法叫连接点。

一个切入点可以对应多个连接点。

## 5. 代理

在运行时动态创建的对象，叫代理对象。

这个代理对象对象负责调用目标对象的方法，并增强。

这个行为叫代理。

## 6. 目标

就是需要代理增强的目标对象。

## 7. 织入

将增强逻辑应用到某个具体的连接点上，并产生代理的行为叫织入。

- 类加载时织入：
  - 需要特殊类加载器（LTW）。
- 编译时织入：
  - 需要特殊编译器（CTW）。
- 运行时织入：
  - 使用 JDK 或 CGLIB 创建动态代理对象。

## 8. 切面定义与织入示例

### 依赖

spring 中使用了aspectJ 的一些注解啥的。

反正就是又要在 maven 里面依赖一下。

```xml
<dependency>
    <groupId>org.aspectj</groupId>
    <artifactId>aspectjweaver</artifactId>
    <version>1.9.24</version>
</dependency>
```

### 配置类

打三个注解就行了。

- @Configuration：反正 Spring 里面的配置类似乎就是要加这个的。
- @ComponentScan：指定要扫描的根包。
- @EnableAspectJAutoProxy：启用AspectJ注解处理器。

```java
package edu.nf.ch13.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackages = "edu.nf.ch13")
// 这个属性设置为true，标识强制使用CGLIB代理（默认false）
// 一般不用加，用默认值就好
@EnableAspectJAutoProxy(proxyTargetClass = true)
public class AppConfig {
}
```

### Service 类

这个 Service 里的方法就算是连接点了。

```java
package edu.nf.ch13.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {
    /**
     * 连接点（可以定很多个的）
     */
    public String save(String name) {
        System.out.println("save");
        return "hello" + name;
    }
}
```

### 定义切面

这里展示了切面中的5中通知类型。

```java
package edu.nf.ch13.aspect;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.*;
import org.springframework.stereotype.Component;

/**
 * 切面
 */
@Aspect
@Component
public class UserServiceAspect {
    /**
     * 切入点
     */
    // 包路径.类名.方法(参数)
    // *：选中下面的所有东西
    // ..：任意类型和个数的参数
    // 所有被表达式选中的均叫连接点
    @Pointcut("execution(* edu.nf.ch13.service.UserService.*(..))")
    public void pointCut() {}

    /**
     * 前置通知
     * @param jp 连接点信息
     */
    @Before("pointCut()")
    public void before(JoinPoint jp) {
        System.out.println("前置通知，参数：" + jp.getArgs()[0]);
    }

    /**
     * 后置通知
     * @param jp 连接点信息
     * @param returnValue 返回值（对应形参名）
     * @return 返回值对象
     */
    @AfterReturning(value = "pointCut()", returning = "returnValue")
    public Object after(JoinPoint jp, String returnValue) {
        System.out.println("后置通知，返回值：" + returnValue);
        return returnValue;
    }

    /**
     * 环绕通知
     * @param jp 连接点信息
     * @return 调用的方法对象
     * @throws Throwable 异常
     */
    @Around("pointCut()")
    public Object around(ProceedingJoinPoint jp) throws Throwable {
        System.out.println("环绕前");
        Object o = jp.proceed();
        System.out.println("环绕后");
        return o;
    }

    /**
     * 异常通知
     * @param jp 连接点信息
     */
    @AfterThrowing(value = "pointCut()", throwing = "e")
    public void afterThrowing(JoinPoint jp, Exception e) throws Throwable {
        System.out.println("异常：" + e.getMessage());
    }

    /**
     * 最终通知
     * @param jp 连接点信息
     */
    @After("pointCut()")
    public void after(JoinPoint jp) {
        System.out.println("最终通知");
    }
}
```

### 测试

```java
package edu.nf.ch13;

import edu.nf.ch13.config.AppConfig;
import edu.nf.ch13.service.UserService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main {
    public static void main(String[] args) {
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        UserService service = context.getBean(UserService.class);
        service.save("as");
    }
}
```

理应输出：

```
环绕前
前置通知，参数：as
save
后置通知，返回值：helloas
最终通知
环绕后
```

在 Service 的连接点方法中搓一个报错，输出理应变成：

```
环绕前
前置通知，参数：as
save
异常：/ by zero
最终通知
```

## 9. 感知接口

一般表示 Aware 接口及下属实现（至少在 Spring 里）。

允许Bean感知Spring容器的内部状态和上下文信息。

实际用起来感觉就是在非 IOC 成员中访问或使用 IOC 成员。

### 新建 Bean

总要给 IOC 里面放点啥嘛。

```java
package edu.nf.ch14.service;

import org.springframework.stereotype.Service;

@Service
public class UserService {
    public void add() {
        System.out.println("add");
    }
}
```

### 配置文件

空配置就行。
定义一下扫包。

```java
package edu.nf.ch14.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;

@Configuration
@ComponentScan(basePackages = "edu.nf.ch14")
public class AppConfig {
}
```

### 上下文持有类

就在这里面声明 ApplicationContext 对象。

私有保证单例。

提供访问方法。

就是这种形式实现的非 IOC 成员访问 IOC 成员的。

（一般单例好像都是这么写的）。

```java
package edu.nf.ch14.util;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

// 也需要标记为 Bean 对象
// 只是说这玩意不属于业务，控制和持久的任意层
// 所以直接用这个父注解
@Component
public class ApplicationContextHolder implements ApplicationContextAware {
    // 唯一上下文对象
    private static ApplicationContext applicationContext;

    // 声明上下文对象
    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        this.applicationContext = applicationContext;
    }

    // 直接拿上下文对象
    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }

    // 从 IOC 里面拿对象
    public static <T> T getBean(Class<T> clazz) {
        return applicationContext.getBean(clazz);
    }
}
```

### 某个非 IOC 对象

```java
package edu.nf.ch14.service;

import edu.nf.ch14.util.ApplicationContextHolder;

public class TestService {
    public void test() {
        // 这里就是非 IOC 成员调用了 IOC 成员的方法
        UserService service = ApplicationContextHolder.getBean(UserService.class);
        service.add();
    }
}
```

### 测试

```java
package edu.nf.ch14;

import edu.nf.ch14.config.AppConfig;
import edu.nf.ch14.service.TestService;
import org.springframework.context.ApplicationContext;
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main {
    public static void main(String[] args) {
        // 整个程序中仅需声明一次
        // 让上下文持有类中包含一个上下文对象即可
        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);
        // 调用非 IOC 成员方法
        TestService service = new TestService();
        service.test();
    }
}
```
