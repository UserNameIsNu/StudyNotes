[TOC]

# MyBatis

# 1，简介

## 1.这是啥

持久层框架。

主要为了简化 JDBC 开发。

持久层就是负责将数据保存到数据库的那些代码。

JavaEE 中，常见的三层架构就是：

- 表现层
- 业务层
- 持久层

而框架就算是一种半成品软件。

可复用，通用的软件项目的基础代码模型。

在框架上构建的软件一般会更加高效，规范，通用，可扩展，且方便维护。

## 2.手敲和这玩意的区别

- 手敲：
  - 硬编码：
    - 如注册驱动，获取连接，各种 SQL 语句。
  - 操作繁琐：
    - 手动设置参数。
    - 手动封装结果。

- MyBatis：
  - 硬编码转为配置文件。
  - 大多操作可自动完成。

这玩意几乎免去了大多数的 JDBC 代码。

与设置，获取结果集之类的工作。

# 2，入门

## 1.示例项目结构

```
untitled
├── ch01
│	├── src
|	|	├── main
|	|	|	├── java
|	|	|	|	└── edu
|	|	|	|	|	└── nf
|	|	|	|	|		└── ch01
|	|	|	|	|			├── entity
|	|	|	|	|			|	└── User.class
|	|	|	|	|			├── mapper
|	|	|	|	|			|	└── UserMapper.class
|	|	|	|	|			├── service
|	|	|	|	|			|	└── UserService.class
|	|	|	|	|			└── util
|	|	|	|	|				└── MyBatisUtils.class
|	|	|	|	└── Main.class
|	|	|	└── resources
|	|	|		├── mappers
|	|	|		|	└── UserMapper.xml
|	|	|		└── mybatis.xml
|	|	└── test
│	└── pom.xml
└── pom.xml
```

## 2.参数传递

除了查询，其它三个操作一般都要各种参数。

这时候就需要使用参数传递。

比如有一个添加的方法。

```java
void insert(@Param("name") String name, @Param("age") Integer age);
```

使用 @Param 标明这是一个需要传递的参数。

跟随括号内的是参数名。

最后就是参数值。

先了解这一个。

然后就可以跟着下面的案例动手了。

## 3.CURD 示例

只要配置完一些乱七八糟的玩意。

后续要新增或修改方法时就方便很多了。

这里就在查询数据的示例中配置。

### 查询数据

#### 创建表

这不用说了吧。

#### 配置 Maven 依赖

先在项目最祖宗的 Maven 配置里（pom.xml）导入要用的。

这里用 MySQL。

还有 MyBatis 和一个方便建对象的 lombok。

```xml
<dependencies>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.3.0</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis</groupId>
        <artifactId>mybatis</artifactId>
        <version>3.5.16</version>
    </dependency>
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <version>1.18.34</version>
    </dependency>
</dependencies>
```

#### 创建对象

然后要有个表对象吧。

（这个 lombok 属实好用）。

```java
package edu.nf.ch01.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String name;
    private Integer age;
}
```

#### 创建接口

对应一个对象，包含这个对象的所有 CURD 方法。

```java
package edu.nf.ch01.mapper;

import edu.nf.ch01.entity.User;

import java.util.List;

public interface UserMapper {
    List<User> select();
}
```

#### 编写 MyBatis 配置

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
    <!--  实体类别名  -->
    <typeAliases>
        <!--  这是指定某个实体  -->
		<!--  <typeAlias type="edu.nf.ch01.entity.User" alias="user"/>  -->
        <!--  这是扫描某个包下的所有实体  -->
        <package name="edu.nf.ch01.entity"/>
    </typeAliases>

    <!--  环境配置（默认使用 mysql）  -->
    <environments default="mysql">
        <!--  MySQL数据源环境  -->
        <environment id="mysql">
            <!--  事务管理  -->
            <!--  JDBC：使用本地事务  -->
            <!--  MANAGED：MyBatis不管事务，爱谁干谁干  -->
            <transactionManager type="JDBC"/>
            <!--  使用MyBatis内置连接池  -->
            <dataSource type="POOLED">
                <!--  这四个不用讲了吧  -->
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3307/java211?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
        <!--  SQLServer数据源环境  -->
		<environment id="sqlserver">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="。。。"/>
                <property name="url" value="。。。"/>
                <property name="username" value="。。。"/>
                <property name="password" value="。。。"/>
            </dataSource>
        </environment>
    </environments>

    <!--  加载映射  -->
    <!--  一个实体就有一个映射，要用哪个映射就要在这里导入  -->
    <mappers>
        <mapper resource="mappers/UserMapper.xml"/>
    </mappers>
</configuration>
```

#### 编写 MyBatis 映射

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch01.mapper.UserMapper">
    <select id="select" resultType="user">
        select
        s_id as id,
        s_name as name,
        s_age as age
        from stu_info
    </select>
</mapper>
```

#### 创建 SQL 会话工厂

记得这玩意要搞成单例。

```java
package edu.nf.ch01.util;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MyBatisUtils {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            InputStream inputStream = Resources.getResourceAsStream("mybatis.xml");
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    public static SqlSession getSession() {
        return sqlSessionFactory.openSession();
    }
}
```

#### 创建对象对应的 Service

一般就是一个对象配一个 Service。

```java
package edu.nf.ch01.service;

import edu.nf.ch01.mapper.UserMapper;
import edu.nf.ch01.util.MyBatisUtils;
import org.apache.ibatis.session.SqlSession;

public class UserService {
    public void selectUser() {
        SqlSession session = MyBatisUtils.getSession();
        UserMapper mapper = session.getMapper(UserMapper.class);
        System.out.println(mapper.select()); // 测试输出罢了，实际可以给返回
        session.close();
    }
}
```

#### 调用

终于结束了。

```java
import edu.nf.ch01.service.UserService;

import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        // 这个工厂实例一次即可
        UserService userService = new UserService();
        userService.selectUser();
    }
}
```

### 添加数据

前面有一大堆准备工作罢了。

剩下就简单了。

#### 接口定义新方法

```java
package edu.nf.ch01.mapper;

import edu.nf.ch01.entity.User;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface UserMapper {
    List<User> select();
    void insert(@Param("name") String name, @Param("age") Integer age);
}
```

#### 映射添加新语句

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch01.mapper.UserMapper">
    <select id="select" resultType="user">
        select
        s_id as id,
        s_name as name,
        s_age as age
        from stu_info
    </select>
    <insert id="insert">
        insert into stu_info(s_name, s_age) values(#{name}, #{age})
    </insert>
</mapper>
```

#### Service 添加方法

除了 select，其它一般要加事务管理的。

就是提交，回滚啥的。

```java
package edu.nf.ch01.service;

import edu.nf.ch01.mapper.UserMapper;
import edu.nf.ch01.util.MyBatisUtils;
import org.apache.ibatis.session.SqlSession;

public class UserService {
    public void selectUser() {
        SqlSession session = MyBatisUtils.getSession();
        UserMapper mapper = session.getMapper(UserMapper.class);
        System.out.println(mapper.select()); // 测试输出罢了，实际可以给返回
        session.close();
    }
    public void insertUser(String name, Integer age) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.insert(name, age);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
}
```

#### 调用

```java
import edu.nf.ch01.service.UserService;

import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        UserService userService = new UserService();
        userService.selectUser();
        userService.insertUser("wu", 18);
        userService.selectUser();
    }
}
```

### 删除数据

也是几乎一样。

#### 接口定义新方法

```java
package edu.nf.ch01.mapper;

import edu.nf.ch01.entity.User;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface UserMapper {
    List<User> select();
    void insert(@Param("name") String name, @Param("age") Integer age);
    void delete(@Param("id") Integer id);
}
```

#### 映射添加新语句

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch01.mapper.UserMapper">
    <select id="select" resultType="user">
        select
        s_id as id,
        s_name as name,
        s_age as age
        from stu_info
    </select>
    <insert id="insert">
        insert into stu_info(s_name, s_age) values(#{name}, #{age})
    </insert>
    <delete id="delete">
        delete from stu_info where s_id = #{id}
    </delete>
</mapper>
```

#### Service 添加方法

```java
package edu.nf.ch01.service;

import edu.nf.ch01.mapper.UserMapper;
import edu.nf.ch01.util.MyBatisUtils;
import org.apache.ibatis.session.SqlSession;

public class UserService {
    public void selectUser() {
        SqlSession session = MyBatisUtils.getSession();
        UserMapper mapper = session.getMapper(UserMapper.class);
        System.out.println(mapper.select()); // 测试输出罢了，实际可以给返回
        session.close();
    }
    public void insertUser(String name, Integer age) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.insert(name, age);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
    public void deleteUser(Integer id) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.delete(id);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
}
```

#### 调用

```java
import edu.nf.ch01.service.UserService;

import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        UserService userService = new UserService();
        userService.selectUser();
        userService.insertUser("wu", 18);
        userService.selectUser();
        userService.deleteUser(4);
        userService.selectUser();
    }
}
```

### 修改数据

还是一样。

#### 接口定义新方法

```java
package edu.nf.ch01.mapper;

import edu.nf.ch01.entity.User;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface UserMapper {
    List<User> select();
    void insert(@Param("name") String name, @Param("age") Integer age);
    void delete(@Param("id") Integer id);
    void update(@Param("id") Integer id, @Param("age") Integer age);
}
```

#### 映射添加新语句

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch01.mapper.UserMapper">
    <select id="select" resultType="user">
        select
        s_id as id,
        s_name as name,
        s_age as age
        from stu_info
    </select>
    <insert id="insert">
        insert into stu_info(s_name, s_age) values(#{name}, #{age})
    </insert>
    <delete id="delete">
        delete from stu_info where s_id = #{id}
    </delete>
    <update id="update">
        update stu_info set s_age = #{age} where s_id = #{id}
    </update>
</mapper>
```

#### Service 添加方法

```java
package edu.nf.ch01.service;

import edu.nf.ch01.mapper.UserMapper;
import edu.nf.ch01.util.MyBatisUtils;
import org.apache.ibatis.session.SqlSession;

public class UserService {
    public void selectUser() {
        SqlSession session = MyBatisUtils.getSession();
        UserMapper mapper = session.getMapper(UserMapper.class);
        System.out.println(mapper.select()); // 测试输出罢了，实际可以给返回
        session.close();
    }
    public void insertUser(String name, Integer age) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.insert(name, age);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
    public void deleteUser(Integer id) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.delete(id);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
    public void updateUserAge(Integer id, Integer age) {
        SqlSession session = MyBatisUtils.getSession();
        try {
            UserMapper mapper = session.getMapper(UserMapper.class);
            mapper.update(id, age);
            session.commit();
        } catch (RuntimeException e) {
            session.rollback();
        } finally {
            session.close();
        }
    }
}
```

#### 调用

```java
import edu.nf.ch01.service.UserService;

import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException {
        UserService userService = new UserService();
        userService.selectUser();
        userService.insertUser("wu", 18);
        userService.selectUser();
        userService.deleteUser(4);
        userService.selectUser();
        userService.updateUserAge(2, 18);
        userService.selectUser();
    }
}
```

## 4.主键映射

接下来就是其它小技巧。

一般按照上面的方法只能获取除主键外的值。

需要获取主键本身要专门修饰一下。

使用 useGeneratedKeys 定义为 true 表示开启主键映射。

使用 keyProperty 指定映射至对象的某个字段（这里将主键映射至对象的 id 字段）。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch02.mapper.UserMapper">
    <!--  定义需要获取主键，且将主键映射至 id 字段  -->
    <insert id="save" useGeneratedKeys="true" keyProperty="id">
        insert into stu_info(s_name, s_age) values(#{name}, #{age})
    </insert>
</mapper>
```

## 5.事务提交控制

MyBatis 可以控制事务是自动提交还是手动管理。

一般在构建 SqlSessionFactory 时定义。

不过一般都是定义为手动管理的。

还有如搜索操作是不需要定义事务的。

```java
package edu.nf.ch03.util;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;

import java.io.IOException;
import java.io.InputStream;

public class MyBatisUtils {
    private static SqlSessionFactory sqlSessionFactory;
    static {
        try {
            InputStream inputStream = Resources.getResourceAsStream("mybatis.xml");
            sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
    // 在创建sqlSessionFactory时，使用布尔值可以定义是否开启手动事务提交
    // true表示自动管理
    // false表示手动管理
    public static SqlSession getSession(boolean autoCommit) {
        return sqlSessionFactory.openSession(autoCommit);
    }
}
```

## 6.字段映射

如搜索一条数据时，对象字段名与数据库字段名是不同的。

前面使用的是在语句中使用 as 别名。

现在可以使用字段映射匹配两者的名字。

id 为映射名，type 为映射对象。

标签 id 为定义主键字段，result 定义其它字段。

property 定义对象字段名，column 定义数据库字段名。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch04.mapper.UserMapper">
    <!--  定义对象字段映射  -->
    <resultMap id="userMap" type="edu.nf.ch04.entity.User">
        <id property="id" column="s_id"></id>
        <result property="name" column="s_name"/>
        <result property="age" column="s_age"/>
    </resultMap>
    <!--  使用定义的映射，语句就不用加别名（as）了  -->
    <select id="getUserById" resultMap="userMap">
        select s_id, s_name, s_age from stu_info where s_id = #{id}
    </select>
</mapper>
```

## 7.动态语句

比如多条件查询，更新等。

反正就是 SQL 语句不确定。

可以用各种奇怪的标签实现动态构建。

### 固定语句

定义一段固定不变的语句。

更多用于定义某些重复的语句段。

```xml
<sql id="select_user">
    select s_id, s_name, s_age from stu_info
</sql>
```

### 条件与判断

用于语句后的条件拼装。

```xml
<select id="listUser" resultMap="userMap">
    <!--  导入定义好的固定语句  -->
    <include refid="select_user"/>
    <!--  定义条件  -->
    <where>
        <!--  按条件拼接指定语句  -->
        <if test="name != null and name != ''">
            s_name = #{name}
        </if>
        <!--  这玩意会自己判断，若这是第一个条件就会自己把 and 去掉  -->
        <if test="age != null">
            and s_age = #{age}
        </if>
    </where>
</select>
```

### 集合拼接

用于需要拼一堆东西时。

可以接收集合数组等玩意。

```xml
<select id="listUsersById" resultMap="userMap">
    <include refid="select_user"/>
    <where>
        s_id in
        <if test="list != null">
            <!--  遍历一个 list 类型的数据 -->
            <!--  每个被遍历到的元素别名为 id  -->
            <!--  语句起始与结束用（ 和 ）包裹  -->
            <!--  每个元素用 ，分割   -->
            <foreach collection="list" item="id" open="(" separator="," close=")">
                #{id}
            </foreach>
        </if>
    </where>
</select>
```

### 修改拼接

就是修改语句会用到的 set。

```xml
<update id="update">
    update stu_info
    <!--  定义修改规则  -->
    <set>
        <!--  这里也是记得加分割用的 ，号  -->
        <!--  末尾的自己会删  -->
        <if test="name != null and name != ''">
            s_name = #{name},
        </if>
        <if test="age != null">
            s_age = #{age},
        </if>
    </set>
    where s_id = #{id}
</update>
```

## 8.关系映射

如一个对象的某个字段存的是另一个对象。

下面用到的方法一般适用于同一个模块下的对象。

若需要别的模块下的对象就要在映射时加入外键字段。

### 示例对象

```java
package edu.nf.ch06.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.ArrayList;
import java.util.List;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    private Integer id;
    private String name;
    private Integer age;
    private IdCard card; // 一对一
    private List<Phone> phones = new ArrayList<>(); // 一对多
    private List<Subject> subjects = new ArrayList<>(); // 多对多
}
```

然后是另外三个对象。

```java
package edu.nf.ch06.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class IdCard {
    private Integer cid;
    private String cnum;
}
```

```java
package edu.nf.ch06.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Phone {
    private Integer pid;
    private String phone;
}
```

```java
package edu.nf.ch06.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Subject {
    private Integer id;
    private String name;
}
```

### 定义映射

然后就是定义 MyBatis 映射。

定义关系映射时，还是使用 resultMap。

举例了三种最常见的数据库中的关系。

- 一对一：
  - 使用 association。
  - property 定义映射的目标对象（类名小写即可，不行就打上完整地址（从蓝色 java 文件下开始））。
- 一对多：
  - 使用 collection。
  - 因为是多个，可以理解成集合。
  - 因为是集合，鉴于傻子虚拟机的问题，需要使用 ofType 指定映射的目标对象。
  - 不加 ofType 会导致虚拟机不知道这个集合装的是啥类型的数据。
- 多对多：
  - 和一对多的写法一样。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch06.mapper.UserMapper">

    <resultMap id="userMap" type="edu.nf.ch06.entity.User">
        <id property="id" column="s_id"/>
        <result property="name" column="s_name"/>
        <result property="age" column="s_age"/>
        <!--  定义一对一关联关系  -->
        <association property="card">
            <id property="cid" column="c_id"/>
            <result property="cnum" column="c_num"/>
        </association>
        <!--  定义一对多关联关系  -->
        <collection property="phones" ofType="phone">
            <id property="pid" column="p_id"/>
            <result property="phone" column="p_num"/>
        </collection>
        <!--  定义多对多关联关系  -->
        <collection property="subjects" ofType="subject">
            <id property="id" column="sub_id"/>
            <result property="name" column="sub_name"/>
        </collection>
    </resultMap>

    <select id="getUserById" resultMap="userMap">
        select s.s_id, s.s_name, s.s_age, c.c_num, p.p_num, p.p_id, sub.sub_name, sub.sub_id
        from stu_info s
        inner join id_card c on s.s_id = c.s_id
        inner join phone_info p on p.s_id = s.s_id
        inner join stu_sub ss on ss.s_id = s.s_id
        inner join subjects sub on sub.sub_id = ss.sub_id
        where s.s_id = #{id}
    </select>
</mapper>
```

## 9.SQL 注解（不推荐）

尽量用 xml，不推荐是用这玩意的说。

使用注解在接口抽象方法上定义 SQL 语句。

一般操作也就是 CURD。

所以一般也就用 Insert，Update，Delete，和 Select 这四个罢了。

就是 Select 特殊一点，需要额外定义返回的类型。

```java
package edu.nf.ch08.mapper;

import edu.nf.ch08.entity.User;
import org.apache.ibatis.annotations.*;

public interface UserMapper {
    // 定义语句
    @Insert("insert into stu_info(s_name, s_age) values(#{name}, #{age})")
    // 获取主键
    @Options(useGeneratedKeys = true, keyProperty = "id")
    void add(User user);

    @Update("update stu_info set s_name = #{name} where s_id = #{id}")
    void update(User user);

    @Delete("delete from stu_info where s_id = #{id}")
    void delete(int id);

    @Select("select s_id as id, s_name as name, s_age as age from stu_info where s_id = #{id}")
    // 映射对象（ResultType类型不能用类似Map类型）
    @ResultType(User.class)
    // 映射Map（与上面的二选一）
    // 这个Map用的其实还是mapers中的映射配置
//    @ResultMap("edu.nf.ch08.mapper.UserMapper.userMap")
    User getUserById(int id);
}
```

## 10.分页插件

pagehelper，简化分页操作用的。

### Maven 引入

第一步还是使用 Maven 引用别人写的。

反正去中央仓库找 pagehelper 就行。

```xml
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>6.1.0</version>
</dependency>
```

### 定义 mybatis 配置

也就是加个 SQL 日志输出和分页插件的配置。

其它大差不差。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-config.dtd">

<configuration>
    <settings>
        <!--  输出sql日志  -->
        <setting name="logImpl" value="STDOUT_LOGGING"/>
    </settings>
    
    <typeAliases>
        <package name="edu.nf.ch07.entity"/>
    </typeAliases>

    <!--  配置分页插件  -->
    <plugins>
        <!--  分页拦截器  -->
        <plugin interceptor="com.github.pagehelper.PageInterceptor">
            <!--  指定数据库方言  -->
            <property name="helperDialect" value="mysql"/>
            <!--  启用分页参数注解  -->
            <property name="supportMethodsArguments" value="true"/>
            <!--  分页合理化  -->
            <property name="reasonable" value="true"/>
        </plugin>
    </plugins>

    <environments default="mysql">
        <environment id="mysql">
            <transactionManager type="JDBC"/>
            <dataSource type="POOLED">
                <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
                <property name="url" value="jdbc:mysql://localhost:3307/java211?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=Asia/Shanghai"/>
                <property name="username" value="root"/>
                <property name="password" value="root"/>
            </dataSource>
        </environment>
    </environments>

    <mappers>
        <mapper resource="mappers/CityMapper.xml"/>
    </mappers>
</configuration>
```

### 定义 Mapper 接口

其实实现分页有两种方法：

- RowBounds 对象：
  - MyBatis 自带的分页用对象。
  - 不基于数据库，而是将数据全部提出至内存后筛分。
  - 所以数据大了就别用这玩意。
  - 当然数据不大也不推荐就是了。
- 分页插件：
  - 也是使用 @Param 注解定义参数。
  - 一般只需要定义 pageNum（当前页数）和 pageSize（每页页数）。
  - 这俩玩意的名字最好别改，这个插件默认识别这俩名字。

```java
package edu.nf.ch07.mapper;

import edu.nf.ch07.entity.City;
import org.apache.ibatis.annotations.Param;
import org.apache.ibatis.session.RowBounds;

import java.util.List;

public interface CityMapper {
    List<City> pageCity(RowBounds rowBounds);

    List<City> pageCityPlus(@Param("pageNum") int pageNum, @Param("pageSize") int pageSize);
}
```

### 定义 Mapper 映射

上面接口展示了两种方法，这里就先定义两句 SQL。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="edu.nf.ch07.mapper.CityMapper">

    <resultMap id="cityMap" type="edu.nf.ch07.entity.City">
        <id property="cityId" column="city_id"/>
        <result property="cityName" column="city_name"/>
        <result property="cityCode" column="city_code"/>
        <result property="province" column="province"/>
    </resultMap>

    <select id="pageCity" resultMap="cityMap">
        select city_id, city_name, city_code, province from city_info
    </select>

    <select id="pageCityPlus" resultMap="cityMap">
        select city_id, city_name, city_code, province from city_info
    </select>
</mapper>
```

### 定义 Service 方法

这里可以使用插件内的 PageInfo 对象进行封装。

```java
package edu.nf.ch07.service;

import com.github.pagehelper.PageInfo;
import edu.nf.ch07.entity.City;
import edu.nf.ch07.mapper.CityMapper;
import edu.nf.ch07.util.MyBatisUtils;
import org.apache.ibatis.session.RowBounds;
import org.apache.ibatis.session.SqlSession;

import java.util.List;

public class CityService {
    public List<City> CityMapper(int pageNum, int pageSize) {
        RowBounds rowBounds = new RowBounds(pageNum, pageSize);
        try (SqlSession session = MyBatisUtils.getSession(true)) {
            return session.getMapper(CityMapper.class).pageCity(rowBounds);
        }
    }
    public PageInfo<City> CityMapperPlus(int pageNum, int pageSize) {
        RowBounds rowBounds = new RowBounds(pageNum, pageSize);
        try (SqlSession session = MyBatisUtils.getSession(true)) {
            List<City> cities = session.getMapper(CityMapper.class).pageCityPlus(pageNum, pageSize);
            // 可以封装分页记录
            // 如总记录数，总页数，起始页，下一页...
            return new PageInfo<>(cities);
        }
    }
}
```

### 调用

这插件用的时候就传当前页数，和每页页数就好了。

返回的是一个对象。

它装了一堆本来需要自己折腾才能获取的东西。

- `pageNum`：当前页码。
- `pageSize`：每页显示的记录数。
- `size`：当前页的实际记录数。
- `startRow`：当前页面第一条记录在总结果集中的位置。
- `endRow`：当前页面最后一条记录在总结果集中的位置。
- `total`：总记录数。
- `pages`：总页数。
- `list`：当前页的记录列表。
- `hasNextPage`：是否还有下一页。
- `hasPreviousPage`：是否有前一页。
- `isFirstPage`：是否是第一页。
- `isLastPage`：是否是最后一页。
- `navigatePages`：导航页码数。
- `navigatepageNums`：可连续显示的页码集合。

```java
package edu.nf.ch07;

import com.github.pagehelper.PageInfo;
import edu.nf.ch07.entity.City;
import edu.nf.ch07.service.CityService;

import java.util.List;

public class Main {
    public static void main(String[] args) {
        CityService service = new CityService();
//        List<City> citys = service.CityMapper(0, 5);
//        for (City city : citys) {
//            System.out.println(city);
//        }

        PageInfo<City> citys = service.CityMapperPlus(0, 5);
        for (City city : citys.getList()) {
            System.out.println(city);
        }
    }
}
```

