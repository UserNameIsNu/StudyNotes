[TOC]

# SpringBoot

# 1，简介

## 1.这是啥

Spring Boot 是 Spring 框架的一个子项目，它的核心设计目标是简化。

它旨在让开发者以最少的配置和最短的时间，快速创建并运行一个基于 Spring 的、生产级别的独立应用程序。

- SB可以极大的简化（极大简化，不是不用）配置，一般引用后SB会自动打上相关的依赖，版本也会调好。
- SB还内置了一些容器，不用自己配置容器，编译，打包再部署。

# 2，动手

## 1.创建一个SB项目

IDE一般似乎都是有创建SB的预设的。

我用的IDEA也是有的，跟着引导走就行。

没啥好说的：）

先啥都不用引入，纯净SB项目即可，先别管导入乱七八糟的玩意。

## 2.认识这个SB项目

似乎一个没有导入任何其它依赖的SB项目就有下面四个文件的样子。

### meven配置

我删了点没啥用的，不影响。

这里就留了非常之重要的配置。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--
        这里是SB的父级依赖
        提供了默认的Java版本，UTF-8的编码设置，插件管理与各种依赖库的版本号管理等功能
        且受益于父级依赖包含的版本号管理功能，这里引入其它库依赖时基本都不需要定义版本号了
      -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version> <!--  要更换SB版本，直接改这里的版本号就行  -->
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <!--  项目坐标  -->
    <groupId>edu.nf</groupId>
    <artifactId>ch01</artifactId>
    <version>0.0.1-SNAPSHOT</version>

    <!--  项目名与项目描述  -->
    <name>ch01</name>
    <description>ch01</description>

    <!--  删了也无妨  -->
    <properties>
        <java.version>21</java.version>
    </properties>

    <dependencies>
        <!--
            SB核心依赖
          -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <!--  SB单元测试依赖  -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <!--  用于把SB应用打成jar或war  -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### SB核心配置文件

SB的核心配置文件。

如果需要改变SB的默认自动配置就在这里改。

不用再去xml里折腾了，修改一些默认值就行了。

同时还支持另外一种格式文件，就是application.yml（缩进式的配置方式）。

```properties
# 当前的SB应用叫什么名字（创建完项目默认就这一行）
spring.application.name=ch01
```

### SB核心启动类

SB应用的核心启动类。

SB应用就是直接通过main方法启动，不用像之前的SSM要挂在容器里面跑。

SB的默认扫描路径从当前启动类所在的包开始扫描，包含所有子包。

或者也能通过scanBasePackages属性修改扫描路径（不建议的说）。

其中关于复合注解中包含的EnableAutoConfiguration注解。

这玩意就是通过导入一个选择器将所有自动配置类加载到Spring容器中，实现自动装配。

所以后续想把其它三方包集成到SB中基本就是通过其中的选择器来集成了。

```java
package edu.nf.ch01;

import edu.nf.ch01.service.UserService;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

/**
* SpringBootApplication注解是一个复合注解
* 包含Configuration，ComponentScan，EnableAutoConfiguration等注解
* 所以这个启动类同时也算是一个配置类，还具备扫描与自动启用配置的功能
*/
@SpringBootApplication
public class Ch01Application {
    /**
    * 运行SB应用（初始化SB）
    * 运行后会返回一个初始化好的容器
    * 这个返回的容器会根据当前的部署环境而改变
    * 如没集成Web环境时就会返回一个普通IOC
    * 如集成了Web环境时就会返回一个WebApplicationContext
    */
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Ch01Application.class, args);
        // 这个UserService就是随便建的一个空类
        UserService service = context.getBean(UserService.class);
        System.out.println(service);
    }
}
```

### SB测试类

单元测试的集成环境，且受容器管理。

所以可以在这些类里面注入需要测试的Bean。

```java
package edu.nf.ch01;

import edu.nf.ch01.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Ch01ApplicationTests {
    private UserService userService;

    // 注入UserService
    public Ch01ApplicationTests(UserService userService) {
        this.userService = userService;
    }

    @Test
    void contextLoads() {
        // 测试userService
    }
}
```

## 3.yml配置类型

创建SB项目后，resource下一般都会有一个SB自己的配置文件叫application.propertise。

不过有一个更推荐的（看起来舒服多了的）格式就是yml（也叫yaml）。

SB会默认读取application.properties或application.yml这两个文件的，找到谁用谁（都有读谁就不知道了）。

读取的内容一般就会绑定到具体的java对象里面，用来干点解析配置啥的活儿。

yml叫什么缩进式配置。

下面的用于定义SB项目的名字的yml格式的配置，等同于propertise下的`spring.application.name=ch02`。

```yaml
# yml配置使用 : 加换行（点空格，不能用tab）进行分割
# 值不需要换行，但也要加一个空格
spring:
    application:
        name: ch02
```

### 值绑定

这是yml最基础的配置绑定格式。

配置文件嘛，里面的东西总是要拿出来绑进程序里面用的嘛。

值绑定就是yml最简单的绑定写法了。

```yaml
student:
	userId: 1
	userName: tom
	age: 22
```

再假设有个对象Student。

```java
package com.example.ch02.entity;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;

@Data
@Component
public class Student {
    // 使用@Value注解绑定单一层级值
	@Value("${student.userId}")
    private Integer userId;

	@Value("${student.userName}")
    private String userName;

	@Value("${student.age}")
    private Integer userAge;
}
```

### 松散绑定

这个就是厉害多的写法。

基本啥都能绑定。

不像值绑定，绑个单一层级的值就没了。

别说数组集合啥的，对象都绑不了。

在yml中可以使用驼峰模式（userName）或中短杠（user-name）又或全大写加下划线（USER_NAME）命名。

```yaml
student:
    user-id: 1
    userName: tom
    age: 22
    # 对象
    card:
        cardNum: 12345
    # 数组（两种写法）
    # phones: 123, 456, 789
    phones:
        - 123
        - 456
        - 789
    # map集合
    score:
        A: 1
        B: 2
        C: 3
    # 对象集合
    teachers:
        - name: T1
          age: 40
        - name: T2
          age: 50
```

再做对象。

```java
package com.example.ch02.entity;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Data
@Component
@ConfigurationProperties(prefix="student")
public class Student {
    private Integer userId;

    private String userName;

    private Integer userAge;

    // 这是个自建对象
    private Card card;

    private String[] phones;

    private Map<String, Integer> score;

    // 这里面的Teacher也是个自建对象
    private List<Teacher> teachers;
}
```

### 多环境配置

需要遵循application-xxx的命名规定。

用来区别如测试环境，开发环境，生产环境等不同情况下的程序运行配置。

切换不同配置组只需要在主配置类里加一句就行。

```yaml
spring:
    # 激活配置（要激活哪一份配置文件就改成对应文件名短杠后的名字）
    profiles:
    	# 如这是application主配置类
    	# 还有application-test和application-dev两个不同环境的配置组
    	# 就用test和dev就可以切换配置组了
        active: dev
```

就用测试模式下让控制台输出的日志显示颜色举例。

主配置类切到test就会让测试模式下的控制台日志输出保持颜色。

切到dev就会让测试模式下的控制台输出取消颜色。

```yaml
# application-test
spring:
    output:
        ansi:
            enabled: always
```

```yaml
# application-dev
spring:
    output:
        ansi:
            enabled: never
```

### 多模块配置

也需要遵循application-xxx的命名规定。

一般就是如dao层整一个application-dao.yml，web层整一个application-web.yml之类的。

除了一堆模块自己的独立配置类，在要有一个SB项目的主配置类。

主配置类啥都别配，只用来导其它配置类。

要导哪个文件，就把那个文件名短杠后的名字加进来，和上面多环境配置的写法相同。

```yaml
spring:
    profiles:
        include: web, dao
```

主要就是多环境配置模式下的主配置类还是可以写配置的。

多模块配置模式下的主配置类就不要写任何配置了，除了这一句导入配置的就啥也别加。

## 4.配置数据源

现在基本了解了SB项目的结构，与SB项目的配置方式。

接下来折腾一下数据源。

连上数据源后基本就能用这套玩意开始做些项目了（环境和数据库有了基本就能动了）。

### JDBC依赖

首先就是打上JDBC的依赖。

这玩意当然又是SB做好的集成包。

包含JDBCTemplate（Spring对JDBC做的封装）还自带Hikari连接池。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

### 配置数据源配置

当然还是写在application.yml里面（后续需要多环境或多模块配置再说，这里就是个案例，塞一起了）。

```yaml
spring:
    datasource:
    	# 老四样
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        # SB自带的连接池（Hikari）
        hikari:
            # 最小空闲连接数
            minimum-idle: 5
            # 最大连接数
            maximum-pool-size: 200
            # 极限空闲时长（超出后将大于最小空闲连接数量的连接关掉）
            idle-timeout: 90000
            # 超时时长（超出后还没从池子里拿到连接就报错）
            connection-timeout: 5000
            # 检查连接是否有效
            connection-test-query: select 1
```

### 测试连接

```java
package com.example.ch03;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

@SpringBootTest
@Slf4j
class Ch03ApplicationTests {
    // 数据源
    @Autowired
    private DataSource dataSource;

    // JDBC模板
    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 尝试获取连接
    @Test
    void testHikari() throws SQLException {
        log.info(dataSource.toString());
        log.info("connection: {}", dataSource.getConnection());
    }

    // 尝试执行查询语句
    @Test
    void testTemplate() {
        List<Map<String, Object>> list = jdbcTemplate.queryForList("select * from city_info");
        for (Map<String, Object> map : list) {
            log.info(map.toString());
        }
    }

}
```

### 切换数据源

比如不想用SB内置的hikari连接池，想换个如druid。

那么去meven导一下依赖。

然后改一下application.yml就行。

基本就是把druid的配置加上，多给一句指向新的连接类型的type就可以了。

```yaml
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        # 指定连接类型
        type: com.alibaba.druid.pool.DruidDataSource
        # druid连接池
        druid:
            # 最大连接数
            max-active: 200
            # 最小空闲连接数
            min-idle: 5
            # 初始化连接数
            initial-size: 5
            # 极限空闲时长1
            max-wait: 5000
            # 检查连接是否有效
            validation-query: select 1
            # 是否缓存PreparedStatement
            pool-prepared-statements: false
```

## 5.MyBatis集成

SB的配置有了，数据源配置也有了，那么下一步当然就是跑SQL语句试试了。

那么当然还是用MyBatis这玩意了。

SB给MyBatis也做了一个启动包，导进去就能用了。

### MyBatis依赖

这里面相比上面主要也就是多了个MyBatis和数据库的依赖。

```xml
<dependencies>
    <!--  SB给的JDBC启动包  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-jdbc</artifactId>
    </dependency>

    <!--  SB给的MyBatis启动包  -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.5</version>
    </dependency>

    <!--  数据库  -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>

    <!--  SB自己的核心启动包  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!--  对象快速构建插件  -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>

    <!--  SB给的分页插件启动包  -->
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper-spring-boot-starter</artifactId>
        <version>2.1.1</version>
    </dependency>
</dependencies>
```

### 配置

这里还是使用默认的hikari连接池。

额外加上mybatis和分页插件的配置。

```yaml
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        hikari:
            # 最小空闲连接数
            minimum-idle: 5
            # 最大连接数
            maximum-pool-size: 200
            # 极限空闲时长（超出后将大于最小空闲连接数量的连接关掉）
            idle-timeout: 90000
            # 超时时长（超出后还没从池子里拿到连接就报错）
            connection-timeout: 5000
            # 检查连接是否有效
            connection-test-query: select 1
mybatis:
    # 扫描的包实体
    type-aliases-package: com.example.ch04.entity
    # mapper映射路径
    mapper-locations: classpath:/mappers/*.xml
    configuration:
        # 输出日志
        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
pagehelper:
    # 数据库方言
    helper-dialect: mysql
    # 分页合理化
    reasonable: true
    # 启用注解分页参数
    support-methods-arguments: true
```

### 对象

这没啥好讲的。

```java
package com.example.ch04.entity;

import lombok.Data;

@Data
public class City {
    private Integer cityId;
    private String cityName;
    private String cityCode;
    private String Province;
}
```

### mapper映射

就简单做的分页查询的方法先。

用了分页插件罢了，给两个参数就行。

```java
package com.example.ch04.mapper;

import com.example.ch04.entity.City;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface CityMapper {
    List<City> listCity(@Param("pageNum") int pageNum, @Param("pageSize") int pageSize);
}
```

还有对应的xml映射。

指定mapper映射路径，实体映射路径和语句。

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.ch04.mapper.CityMapper">
    <resultMap id="cityMap" type="city">
        <id property="cityId" column="city_id"/>
        <result property="cityName" column="city_name"/>
        <result property="cityCode" column="city_code"/>
        <result property="province" column="province"/>
    </resultMap>
    <select id="listCity" resultMap="cityMap">
        select city_id, city_name, city_code, province from city_info
    </select>
</mapper>
```

### mapper扫描

SB项目中可以直接在启动类开扫描。

```java
package com.example.ch04;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.example.ch04.mapper")
public class Ch04Application {

    public static void main(String[] args) {
        SpringApplication.run(Ch04Application.class, args);
    }

}
```

### 测试

SB项目嘛，既然自己都带一个单元测试的支持，就直接去那里面测测。

把mapper注入过来，直接在test方法里面跑一下试试。

```java
package com.example.ch04;

import com.example.ch04.entity.City;
import com.example.ch04.mapper.CityMapper;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import java.util.List;

@SpringBootTest
@Slf4j
class Ch04ApplicationTests {
    @Autowired
    private CityMapper cityMapper;

    @Test
    void testListCity() {
        List<City> cityList = cityMapper.listCity(2, 10);
        cityList.forEach(city -> log.info("{}", city.getCityName()));
    }

}
```

## 6.SB的默认Web容器

### Web依赖

首先，这里的容器指Web容器。

既然是Web容器，那么崭新出场的SB项目当然是没有支持的。

不过SB这玩意确实方便，还是去Meven依赖一下SB做好的Web启动包就行。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
</dependency>
```

### 容器切换

SB默认支持三种容器（tomcat，jetty，undertow），SB默认用tomcat。

如果想换成另外两种容器，改一改依赖就行。

首先就是让SB把默认的tomcat弄掉。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-web</artifactId>
    <!--  排除内部的tomcat  -->
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-tomcat</artifactId>
        </exclusion>
    </exclusions>
</dependency>
```

然后加上想用的容器依赖就行了。

这是jetty容器的依赖。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jetty</artifactId>
</dependency>
```

这是undertow容器的依赖。

选一个加上就能换掉tomcat了（一般没啥特殊需要也没必要换掉它）。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-undertow</artifactId>
</dependency>
```

## 7.SB一些常用的配置

在继续进度前先列一下SB中比较常用的配置。

```yaml
spring:
    application:
        name: ch05
    # 静态资源管理器
    web:
        resources:
            static-locations: classpath:whatTheFuckIsThis, classpath:static
    # 视图解析器
    mvc:
        view:
            prefix: /WEB-INF/jsp
            suffix: .jsp
    # jackson
    jackson:
        date-format: yyyy-MM-dd HH:mm:ss
        time-zone: GMT+8
    # 上传配置
    servlet:
        multipart:
            enabled: true
            max-file-size: 10MB
            max-request-size: 800MB
    lifecycle:
        # 设置优雅停机的缓冲时间，就是给它这些时间用来处理后事
        # 超时的话就不管了，直接弄死
        timeout-per-shutdown-phase: 30s
# web容器配置
server:
    # 端口号
    port: 8089
    # 启用优雅停机
    shutdown: graceful
    # 上下文路径
    servlet:
        context-path: /
        # 字符编码过滤器
        encoding:
            enabled: true
            charset: UTF-8
            force: true
    # 错误页面配置
    error:
        whitelabel:
            enabled: false
```

## 8.静态资源管理器

SB默认启用了静态资源管理器，静态资源直接丢进约定目录下就行。

### 约定目录

约定目录有static，public，resources。

这三个约定目录下的资源不用配置啥。

比如直接在目录下第一级的一个html，理应可以直接以上下文地址+文件名访问到。

还可以自定义新的静态资源目录，这个自定义目录也是从resources开始找。

不过定义了自定义的静态资源目录后，默认约定的三个目录就失效了，完全就按照自己定义的目录走了。

### 手动配置

每个classpath就用来指定一个受管理的静态资源目录。

多个需要受管理的静态资源目录就用多个classpath，用英文逗号分隔。

```yaml
spring:
    web:
    	resources:
        	static-locations: classpath:whatTheFuckIsThis, classpath:static
```

## 9.错误页面配置

SB默认是有用于展示报错的页面的。

如果不想要SB默认的错误页面，也是可以自定定义的。

在可以访问的任意静态资源目录下加个error目录，里面放自己的错误页面就行。

错误页面的命名必须是`错误码.html`。

```yaml
server:
    error:
        whitelabel:
        	# 设置禁用默认的错误页面，用自己的
            enabled: false
```

## 10.SB中的过滤器

先做三个假过滤器（只是结构，没有实际业务的）。

```java
package com.example.ch05.filter;

import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

@WebFilter(urlPatterns = "/*")
@Slf4j
public class MyFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("自定义过滤器1");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

```java
package com.example.ch05.filter;

import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

@WebFilter(urlPatterns = "/*")
@Slf4j
public class TestFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("自定义过滤器2");
        filterChain.doFilter(servletRequest, servletResponse);
    }
}
```

```java
package com.example.ch05.filter;

import jakarta.servlet.*;
import jakarta.servlet.annotation.WebFilter;
import lombok.extern.slf4j.Slf4j;

import java.io.IOException;

@WebFilter(urlPatterns = "/*")
@Slf4j
public class FirstFilter implements Filter {
    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        log.info("自定义过滤器3");
        filterChain.doFilter(servletRequest, servletResponse);
    }
```

### 默认处理

@ServletComponentScan是SB提供的，专门用来扫描servlet组件（servlet，filter，listener等）的玩意。

不过这种方法，在存在多个过滤器时，无法指定过滤顺序，默认按照过滤器文件名首字母顺序执行。

```java
package com.example.ch05.config;

import com.example.ch05.filter.FirstFilter;
import com.example.ch05.filter.MyFilter;
import com.example.ch05.filter.TestFilter;
import org.springframework.boot.web.servlet.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@ServletComponentScan("com.example.ch05.filter")
public class MvcConfig {}
```

### 动态注册器

RegistrationBean，动态注册器。

用这玩意注册Servlet组件，可以控制过滤执行顺序。

一般有有三种注册器，分别用于servlet，filter，listener。

ServletRegistrationBean，FilterRegistrationBean，ServletListenerRegistrationBean。

```java
package com.example.ch05.config;

import com.example.ch05.filter.FirstFilter;
import com.example.ch05.filter.MyFilter;
import com.example.ch05.filter.TestFilter;
import org.springframework.boot.web.servlet.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class MvcConfig {
    @Bean
    public FilterRegistrationBean myFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setFilter(new MyFilter());
        filterRegistrationBean.setName("myFilter");
        filterRegistrationBean.addUrlPatterns("/*");
        // 这玩意用来给过来过滤器排队，数字越小越先执行
        filterRegistrationBean.setOrder(1);
        return filterRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean testFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setFilter(new TestFilter());
        filterRegistrationBean.setName("testFilter");
        filterRegistrationBean.addUrlPatterns("/*");
        filterRegistrationBean.setOrder(2);
        return filterRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean firstFilter() {
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean<>();
        filterRegistrationBean.setFilter(new FirstFilter());
        filterRegistrationBean.setName("firstFilter");
        filterRegistrationBean.addUrlPatterns("/*");
        filterRegistrationBean.setOrder(3);
        return filterRegistrationBean;
    }
}
```

## 11.SB整合SSM

这就是可以搓项目前的最后一步了。

整合完SSM理应就可以做点什么玩玩了。

一个常规且典型的SB项目也算是完整了。

### 依赖

有这些依赖就够了。

```xml
<dependencies>
    <!--  Web  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>

    <!--  核心  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>

    <!--  对象构建插件  -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>

    <!--  数据库  -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
    </dependency>

    <!--  mybatis  -->
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.5</version>
    </dependency>

    <!--  分页插件  -->
    <dependency>
        <groupId>com.github.pagehelper</groupId>
        <artifactId>pagehelper-spring-boot-starter</artifactId>
        <version>2.1.1</version>
    </dependency>
</dependencies>
```

### 配置

这次既然整合了SSM，那么这次的配置就采用多模块配置。

主配置文件：

```yaml
spring:
    profiles:
        include: dao, web
```

持久层配置文件：

```yaml
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        hikari:
            # 最小空闲连接数
            minimum-idle: 5
            # 最大连接数
            maximum-pool-size: 200
            # 极限空闲时长（超出后将大于最小空闲连接数量的连接关掉）
            idle-timeout: 90000
            # 超时时长（超出后还没从池子里拿到连接就报错）
            connection-timeout: 5000
            # 检查连接是否有效
            connection-test-query: select 1
mybatis:
    # 扫描的包实体
    type-aliases-package: com.notfound.ch05_homework.entity
    # mapper映射路径
    mapper-locations: classpath:/mappers/*.xml
    configuration:
        # 输出日志
        log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
pagehelper:
    # 数据库方言
    helper-dialect: mysql
    # 分页合理化
    reasonable: true
    # 启用注解分页参数
    support-methods-arguments: true
```

web配置文件：

```yaml
spring:
    application:
        name: ch05
    lifecycle:
        # 优雅停机的缓冲时间
        timeout-per-shutdown-phase: 30s
# web容器配置
server:
    # 端口号
    port: 8080
    # 优雅停机
    shutdown: graceful
    # 上下文路径
    servlet:
        context-path: /
        # 字符编码过滤器
        encoding:
            enabled: true
            charset: UTF-8
            force: true
```

### 实体

还是随便搓一个（数据库里有啥表就搓啥实体就行，练习嘛）。

```java
package com.notfound.ch05_homework.entity;

import lombok.Data;

@Data
public class City {
    private Integer cityId;
    private String cityName;
    private String cityCode;
    private String Province;
}
```

### mapper映射

还是那一对。

接口mapper和xmlmpper。

```java
package com.notfound.ch05_homework.mapper;

import com.notfound.ch05_homework.entity.City;
import org.apache.ibatis.annotations.Param;

import java.util.List;

public interface CityMapper {
    List<City> listCity(@Param("pageNum") int pageNum, @Param("pageSize") int pageSize);
}
```

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.notfound.ch05_homework.mapper.CityMapper">
    <resultMap id="cityMap" type="com.notfound.ch05_homework.entity.City">
        <id property="cityId" column="city_id"/>
        <result property="cityName" column="city_name"/>
        <result property="cityCode" column="city_code"/>
        <result property="province" column="province"/>
    </resultMap>

    <select id="listCity" resultMap="cityMap">
        select city_id, city_name, city_code, province from city_info
    </select>
</mapper>
```

### service层

也是接口——实现这一对。

```java
package com.notfound.ch05_homework.service;

import com.notfound.ch05_homework.entity.City;

import java.util.List;

public interface CityService {
    List<City> listCity(int pageNum, int pageSize);
}
```

```java
package com.notfound.ch05_homework.service.impl;

import com.notfound.ch05_homework.entity.City;
import com.notfound.ch05_homework.mapper.CityMapper;
import com.notfound.ch05_homework.service.CityService;
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class CityServiceImpl implements CityService {
    private final CityMapper cityMapper;

    public CityServiceImpl(CityMapper cityMapper) {
        this.cityMapper = cityMapper;
    }

    @Override
    public List<City> listCity(int pageNum, int pageSize) {
        return cityMapper.listCity(pageNum, pageSize);
    }
}
```

### controller层

对外的入口嘛。

```java
package com.notfound.ch05_homework.web;

import com.notfound.ch05_homework.entity.City;
import com.notfound.ch05_homework.service.CityService;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;

@RestController
public class CityController implements CityService {
    private final CityService cityService;

    public CityController(CityService cityService) {
        this.cityService = cityService;
    }

    @GetMapping("/list/city")
    public List<City> listCity(int pageNum, int pageSize) {
        return cityService.listCity(pageNum, pageSize);
    }
}
```

### 跨域配置

这里整个前后分离形式的练习。

多一个跨域配置。

单独做一个MvcConfig就行。

```java
package com.notfound.ch05_homework.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")  // 允许所有路径
                .allowedOriginPatterns("*")  // 允许所有来源
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")  // 允许的请求方法
                .allowedHeaders("*")  // 允许所有请求头
                .allowCredentials(true)  // 允许发送cookie
                .maxAge(3600);  // 预检请求的有效期，单位为秒
    }
}
```

### 启动类

最后在SB的启动类里打上mapper扫描。

然后运行。

去浏览器直接访问上面controller开放的地址理应就会有返回的数据了。

```java
package com.notfound.ch05_homework;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
@MapperScan("com.notfound.ch05_homework.mapper")
public class Ch05HomeworkApplication {

    public static void main(String[] args) {
        SpringApplication.run(Ch05HomeworkApplication.class, args);
    }

}
```

## 12.starter启动包

SB这么方便的很重要的一个原因就是SB把很多包或插件封成了starter包。

这些启动包在SB启动时会一并把它们打包的包与插件一起初始化。

相当于在这个SB项目中就不再需要进行它们的配置。

就是不用再写配置类啦。

starter里面已经封好了它们的配置类，SB项目依赖它们后只需要在yml中定义它们所需的属性的值就行了。

提一下starter包的命名。

模块名必须是：打包的包或插件名-spring-boot-starter（这个例子里为：`c3p0-spring-boot-starter`）。

根目录下的包名必须是：org.打包的包或插件名.spring.boot.autoconfigure（这个例子里为：`org.c3p0.spring.boot.autoconfigure`）。

下面的参数对象必须放在上面包名下的properties目录下。

参数对象名必须为：打包的包或插件名+DataSourceProperties（这个例子里为：`C3p0DataSourceProperties`）。

自动配置类名必须为：打包的包或插件名+DataSourceAutoConfigure（这个例子里为：`c3p0DataSourceAutoConfigure`）。

### 依赖

虽然使用启动包的SB项目不需要依赖这些启动包本身打包的依赖。

但是为了做这个启动包，启动包内还是要这些包或插件的依赖的。

除了要打包的玩意外，多依赖两个SB给的方便做启动包的玩意。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--  启动包不需要继承任何父级依赖  -->
    <!--  直接定义自己于meven中的路径与版本号，打包为jar  -->
    <groupId>org.c3p0.spring.boot</groupId>
    <artifactId>c3p0-spring-boot-starter</artifactId>
    <version>1.0</version>
    <packaging>jar</packaging>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!--  添加自动依赖配置，用于发现并加载配置类  -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-autoconfigure</artifactId>
            <version>3.5.5</version>
        </dependency>

        <!--  将@ConfigurationProperties标注的类以及绑定的属性注入到元数据中  -->
        <!--  在IDEA中将会检测到元数据，进而可以提供代码提示的功能  -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <version>3.5.5</version>
        </dependency>

        <!--  这里演示打包的连接池，c3p0  -->
        <dependency>
            <groupId>c3p0</groupId>
            <artifactId>c3p0</artifactId>
            <version>0.9.1.2</version>
        </dependency>
    </dependencies>

</project>
```

### 参数对象

然后需要定义一个类，用于封装启动包打包的包所需的参数。

这里打包的是c3p0连接池，它主要就四个参数，所以这里就封这四个参数。

记得还要打上用于松散绑定的注解，方便去yml里面找到它自己的配置值。

（启动包的参数对象不建议用lombok，老实显示标明get-set方法）。

```java
package org.c3p0.spring.boot.autoconfigure.properties;

import org.springframework.boot.context.properties.ConfigurationProperties;

@ConfigurationProperties(prefix = "spring.datasource.c3p0")
public class C3p0DataSourceProperties {
    private Integer maxPoolSize = 200;
    private Integer minPoolSize = 5;
    private Integer initialPoolSize = 5;
    private Integer maxIdleTime = 6000;

    public Integer getMaxPoolSize() {
        return maxPoolSize;
    }

    public void setMaxPoolSize(Integer maxPoolSize) {
        this.maxPoolSize = maxPoolSize;
    }

    public Integer getMinPoolSize() {
        return minPoolSize;
    }

    public void setMinPoolSize(Integer minPoolSize) {
        this.minPoolSize = minPoolSize;
    }

    public Integer getInitialPoolSize() {
        return initialPoolSize;
    }

    public void setInitialPoolSize(Integer initialPoolSize) {
        this.initialPoolSize = initialPoolSize;
    }

    public Integer getMaxIdleTime() {
        return maxIdleTime;
    }

    public void setMaxIdleTime(Integer maxIdleTime) {
        this.maxIdleTime = maxIdleTime;
    }
}
```

### 自动配置类

然后就是做一个用来自动配置这个连接池并初始化它，还装进SB的容器管理的类。

这里标的四个注解：

- 标记为配置类。
- 传入的类存在时才初始化这个类。
- 在传入的类加载前加载这个类。
- 将有@ConfigurationProperties标记的类加入容器管理。

```java
package org.c3p0.spring.boot.autoconfigure;

import com.mchange.v2.c3p0.ComboPooledDataSource;
import javax.sql.DataSource;
import org.c3p0.spring.boot.autoconfigure.properties.C3p0DataSourceProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration;
import org.springframework.boot.autoconfigure.jdbc.DataSourceProperties;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.beans.PropertyVetoException;

@Configuration
@ConditionalOnClass(ComboPooledDataSource.class)
@AutoConfigureBefore(DataSourceAutoConfiguration.class)
// 前面的是SB的数据源连接属性，后面的是c3p0的连接池属性
 @EnableConfigurationProperties({DataSourceProperties.class, C3p0DataSourceProperties.class})
public class c3p0DataSourceAutoConfigure {
    @Autowired
    private DataSourceProperties dataSourceProperties;

    @Autowired
    private C3p0DataSourceProperties c3p0DataSourceProperties;

    @Bean
    // 容器中不存在这个DataSources的Bean就初始化它
    @ConditionalOnMissingBean
    public DataSource dataSources() throws PropertyVetoException {
        // 初始化c3p0连接池
        ComboPooledDataSource dataSource = new ComboPooledDataSource();
        dataSource.setJdbcUrl(dataSourceProperties.getUrl());
        dataSource.setDriverClass(dataSourceProperties.getDriverClassName());
        dataSource.setPassword(dataSourceProperties.getPassword());
        dataSource.setUser(dataSourceProperties.getUsername());
        dataSource.setMaxPoolSize(c3p0DataSourceProperties.getMaxPoolSize());
        dataSource.setMinPoolSize(c3p0DataSourceProperties.getMinPoolSize());
        dataSource.setInitialPoolSize(c3p0DataSourceProperties.getInitialPoolSize());
        dataSource.setMaxIdleTime(c3p0DataSourceProperties.getMaxIdleTime());
        return dataSource;
    }
}
```

### 启动路径

最后就是做一个名字特别长的文件。

resources下的META-INF下的spring下的`包名+自动配置类名.imports`文件。

这个例子中是：`org.c3p0.spring.boot.autoconfigure.c3p0DataSourceAutoConfigure`。

```import
org.c3p0.spring.boot.autoconfigure.c3p0DataSourceAutoConfigure
```

### 使用

这样一个自己搓的starter包就做好了。

在新的SB项目中依赖自己搓的这个starter包（不要依赖了这个starter忘了数据库驱动，这只是个连接池）。

```xml
<dependency>
    <groupId>org.c3p0.spring.boot</groupId>
    <artifactId>c3p0-spring-boot-starter</artifactId>
    <version>1.0</version>
</dependency>
```

在yml中为自己定义的参数对象传值。

```yaml
spring:
    application:
        name: ch07
    # 数据源配置不变
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        # 这里就是参数对象的值
        c3p0:
            max-pool-size: 100
            min-pool-size: 10
            initial-pool-size: 5
            max-idle-time: 3000
        type: com.mchange.v2.c3p0.ComboPooledDataSource
```

在单元测试中试一试。

```java
package com.ljf.ch07;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;

import javax.sql.DataSource;
import java.sql.SQLException;

@SpringBootTest
@Slf4j
class Ch07ApplicationTests {
    @Autowired
    private DataSource dataSource;

    @Test
    void contextLoads() throws SQLException {
        log.info("connection: {}", dataSource);
        log.info("connection: {}", dataSource.getConnection());
    }

}
```

## 13.REST API和OPEN API

### REST API

这玩意就是一个接口风格？

不是啥工具，框架，更不是规范。

连个建议都不是。

只是一种风格，算是一种接口的写法。

- 使用URL定位资源，尤其URL只能出现名词描述，不能有动词状态。
- 动词，就是不同的操作用不同的HTTP方法描述。
  - GET：获取些啥。
  - POST：创建些啥。
  - PUT：更新或修改整个对象或一堆玩意。
  - PATCH：更新或修改个别字段或一点点东西。
  - DELETE：删除些啥。

- 返回的响应全部使用JSON格式（VO响应对象）统一。

遵循这些规定写出来的接口就算是REST API。

### OPEN API

这玩意就是一个规范了。

一个专门描述REST API的规范。

用来进一步描述完善，精修REST API的玩意。

前身似乎叫swagger。

定义了一大堆如接口路径，请求参数，响应格式等各种注解。

它定义的这堆注解又可以为它自己自带的一个文档生成插件提供数据。

就是可以动态的，根据注解接收到的数据，为编写的接口生成详细的接口文档。

### 案例

#### 配置

整个新玩意，先导包并配置。

这个OPEN API要导一个包，写两份配置（yml一个，还要单独做一个配置类）。

```
<dependency>
    <groupId>org.springdoc</groupId>
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
    <version>2.8.13</version>
</dependency>
```

```yaml
spring:
    application:
        name: ch08_homework
# open api配置
springdoc:
    # Swagger UI的访问路径（这是‘localhost://8080/swagger.html’）
    swagger-ui:
        path: /swagger.html
    # 给哪些目录下的类生成文档（一般生成接口文档那么当然就要指到controller目录嘛）
    packages-to-scan: edu.ljf.ch08_homework.web
    # 是否启用自动生成文档（false的话写了注解，进到Swagger UI也不会有文档）
    api-docs:
        enabled: true
```

这个配置类里有些OPEN API的注解。

- @OpenAPIDefinition：全局文档基本解释。
  - Info：文档基本信息。
  - security：文档遵循的开源协议。
- @Info：文档基本信息。
  - title：文档标题。
  - version：文档版本。
  - description：文档描述。
  - license：开源协议信息。
- @SecurityScheme：定义具体安全认证方案。
  - name：开源协议名。
  - type：HTTP类型。
  - scheme：使用Bearer Token认证。
  - in：这个认证会放在请求头中。

```java
package edu.ljf.ch08_homework.common.config;

import io.swagger.v3.oas.annotations.OpenAPIDefinition;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeIn;
import io.swagger.v3.oas.annotations.enums.SecuritySchemeType;
import io.swagger.v3.oas.annotations.info.Info;
import io.swagger.v3.oas.annotations.info.License;
import io.swagger.v3.oas.annotations.security.SecurityRequirement;
import io.swagger.v3.oas.annotations.security.SecurityScheme;
import org.springframework.context.annotation.Configuration;

@Configuration
// 全局文档基本解释
@OpenAPIDefinition(
        // 文档基本信息
        info = @Info(
                // 文档标题
                title = "客户端——Web端接口文档",
                // 文档版本
                version = "1.0",
                // 文档描述
                description = "RSL商城的客户端Web端的API接口",
                // 开源协议信息
                license = @License(name = "开源协议名", url = "http://www.baidu.com")
        ),
        // 文档遵循的开源协议
        security = @SecurityRequirement(name = "开源协议名")
)
// 定义具体安全认证方案
@SecurityScheme(
        // 开源协议名
        name = "开源协议名",
        // HTTP类型
        type = SecuritySchemeType.HTTP,
        // 使用Bearer Token认证
        scheme = "Bearer",
        // 这个认证会放在请求头中
        in = SecuritySchemeIn.HEADER
)
public class OpenApiConfig {
}
```

#### 响应对象

REST API说了响应要做成JSON嘛。

那就把所有响应，不管正常的，异常的，不管有没有携带数据，全部统一一下。

```java
package edu.ljf.ch08_homework.common;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@NoArgsConstructor
@AllArgsConstructor
public class ResultVO<T> {
    private Integer code;
    private String message;
    private T data;

    public static <T> ResultVO<T> success(T data) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(200);
        resultVO.setData(data);
        return resultVO;
    }

    public static <T> ResultVO<T> success() {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(200);
        return resultVO;
    }

    public static <T> ResultVO<T> error(int code, String message) {
        ResultVO<T> resultVO = new ResultVO<>();
        resultVO.setCode(code);
        resultVO.setMessage(message);
        return resultVO;
    }
}
```

#### 实体对象

随便整个对象举例。

这里也有OPEN API的注解。

- @Schema：补充描述信息。
  - name：描述对象名。
  - description：描述对象解释。
  - example：描述对象示例。

```java
package edu.ljf.ch08_homework.entity;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.math.BigDecimal;

@Data
@NoArgsConstructor
@AllArgsConstructor
// 补充描述信息
@Schema(
        name = "商品对象",
        description = "商品自身的所有信息"
)
public class Cargo {
    @Schema(
            // 描述对象名
            name = "cargoId",
            // 描述对象解释
            description = "商品ID",
            // 描述对象示例
            example = "1"
    )
    private Integer cargoId;

    @Schema(
            name = "cargoName",
            description = "商品名",
            example = "可乐"
    )
    private String cargoName;

    @Schema(
            name = "price",
            description = "商品单价",
            example = "100.00"
    )
    private BigDecimal price;
}
```

#### Controller

懒得还接数据源。

dao层，service层，mapper映射啥的全部不管先。

反正这一节就是学REST API和OPEN API。

接口规范嘛，写个接口就行。

这里又有OPEN API的注解（这玩意注解真多）。

- @Tag：这个组的组解释。
  - name：组名。
  - description：组解释。
- @Operation：接口方法说明。
  - summary：接口名。
  - description：接口描述。
  - method：接口接受的请求方法。
- @ApiResponses：接口可能的多种响应情况。
- @ApiResponse：一个响应的详情。
  - responseCode：响应码。
  - description：响应解释。
- @Parameters：接口的接受参数。
- @Parameter：一个参数的详情。
  - name：参数名。
  - description：参数描述。
  - required：是否为必须。
  - in：参数所在位置。

```java
package edu.ljf.ch08_homework.web;

import edu.ljf.ch08_homework.common.ResultVO;
import edu.ljf.ch08_homework.entity.Cargo;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.Parameters;
import io.swagger.v3.oas.annotations.enums.ParameterIn;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.List;

@RestController
// 访问前缀，一级访问缀
@RequestMapping("/v1")
// 这个组的组解释
@Tag(
        // 组名
        name = "商品服务接口",
        // 组解释
        description = "提供商品相关操作的API"
)
public class CargoController {
    // 请求方式标注和二级访问缀
    @GetMapping("/cargoes")
    // 接口方法说明
    @Operation(
            // 接口名
            summary = "查询所有商品",
            // 接口描述
            description = "获取所有商品的所有信息",
            // 接口接受的请求方法
            method = "GET"
    )
    // 接口可能的多种响应情况
    @ApiResponses({
            // 一个响应的详情
            @ApiResponse(
                    // 响应码
                    responseCode = "200",
                    // 响应解释
                    description = "正常响应，并返回预期数据"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "异常响应，没有返回预期数据，服务端出现问题"
            ),
    })
    public ResultVO<List<Cargo>> listCargoes() {
        List<Cargo> cargoes = new ArrayList<>();
        return ResultVO.success(cargoes);
    }

    @GetMapping("/cargoes/{id}")
    @Operation(
            summary = "查询指定商品",
            description = "按指定ID查询匹配的商品的所有信息",
            method = "GET"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "正常响应，并返回预期数据"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "异常响应，没有返回预期数据，服务端出现问题"
            ),
    })
    // 接口的接受参数
    @Parameters({
            // 一个参数的详情
            @Parameter(
                    // 参数名
                    name = "id",
                    // 参数描述
                    description = "商品ID",
                    // 是否为必须
                    required = true,
                    // 参数所在位置（这里是参数存在于URL中）
                    in = ParameterIn.PATH
            )
    })
    public ResultVO<Cargo> getCargo(@PathVariable(name = "id") int id) {
        Cargo cargo = new Cargo();
        return ResultVO.success(cargo);
    }

    @PostMapping("/cargoes")
    @Operation(
            summary = "添加一件商品",
            description = "添加一件商品并填充商品信息",
            method = "POST"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "正常响应，并返回预期数据"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "异常响应，没有返回预期数据，服务端出现问题"
            ),
    })
    public ResultVO<String> addCargo(@RequestBody Cargo cargo) {
        return ResultVO.success();
    }

    @DeleteMapping("/cargoes/{id}")
    @Operation(
            summary = "删除一件商品",
            description = "根据ID删除一件匹配的商品",
            method = "DELETE"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "正常响应，并返回预期数据"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "异常响应，没有返回预期数据，服务端出现问题"
            ),
    })
    @Parameters({
            @Parameter(
                    name = "id",
                    description = "商品ID",
                    required = true,
                    in = ParameterIn.PATH
            )
    })
    public ResultVO<String> delCargo(@PathVariable(name = "id") int id) {
        return ResultVO.success();
    }

    @PutMapping("/cargoes/{id}")
    @Operation(
            summary = "修改一件商品",
            description = "根据ID修改一件商品的任意或所有信息",
            method = "PUT"
    )
    @ApiResponses({
            @ApiResponse(
                    responseCode = "200",
                    description = "正常响应，并返回预期数据"
            ),
            @ApiResponse(
                    responseCode = "500",
                    description = "异常响应，没有返回预期数据，服务端出现问题"
            ),
    })
    @Parameters({
            @Parameter(
                    name = "id",
                    description = "商品ID",
                    required = true,
                    in = ParameterIn.PATH
            )
    })
    public ResultVO<String> updCargo(@RequestBody Cargo cargo, @PathVariable(name = "id") int id) {
        return ResultVO.success();
    }
}
```

