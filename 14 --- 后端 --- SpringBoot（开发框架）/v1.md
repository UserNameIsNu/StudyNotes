[TOC]

# SpringBoot

# 1，简介

## 1.这是啥

Spring Boot 是 Spring 框架的一个子项目，它的核心设计目标是简化。

它旨在让开发者以最少的配置和最短的时间，快速创建并运行一个基于 Spring 的、生产级别的独立应用程序。

- SB可以极大的简化（极大简化，不是不用）配置，一般引用后SB会自动打上相关的依赖，版本也会调好。
- SB还内置了一些容器，不用自己配置容器，编译，打包再部署。

# 2，动手

## 1.创建一个SB项目

IDE一般似乎都是有创建SB的预设的。

我用的IDEA也是有的，跟着引导走就行。

没啥好说的：）

先啥都不用引入，纯净SB项目即可，先别管导入乱七八糟的玩意。

## 2.认识这个SB项目

似乎一个没有导入任何其它依赖的SB项目就有下面四个文件的样子。

### meven配置

我删了点没啥用的，不影响。

这里就留了非常之重要的配置。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <!--
        这里是SB的父级依赖
        提供了默认的Java版本，UTF-8的编码设置，插件管理与各种依赖库的版本号管理等功能
        且受益于父级依赖包含的版本号管理功能，这里引入其它库依赖时基本都不需要定义版本号了
      -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.5.5</version> <!--  要更换SB版本，直接改这里的版本号就行  -->
        <relativePath/> <!-- lookup parent from repository -->
    </parent>

    <!--  项目坐标  -->
    <groupId>edu.nf</groupId>
    <artifactId>ch01</artifactId>
    <version>0.0.1-SNAPSHOT</version>

    <!--  项目名与项目描述  -->
    <name>ch01</name>
    <description>ch01</description>

    <!--  删了也无妨  -->
    <properties>
        <java.version>21</java.version>
    </properties>

    <dependencies>
        <!--
            SB核心依赖
          -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
        </dependency>

        <!--  SB单元测试依赖  -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <!--  用于把SB应用打成jar或war  -->
    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
        </plugins>
    </build>
</project>
```

### SB核心配置文件

SB的核心配置文件。

如果需要改变SB的默认自动配置就在这里改。

不用再去xml里折腾了，修改一些默认值就行了。

同时还支持另外一种格式文件，就是application.yml（缩进式的配置方式）。

```properties
# 当前的SB应用叫什么名字（创建完项目默认就这一行）
spring.application.name=ch01
```

### SB核心启动类

SB应用的核心启动类。

SB应用就是直接通过main方法启动，不用像之前的SSM要挂在容器里面跑。

SB的默认扫描路径从当前启动类所在的包开始扫描，包含所有子包。

或者也能通过scanBasePackages属性修改扫描路径（不建议的说）。

其中关于复合注解中包含的EnableAutoConfiguration注解。

这玩意就是通过导入一个选择器将所有自动配置类加载到Spring容器中，实现自动装配。

所以后续想把其它三方包集成到SB中基本就是通过其中的选择器来集成了。

```java
package edu.nf.ch01;

import edu.nf.ch01.service.UserService;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;

/**
* SpringBootApplication注解是一个复合注解
* 包含Configuration，ComponentScan，EnableAutoConfiguration等注解
* 所以这个启动类同时也算是一个配置类，还具备扫描与自动启用配置的功能
*/
@SpringBootApplication
public class Ch01Application {
    /**
    * 运行SB应用（初始化SB）
    * 运行后会返回一个初始化好的容器
    * 这个返回的容器会根据当前的部署环境而改变
    * 如没集成Web环境时就会返回一个普通IOC
    * 如集成了Web环境时就会返回一个WebApplicationContext
    */
    public static void main(String[] args) {
        ApplicationContext context = SpringApplication.run(Ch01Application.class, args);
        // 这个UserService就是随便建的一个空类
        UserService service = context.getBean(UserService.class);
        System.out.println(service);
    }
}
```

### SB测试类

单元测试的集成环境，且受容器管理。

所以可以在这些类里面注入需要测试的Bean。

```java
package edu.nf.ch01;

import edu.nf.ch01.service.UserService;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class Ch01ApplicationTests {
    private UserService userService;

    // 注入UserService
    public Ch01ApplicationTests(UserService userService) {
        this.userService = userService;
    }

    @Test
    void contextLoads() {
        // 测试userService
    }
}
```

## 3.yml配置类型

创建SB项目后，resource下一般都会有一个SB自己的配置文件叫application.propertise。

不过有一个更推荐的（看起来舒服多了的）格式就是yml（也叫yaml）。

SB会默认读取application.properties或application.yml这两个文件的，找到谁用谁（都有读谁就不知道了）。

读取的内容一般就会绑定到具体的java对象里面，用来干点解析配置啥的活儿。

yml叫什么缩进式配置。

下面的用于定义SB项目的名字的yml格式的配置，等同于propertise下的`spring.application.name=ch02`。

```yaml
# yml配置使用 : 加换行（点空格，不能用tab）进行分割
# 值不需要换行，但也要加一个空格
spring:
    application:
        name: ch02
```

### 值绑定

这是yml最基础的配置绑定格式。

配置文件嘛，里面的东西总是要拿出来绑进程序里面用的嘛。

值绑定就是yml最简单的绑定写法了。

```yaml
student:
	userId: 1
	userName: tom
	age: 22
```

再假设有个对象Student。

```java
package com.example.ch02.entity;

import lombok.Data;
import org.springframework.beans.factory.annotation.Value;

@Data
@Component
public class Student {
    // 使用@Value注解绑定单一层级值
	@Value("${student.userId}")
    private Integer userId;

	@Value("${student.userName}")
    private String userName;

	@Value("${student.age}")
    private Integer userAge;
}
```

### 松散绑定

这个就是厉害多的写法。

基本啥都能绑定。

不像值绑定，绑个单一层级的值就没了。

别说数组集合啥的，对象都绑不了。

在yml中可以使用驼峰模式（userName）或中短杠（user-name）又或全大写加下划线（USER_NAME）命名。

```yaml
student:
    user-id: 1
    userName: tom
    age: 22
    # 对象
    card:
        cardNum: 12345
    # 数组（两种写法）
    # phones: 123, 456, 789
    phones:
        - 123
        - 456
        - 789
    # map集合
    score:
        A: 1
        B: 2
        C: 3
    # 对象集合
    teachers:
        - name: T1
          age: 40
        - name: T2
          age: 50
```

再做对象。

```java
package com.example.ch02.entity;

import lombok.Data;
import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;

import java.util.List;
import java.util.Map;

@Data
@Component
@ConfigurationProperties(prefix="student")
public class Student {
    private Integer userId;

    private String userName;

    private Integer userAge;

    // 这是个自建对象
    private Card card;

    private String[] phones;

    private Map<String, Integer> score;

    // 这里面的Teacher也是个自建对象
    private List<Teacher> teachers;
}
```

### 多环境配置

需要遵循application-xxx的命名规定。

用来区别如测试环境，开发环境，生产环境等不同情况下的程序运行配置。

切换不同配置组只需要在主配置类里加一句就行。

```yaml
spring:
    # 激活配置（要激活哪一份配置文件就改成对应文件名短杠后的名字）
    profiles:
    	# 如这是application主配置类
    	# 还有application-test和application-dev两个不同环境的配置组
    	# 就用test和dev就可以切换配置组了
        active: dev
```

就用测试模式下让控制台输出的日志显示颜色举例。

主配置类切到test就会让测试模式下的控制台日志输出保持颜色。

切到dev就会让测试模式下的控制台输出取消颜色。

```yaml
# application-test
spring:
    output:
        ansi:
            enabled: always
```

```yaml
# application-dev
spring:
    output:
        ansi:
            enabled: never
```

### 多模块配置

也需要遵循application-xxx的命名规定。

一般就是如dao层整一个application-dao.yml，web层整一个application-web.yml之类的。

除了一堆模块自己的独立配置类，在要有一个SB项目的主配置类。

主配置类啥都别配，只用来导其它配置类。

要导哪个文件，就把那个文件名短杠后的名字加进来，和上面多环境配置的写法相同。

```yaml
spring:
    profiles:
        include: web, dao
```

主要就是多环境配置模式下的主配置类还是可以写配置的。

多模块配置模式下的主配置类就不要写任何配置了，除了这一句导入配置的就啥也别加。

## 4.配置数据源

现在基本了解了SB项目的结构，与SB项目的配置方式。

接下来折腾一下数据源。

连上数据源后基本就能用这套玩意开始做些项目了（环境和数据库有了基本就能动了）。

### JDBC依赖

首先就是打上JDBC的依赖。

这玩意当然又是SB做好的集成包。

包含JDBCTemplate（Spring对JDBC做的封装）还自带Hikari连接池。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>
```

### 配置数据源配置

当然还是写在application.yml里面（后续需要多环境或多模块配置再说，这里就是个案例，塞一起了）。

```yaml
spring:
    datasource:
    	# 老四样
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        # SB自带的连接池（Hikari）
        hikari:
            # 最小空闲连接数
            minimum-idle: 5
            # 最大连接数
            maximum-pool-size: 200
            # 极限空闲时长（超出后将大于最小空闲连接数量的连接关掉）
            idle-timeout: 90000
            # 超时时长（超出后还没从池子里拿到连接就报错）
            connection-timeout: 5000
            # 检查连接是否有效
            connection-test-query: select 1
```

### 测试连接

```java
package com.example.ch03;

import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.jdbc.core.JdbcTemplate;

import javax.sql.DataSource;
import java.sql.SQLException;
import java.util.List;
import java.util.Map;

@SpringBootTest
@Slf4j
class Ch03ApplicationTests {
    // 数据源
    @Autowired
    private DataSource dataSource;

    // JDBC模板
    @Autowired
    private JdbcTemplate jdbcTemplate;

    // 尝试获取连接
    @Test
    void testHikari() throws SQLException {
        log.info(dataSource.toString());
        log.info("connection: {}", dataSource.getConnection());
    }

    // 尝试执行查询语句
    @Test
    void testTemplate() {
        List<Map<String, Object>> list = jdbcTemplate.queryForList("select * from city_info");
        for (Map<String, Object> map : list) {
            log.info(map.toString());
        }
    }

}
```

### 切换数据源

比如不想用SB内置的hikari连接池，想换个如druid。

那么去meven导一下依赖。

然后改一下application.yml就行。

基本就是把druid的配置加上，多给一句指向新的连接类型的type就可以了。

```yaml
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://localhost:3307/java211?useSSL=false&useUnicode=true&characterEncoding=utf-8&serverTimezone=Asia/Shanghai
        username: root
        password: root
        # 指定连接类型
        type: com.alibaba.druid.pool.DruidDataSource
        # druid连接池
        druid:
            # 最大连接数
            max-active: 200
            # 最小空闲连接数
            min-idle: 5
            # 初始化连接数
            initial-size: 5
            # 极限空闲时长1
            max-wait: 5000
            # 检查连接是否有效
            validation-query: select 1
            # 是否缓存PreparedStatement
            pool-prepared-statements: false
```

