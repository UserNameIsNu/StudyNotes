[TOC]

# MinIO

# 1，简介

## 1.这是啥

似乎挺厉害的高性能分布式开源存储系统。

自己想搞个对象存储就能用这玩意搭建。

不用花钱用别人家的（除非别人家的更香嘛）。

## 2.安装

先去官网[MinIO下载和安装 | 用于创建高性能对象存储的代码和下载内容](https://minio.org.cn/download.shtml#/windows)拿安装包。

然后跑命令安装（minio.exe放到自己想放的地方再执行命令安装）。

```cmd
Invoke-WebRequest -Uri "https://dl.minio.org.cn/server/minio/release/windows-amd64/minio.exe" -OutFile "D:\minIO\minio.exe"
```

然后设置用户名和密码。

```cmd
setx MINIO_ROOT_USER admin
```

```cmd
setx MINIO_ROOT_PASSWORD admin12345
```

最后指定仓库文件并启动服务。

前一段路径是minio程序位置，后一段路径是仓库文件位置（这俩建议摆一起，且端口9001尽量别改）。

```cmd
D:\minIO\minio.exe server D:\minIO\Data --console-address ":9001"
```

完了应该会蹦出来运行地址的，一般就是`xxx.xxx.xxx.xxx:9001`。

直接在浏览器访问这里，默认账号密码都是`minioadmin`。

理应就可以进入系统管理面板了。

# 2，整合至Spring

其它大多数第三方包或框架也能用下面的方式（思想）整合进Spring框架。

不进行整合的话，这些第三方包或框架因为不是Spring Bean对象，所以无法实现注入。

当然也无法让IOC管理它们。

所以一般就是把第三方的API打成对象，再用FactoryBean创建这个对象的对象工厂。

这样就能实现让Spring的IOC收容这个第三方包或框架。

整合就是为了让Spring的IOC一并管理这些第三方包或框架中某些东西的生命周期与依赖。

如果不建立工厂，直接把外来者各自标记打包为Bean对象，那你也是想累死自己。

## 1.Maven配置

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>org.example</groupId>
    <artifactId>minio_demo</artifactId>
    <version>1.0-SNAPSHOT</version>
    <packaging>pom</packaging>
    <modules>
        <module>demo</module>
    </modules>

    <properties>
        <maven.compiler.source>21</maven.compiler.source>
        <maven.compiler.target>21</maven.compiler.target>
        <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    </properties>

    <dependencies>
        <!--  Servlet API  -->
        <dependency>
            <groupId>jakarta.servlet</groupId>
            <artifactId>jakarta.servlet-api</artifactId>
            <version>6.1.0</version>
            <scope>provided</scope>
        </dependency>

        <!--  Spring MVC  -->
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webmvc</artifactId>
            <version>6.2.7</version>
        </dependency>

        <!--  JSON 序列化  -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
            <version>2.19.0</version>
        </dependency>

        <!--  MinIO（对象存储）支持  -->
        <dependency>
            <groupId>io.minio</groupId>
            <artifactId>minio</artifactId>
            <version>8.4.3</version>
        </dependency>
    </dependencies>
</project>
```

## 2.封装MinIO的API

```java
package edu.nf.demo.common;

import io.minio.BucketExistsArgs;
import io.minio.MakeBucketArgs;
import io.minio.MinioClient;
import io.minio.PutObjectArgs;

import java.io.InputStream;

// MinIO的API对象
public class MinioOptions {
    // 客户端对象
    private MinioClient client;
    // 桶名称
    private String bucket;

    // 构造器
    public MinioOptions(MinioClient client, String bucket) {
        this.client = client;
        this.bucket = bucket;
        // 初始化桶
        initBucket();
    }

    // 初始化桶
    private void initBucket() {
        try {
            // 若桶不存在就创建一个桶
            if(!client.bucketExists(BucketExistsArgs.builder() // 创建一个专门用于检查桶是否存在的对象
                    .bucket(bucket) // 桶名
                    .build())){ // 执行
                client.makeBucket(MakeBucketArgs.builder() // 创建一个桶创建参数构造器对象
                        .bucket(bucket) // 桶名
                        .build()); // 执行
            }
        } catch (Exception e) {
            throw new RuntimeException("Create bucket fail.", e);
        }
    }

    /**
     * 上传文件
     * @param path 文件在桶中的路径
     * @param contentType 文件类型（MIME类型）
     * @param size 文件大小（字节）
     * @param input 文件输入流
     */
    public void upload(String path,
                       String contentType,
                       long size,
                       InputStream input) {
        try {
            // 上传文件至桶
            client.putObject(PutObjectArgs.builder() // 创建一个上传对象参数构造器
                    .bucket(bucket) // 桶名
                    .object(path) // 文件在桶中的路径
                    .contentType(contentType) // MIME文件类型
                    .stream(input, size, -1) // 文件输入流，文件大小，定义MinIO自动选择上传策略
                    .build()); // 执行
        } catch (Exception e) {
            throw new RuntimeException("Upload fail.", e);
        }
    }
}
```

## 3.封装MinIO工厂

```java
package edu.nf.demo.common;

import io.minio.MinioClient;
import org.springframework.beans.factory.FactoryBean;

// 创建MinIO的API对象与初始化桶
// 直接使用Spring的FactoryBean，传入Minio的API对象，表示这个MinIO工厂产出的所有MinIO的API对象均被IOC收容
public class MinioFactoryBean implements FactoryBean<MinioOptions> {
    /**
     * 文件服务器连接url
     */
    private String host;
    /**
     * 账号
     */
    private String account;
    /**
     * 密码
     */
    private String password;
    /**
     * 桶名称
     */
    private String bucketName;

    // 设置方法
    public void setHost(String host) {
        this.host = host;
    }
    public void setAccount(String account) {
        this.account = account;
    }
    public void setPassword(String password) {
        this.password = password;
    }
    public void setBucketName(String bucketName) {
        this.bucketName = bucketName;
    }

    // 获取Class对象
    @Override
    public Class<?> getObjectType() {
        return MinioOptions.class;
    }

    /**
     * 初始化MinIO的API对象并纳入IOC容器管理
     * @return
     * @throws Exception
     */
    @Override
    public MinioOptions getObject() throws Exception {
        //创建MinIO的API对象
        MinioClient client = MinioClient.builder() // 创建一个MinIO的API对象的构造器对象
                .endpoint(host) // MinIO服务的访问地址
                .credentials(account, password) // MinIO的服务的访问账号与密码
                .build(); // 执行
        //将client封装到MinioOptions中
        return new MinioOptions(client, bucketName);
    }

}
```

## 4.封装MinIO配置

```java
package edu.nf.demo.config;

import edu.nf.demo.common.MinioFactoryBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

// 配置类
@Configuration
// MinIO配置类
public class MinioConfig {

    /**
     * 装配MinIO工厂
     * @return
     */
    @Bean
    public MinioFactoryBean minioFactoryBean() {
        MinioFactoryBean factoryBean = new MinioFactoryBean(); // 声明工厂
        factoryBean.setHost("http://127.0.0.1:9000"); // 定义服务地址
        factoryBean.setAccount("minioadmin"); // 定义登录账号
        factoryBean.setPassword("minioadmin"); // 定义登录密码
        factoryBean.setBucketName("myapp"); // 定义目标桶名
        return factoryBean; // MinIO工厂对象
    }
}
```

## 5.封装视图解析器

```java
package edu.nf.demo.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;
import org.springframework.web.servlet.config.annotation.EnableWebMvc;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

// 配置类
@Configuration
// 启用MVC注解驱动
@EnableWebMvc
// 视图解析器
public class MvcConfig implements WebMvcConfigurer {
    /**
     * 启用默认servlet静态资源处理
     * @param configurer
     */
    @Override
    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {
        configurer.enable();
    }
}
```

## 6.封装跟配置类

```java
package edu.nf.demo.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Import;

// 配置类
@Configuration
// 扫包
@ComponentScan(basePackages = "edu.nf.demo")
// 集中其它配置
@Import({MvcConfig.class, MinioConfig.class})
// 根配置类
public class RootConfig {
}
```

## 7.封装入口配置类

```java
package edu.nf.demo.config;

import jakarta.servlet.MultipartConfigElement;
import jakarta.servlet.ServletRegistration;
import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;

// 入口配置类
public class WebConfig extends AbstractAnnotationConfigDispatcherServletInitializer {
    // 根配置加载器
    @Override
    protected Class<?>[] getRootConfigClasses() {
        return new Class[0];
    }

    // Web容器加载器
    @Override
    protected Class<?>[] getServletConfigClasses() {
        return new Class[]{RootConfig.class};
    }

    /**
     * 动态注册自定义的Servlet配置
     * 这里为：启用DispatcherServlet上传功能
     * @param registration
     */
    @Override
    protected void customizeRegistration(ServletRegistration.Dynamic registration) {
        // 创建上传配置对象
        // 参数一：上传的根目录
        // 参数二：限制单个文件上传的大小（单位：字节）
        // 参数三：限制本次请求中所有文件的总大小
        // 参数四：当达到指定大小时，将写入文件
        MultipartConfigElement configElement = new MultipartConfigElement(
                "",
                20971520,
                2097152000,
                2097152);
        // 注册上传配置
        registration.setMultipartConfig(configElement);
        // 容器启动时跟着初始化这个配置
        registration.setLoadOnStartup(0);
    }

    // 请求拦截规则（全部来让Spring看看！）
    @Override
    protected String[] getServletMappings() {
        return new String[]{"/"};
    }
}
```

## 8.封装统一视图响应对象（VO）

```java
package edu.nf.demo.vo;

// 统一响应视图对象
public class ResultVO<T> {
    /**
     * 响应码
     */
    private Integer code;
    /**
     * 响应的消息
     */
    private String message;
    /**
     * 响应的数据
     */
    private T data;

    public Integer getCode() {
        return code;
    }

    public void setCode(Integer code) {
        this.code = code;
    }

    public String getMessage() {
        return message;
    }

    public void setMessage(String message) {
        this.message = message;
    }

    public T getData() {
        return data;
    }

    public void setData(T data) {
        this.data = data;
    }
}
```

## 9.封装基础控制器

```java
package edu.nf.demo.controller;

import edu.nf.demo.vo.ResultVO;
import org.springframework.http.HttpStatus;

// 基础控制器
public class BaseController {
    /**
     * 响应成功（有数据）
     * @param data
     * @return
     * @param <T>
     */
    protected  <T> ResultVO<T> success(T data) {
        ResultVO<T> vo = new ResultVO<>(); // 创建响应对象
        vo.setCode(HttpStatus.OK.value()); // 设置响应码
        vo.setData(data); // 设置响应数据
        return vo;
    }

    /**
     * 响应成功（无数据）
     * @return
     * @param <T>
     */
    protected <T> ResultVO<T> success() {
        ResultVO<T> vo = new ResultVO<>(); // 创建响应对象
        vo.setCode(HttpStatus.OK.value()); // 设置响应码
        return vo;
    }
}
```

## 10.封装MinIO控制器

```java
package edu.nf.demo.controller;


import edu.nf.demo.common.MinioOptions;
import edu.nf.demo.vo.ResultVO;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.web.multipart.MultipartFile;

import java.io.InputStream;

// 控制器
@RestController
public class UploadController extends BaseController {
    // MinIO的API对象
    private MinioOptions options;

    // 构造器，初始化MinIO的API对象
    public UploadController(MinioOptions options) {
        this.options = options;
    }

    /**
     * 上传
     * @param path 文件路径（绑定URL中的{path}至方法参数path）
     * @param files 文件组
     * @return
     * @throws Exception
     */
    @PostMapping("/upload/{path}")
    public ResultVO upload(@PathVariable("path") String path,
                            @RequestParam("file") MultipartFile[] files) throws Exception{
        for(MultipartFile file : files) {
            //获取文件名
            String fileName = file.getOriginalFilename();
            //获取文件输入流
            InputStream input = file.getInputStream();
            //获取文件类型
            String contentType = file.getContentType();
            //获取文件大小
            long size = file.getSize();
            //上传文件到minio文件服务器
            options.upload(
                    path + "/" + fileName,
                    contentType,
                    size,
                    input);
        }
        return success();
    }
}
```

## 11.上传

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <script src="js/jquery-1.12.4.min.js"></script>
</head>
<body>
<h2>文件上传</h2>
<form id="f1" enctype="multipart/form-data">
    文件：<input type="file" name="file" multiple/>
    <input type="button" value="上传"/>
</form>
<script>
    $(function(){
        $(':button').on('click', function(){
             //构建formData封装表单数据
             let formData = new FormData($('#f1')[0]);
             //使用ajax提交
             $.ajax({
                 url: '/upload/test',
                 type: 'post',
                 data: formData,
                 processData: false,
                 contentType: false,
                 success: function(result) {
                    if(result.code == 200) {
                        alert("上传成功");
                    } else {
                       alert("上传失败");
                    }
                 }
             });
        })
    })
</script>
</body>
</html>
```

