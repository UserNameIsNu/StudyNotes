[TOC]

# MySQL

# 1，简介与概念

## 1.这是啥

​	一种关系型数据库（还有个非关系型，这里不讲（也不会））。

​	轻量（小），可以多开，用的人多。

​	免费（社区版免费，企业版收费），开源，跨平台。

## 2.使用一种奇怪的语言

​	这玩意使用 SQL（结构化查询语言） 操作。

​	这玩意又细分成四种：

​	DDL，数据定义语言。

​	DML，数据操作语言。

​	DQL，数据检索语言。

​	DCL，数据控制语言。

## 3.设计过程

​	七步：

​	收集信息。

​	标识对象。

​	标识对象的属性。

​	标识对象间关系。

​	绘制ER图。

​	使用范式规范数据。

​	创建表。

## 4.范式

​	用于规范化数据，减少数据冗余，避免操作异常。

​	主要有三种：

​	第一范式，保证表中每列都不可再细分（原子性）。

​	第二范式，保证表中每列都与主键相关（一张表只描述一件事）。

​	第三范式，保证表中每列都与主键直接相关。

## 5.安装

​	有向导安装和解压（命令行）安装。

​	向导安装基本就是一路下一步，不说了。

​	解压安装详情见同目录下 `伞兵MySQL命令行安装与卸载.md`。

​	安装完只要服务是启动的，理应就可以直接用。

​	比如 navicat 之类的图形界面。

# 2，基础操作

## 1.创建和删除库（create，database，drop，show）

​	MySQL 安装完之后，还要创建库和表。

​	安装相当于划了土地，还要建立仓库（建库），然后还要在仓库里放货架（建表）。

​	第一个是，若没有这个库，创建一个库，并设置默认字符集。

​	第二个是，若有这个库，删除。

```sql
create database [if not exists] databaseName [default character set = 'UTF8'];
```

```sql
drop database [if exists] databaseName;
```

​	可以检查一下有没有创建成功或删除成功（就看看在不在）。

```sql
show databases;
```

## 2.存储引擎

​	数据库插件，决定了数据库是否可以拥有更强的性能或更多样的功能。

| 名字      | 描述                                                         |
| --------- | ------------------------------------------------------------ |
| ARCHIVE   | 用于数据存档的引擎，数据被插入后就不能在修改了，且不支持索引。 |
| CSV       | 在存储数据时，会以逗号作为数据项之间的分隔符。               |
| BLACKHOLE | 会丢弃写操作，该操作会返回空内容。                           |
| FEDERATED | 将数据存储在远程数据库中，用来访问远程表的存储引擎。         |
| InnoDB    | 具备外键支持功能的事务处理引擎                               |
| MEMORY    | 置于内存的表                                                 |
| MERGE     | 用来管理由多个 MyISAM 表构成的表集合                         |
| MyISAM    | 主要的非事务处理存储引擎                                     |
| NDB       | MySQL 集群专用存储引擎                                       |

​	MySQL 新版的似乎默认使用 InnoDB。

## 3.创建，删除和查看表（use，table，desc）

​	建表前记得先引用创建的库。

​	建表时，其中的列名如果有多行，用英文逗号换行，最后一行不加。

```sql
use databaseName;
```

```sql
create table [if not exists] tableName (
	字段名称1 数据类型[(长度)] [约束] [comment '描述'],
	...
	字段名称n 数据类型[(长度)] [约束] [comment '描述']
)[engine=engineName charset='编码方式'];
```

​	还有删除表。

```sql
drop table [if exists] tableName;
```

​	也是可以检查一下创建成功没有或删除成功没有，会一并显示表结构。

```sql
desc tableName;
```

## 4.认识并在建表时添加约束

​	就是在建表时给字段添加各种约束条件（不建议用）。

​	常见的有：

​	主键约束（PRIMARY KEY），用于标记唯一标识数据。

​	自增约束（AUTO_INCREMENT），用于添加行时数据类型自动增长。

​	非空约束（not nul），用于防止空值。

​	唯一约束（unique），用于确保唯一。

​	默认约束（default），用于无值时填充默认值。

​	检查约束（check），用于判断内容符合条件。

```sql
create table if not exists testtable(
  id int PRIMARY KEY AUTO_INCREMENT,
  name varchar(50) not null unique default '无',
  age int check(age>0)
)engine=InnoDB charset='UTF8';
```

​	还有一个特殊一点的常见约束，外键约束。

​	用于连接两张表，绑定关系。

```sql
create table otherTable(
  id int primary key,
  outsideId int,
  constraint testKey foreign key(outsideId) references testtable(id)
);
```

# 3，补救措施

## 1.修改表名

​	表名毁了，重新改一个。

```sql
rename table 表名 to 新表名;
```

## 2.添加，删除和修改字段

​	字段少了，加一个。

​	写错了，改一下（字段名好像改不了）。

​	不要了，删掉。

​	免得重建表。

```sql
alter table 表名 add 字段名 数据类型[(长度)] [约束] [comment '描述']  [first | after 字段名];

alter table 表名 modify 字段名 数据类型[(长度)] [约束] [comment '描述'] [first | after 字段名]

alter table 表名 drop 字段名;
```

# 4，增删改操作

## 1.添加数据

​	需要向表里添加数据行。

​	可以一行一行加，也能一堆一堆加。

​	不指定字段的话，后面的值需要把每个字段都给上。

​	指定字段的话只需要给指定了的字段添加值（当然要满足约束的前提下）。

```sql
insert into 表名[(字段1, ...,字段n)] values(值1, ...,值n);

insert into 表名[(字段1, ...,字段n)] values
(值1, ...,值n),
...
(值1, ...,值n);
```

## 2.删除数据

​	需要删除表里的某行（也能清空表）。

​	给了条件就是选择性删除数据行，不给条件就清空表。

```sql
delete from 表名 [where 条件];
```

## 3.修改数据

​	需要修改表里的数据行（一次性修改所有满足条件的）。

​	同样不给条件的话整张表都会被修改。

```sql
update 表名 set 字段1 = '值1', ..., 字段n = '值n' [where 条件];
```

# 5，基本查询

## 1.基本查询模板

​	需要查询表中的数据时。

​	查询不要求只能查一张表，也可以好几张表并在一起查。

​	下面是一个重量级查询模板。

```sql
select [distinct(去重)] [聚合函数] 字段集合|常量|表达式|函数|*
from  表名
[where 查询条件语句集合]
[group by 分组字段列表]
[having 过滤条件语句集合]
[order by 排序字段集合 [asc | desc]]
[LIMIT [<offset(跳过前几行)>,] <row count(显示前几行)>]
```

​	下面举例一些常见的基本查询。

​	查询单表全部字段。

```sql
select * from 表名;
```

​	查询指定字段。

```sql
select 字段名1, ..., 字段n from 表名;
```

​	查询前x条数据。

```sql
select * from 表名 limit 从第几行开始 显示前几行;
```

​	查询指定条件的数据。

```sql
select 字段集合 | * from 表名 where 条件;
```

​	查询是否为组内某个数据。

```sql
select 字段名 from 表名 where 字段名 in (值1, ..., 值n);
```

## 2.查询时使用别名

​	出现多表查询时，为了区分不同的表，可以使用别名标识不同的表。

​	也可以在需要给结果字段重命名时使用。

```sql
select * from 表名 as 别名;

select 字段 as 别名 from 表名;
```

## 3.查询结果排序

​	比如我想按照成绩高低排名，出现这种需要按照某条件排序结果时使用。

```sql
select * from 表名 order by 字段 ASC | DESC
```

## 4.聚合函数分组与处理

​	聚合函数一般就是统计时用的多（个人来说）。

​	常见的有：

​	sum()，求和。

​	avg()，求平均值。

​	max()，求最大值。

​	min()，求最小值。

​	count()，求总数。

```sql
select sum | avg | max | min | count(字段名) as 别名 from 表名;
```

## 5.去重和分组查询

​	当结果出现重复数据，且不想要这些重复数据时，可以使用去重查询。

​	去重只会判断字段组中所有数据的重复情况。

​	如只判断性别列，可以筛选出有哪些性别。

​	但如果加上学号列，应为学号是唯一的，所以去重是匹配不到重复项的。

```sql
select distinct 性别 from 学生信息; 
```

​	而当需要给结果分组显示时，就用分组查询。

​	且查询的字段只能是被分组的字段或聚合函数。

​	且 `where` 在分组前只用，而 `having` 在分组后使用。

​	一般是先执行分组，后在结果内查询。

```sql
select 性别, count(*) from 学生信息 [where 民族 = '汉族'] group by 性别 [having 性别 = '男'];
```

## 6.模糊查询

​	需要匹配数据中的某段时使用。

​	一般查询的最小单位是格嘛，格匹配即可。

​	模糊查询会将最小单位继续降为字符，可以实现字符级匹配。

​	`%` 指包含后续所有任意字符，`_` 指包含后续 `_` 数量的字符。

​	下面第一行就是匹配姓名第一个字是李的。

​	第二个就是匹配姓李且后面只跟一个字的，就是两个字名字且姓李的。

```sql
select * from 学生信息 where 姓名 like '李%';
select * from 学生信息 where 姓名 like '李_';
```

## 7.分页查询

​	就是限定从第几行到第几行的数据。

​	下面就是不跳过行，显示5行，那就是显示1-5行。

​	第二个就是跳过前5行，显示5行，那就是显示6-10行。

```sql
select * from 学生信息 limit 0, 5;
select * from 学生信息 limit 5, 5;
```

## 8.结果条件判断

​	比如表中用0，1代表男女，直接显示不太好看。

​	这个就可以判断结果值，选择输出代值。

```sql
select
(
  case 性别 
    when 0 then '男' 
    when 1 then '女'
    else '未知'
  end
) 字段名 
from 表名;
```

## 9.行数据转为列数据

​	如我需要查询某个学生每门课的成绩。

​	但是成绩表是一张表，无法单独把某个学生的所有课的分数提出来。

​	要把：

| 学号 | 姓名 | 课程 | 分数 |
| ---- | ---- | ---- | ---- |
| 1    | a    | 01   | 90   |
| 1    | a    | 02   | 87   |

​	变成：

| 学号 | 01课程分数 | 02课程分数 |
| ---- | ---------- | ---------- |
| 1    | 90         | 87         |

​	所以要用行转列了。

​	逻辑上就像，判断某个玩意是否满足某条件，满足就如何，否则就如何，最后标记逻辑结束。

```sql
select 
	学号, 
	max(case when 课程 = 01 then 分数 else 0 end) as '01课程分数',
	max(case when 课程 = 02 then 分数 else 0 end) as '02课程分数'
from 表名 where 学号 = 1;
```

# 6，多表复合查询

## 1.等值与内连接查询

​	等值查询会把相关表的全部字段累乘，结果为所有表的数据行的搭配组合。

​	如表A有10行数据，表B有10行数据，结果就会出现100行数据。

​	若还有一个表C有2行数据，结果就是200行数据。

```sql
select * from 表名1, ..., 表名n;
```

​	而内连接查询在效果上都是一样的，只是在语法上不同。

​	后面的 `on` 需要将连接的表的相同字段（一般就是主外键）联系起来。

​	这个 `on` 似乎在内连接时，若连接了没有主外键关系的表，不加也能正常执行。

​	而其它类型的连接似乎就都要加了。

```sql
select * from 表名1 [inner] join 表名2 [on 表1列名 = 表2列名]
```

## 2.自连接

​	也算是内连接的写法，只是主表和副表都是同一张。

```sql
select * from 表名1 [inner] join 表名2 [on 表1列名 = 表2列名]
```

## 3.左外连接和右外连接

​	也是多表连接的方法。

​	选了哪个表（主表），那个表的数据就会完整显示，而另一个（副表）只显示匹配行。

​	左外连接和右外连接的区别也就只是前者为主表还是后者为主表。

```sql
select * from 表1 left join 表2 on 表1列名 = 表2列名
select * from 表1 right join 表2 on 表1列名 = 表2列名
```

## 4.联合查询

​	就是把多个查询的结果合并。

​	`all` 参数代表是否去重。

​	使用这玩意时，字段数量需要相同。

​	而字段类型至少要兼容，最好也相同。

```sql
select * from 表1 union [all] select * from 表2;
```

# 7，子查询

## 1.快速解释

​	就是嵌在别的语句中的查询语句，大多和查询语句并用。

​	一般放在小括号内，且优先于主语句执行。

## 2.使用子查询

​	一般有三种用法。

​	第一就是检查结果是否存在，或不存在于子查询结果中。

​	第二就是检查结果比较子查询结果是否至少一个或全部，搭配比较运算符使用。

​	第三就是检查子查询是否存在结果返回 `true` 或 `false`，若为假，则主查询不执行。

```sql
select * from 表名 where 字段 [NOT] IN (子查询|数值集合);
select * from 表名 where 字段 比较运算符 [any | some | all] (子查询);
select * from 表名 where [NOT] EXISTS (子查询);
```

​	除去这三种用法，在 `from`，`where`，`insert`，`update`，`delete` 或 `having` 中也会用到（不常用，也不算少用）。

# 8，索引

## 1.干嘛的

​	用于大量数据时快速检出结果。

​	不需要直接使用，在查询表时，只要查询建立了索引的字段时就会自动触发。

## 2.创建索引

​	一般只给主键和常用字段建立索引。

​	三个可选项为唯一索引，全文索引和空间索引（一般倒是不加，直接创建就行了）。

```sql
create [unique | fulllext | spatial] index 索引名 on 表名 (字段名1, ..., 字段名n);
```

## 3.检查索引

​	看看某张表有没有索引存在，并看看索引信息。

```sql
show index from 表名;
```

## 4.删除索引

​	指定删除某张表的某个索引。

```sql
drop index 索引名 on 表名;
```

# 9，视图

## 1.干嘛的

​	基于语句创建的虚拟表。

​	可以隔离无关数据，提高安全性，也能算是复杂语句的 ’ 封装 ‘ 。

​	也是没有啥特殊的使用方法，视图就是相当于虚拟表嘛，所以怎么查表就怎么查视图。

​	但是视图不建议执行增删改操作，牵连有点多，危险。

## 2.创建视图

​	视图的创建是需要基于查询语句的结果的。

```sql
create view 视图名 as select from 表名 [条件];
```

## 3.修改视图

​	视图不满足需求时，修改视图的来源语句就好。

```sql
alter view 视图名 as select from 表名 [条件];
```

## 4.删除视图

​	不用了就删掉。

```sql
drop view 视图名;
```

# 10，性能分析

## 1.检查执行频次

​	主要就是看这个库的各种操作的次数。

​	若查询数远大于增删改数，那多少有点问题了。

```sql
SHOW GLOBAL STATUS LIKE 'Com_______';
```

## 2.慢查询日志

​	查看查询花了好久时间的次数记录下来。

```sql
show variables like 'slow_query_log'; // 检查慢查询日志是否开启
show variables like '%query%'; // 检查慢查询日志参数
```

## 3.profile

​	查询执行语句时，那些步骤花费了那些时间。

```sql
select @@have_profiling; // 检查数据库引擎是否支持
select @@profiling; // 检查是否开启
SET profiling = 1 // 开启（0关闭）
show profiles; // 检查开启后的所有执行的语句的时间消耗
show profile for query 2; // 按照展示的列表中指定ID的操作的每个步骤（阶段）的耗时
```

## 4.explain

​	计划执行。

​	代表即将准备执行这个语句，查看 MySQL 是怎么执行语句的（包括执行参数）。

​	语句不会真的执行。

```sql
explain 语句;
explain select * from tableName;
