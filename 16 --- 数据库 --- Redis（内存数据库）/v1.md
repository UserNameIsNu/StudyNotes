[TOC]

# Redis

# 1，简介

## 1.这是啥

基于内存的数据结构服务器。

小，快，手伸的很广。

## 2.安装

先去整个Docker。

Docker装好之后去命令行跑两行命令。

```
docker pull redis/redis-stack-server:latest
```

```
docker run --name redis-stack-server -p 6379:6379 redis/redis-stack-server:latest
```

理应就会在Docker里面创建一个Redis镜像，并启动它。

后续启动就不用敲命令，在Docket的UI里面就能直接启动了。

然后再去整个Another Redis Desktop Manager。

就当成图形化的数据库管理工具。

这玩意没官网，去GitHub上下。

最后在Docker中启动扒拉下来的Redis镜像。

然后去这个图形化里面创建新连接。

所有配置都不用动，直接创建。

理应就会出来一个`IP@默认端口`名字的实例。

Redis命令啥的也是在这里敲。

# 2，基本数据类型

- String：字符串。
- List：列表类型（有序，可重复）。
- Set：集合类型（无序，不可重复）。
- Zset：集合类型（有序，值对应分数用于排序）。
- hash：键值对。
- Stream：消息流。

## 1.String

### 设置

```
set key value
```

新建或修改一个键值对。

set固定，key设置键名，value设置值。

```
setnx key value
```

新建一个键值对，若键存在则不对其做修改。

setnx固定，key设置键名，value设置值。

### 获取

```
get key
```

获取一个键值对的值。

get固定，key设置要获取值的目标键名。

### 删除

```
del key
```

删除一个键值对。

del固定，key设置要删除的目标键名。

### 验证存在

```
exists key
```

检查某个键值对是否存在。

exists固定，key设置要检查的目标键名。

### 查看所有

```
keys *
```

检查所有存在的键值对（仅显示键名）。

keys固定，后面跟通配符。

### 删除所有

```
flushall
```

删除所有存在的键值对。

flushall固定。

### 过期检查

```
ttl key
```

检查某个键值对是否过期（过期值为null，没有设置为-1）。

ttl固定，key设置要检查的目标键名。

### 过期设置

```
expire key time
```

设置某个键值对多久过期。

expire固定，key设置要设置过期时间的键名，time设置多久后过期（时间为秒）。

```
setex key time value
```

在创建时设置键值对的过期时间。

setex固定，key设置键名，time设置过期时间，value设置值。

## 2.List

### 前追加

```
lpush key value
```

在列表前追加值，没有列表则创建后添加。

lpush固定，key键名，value值。

### 后追加

```
rpush key value
```

在列表后追加值，没有列表则创建后添加。

rpush固定，key键名，value值。

### 检查区间

```
lrange key start end
```

检查列表中指定区间的值。

lrange固定，key键名，start起始下标，end结束下标（-1表示末尾）。

### 首位删除

```
lpop key [how many]
```

从首位开始删除列表值，不加参数删除一个。

lpop固定，key键名，how many设置从头开始删除几个。

### 末位删除

```
rpop key [how many]
```

从末位开始删除列表值，不加参数删除一个。

rpop固定，key键名，how many设置从尾开始删除几个。

### 检查长度

```
llen key
```

检查列表长度。

llen固定，key键名。

### 剪裁

```
ltrim key start end
```

删除区间外的值，仅保留区间内的值。

ltrim固定，key键名，start起始下标，end结束下标。

## 3.Set

### 设置

```
sadd key value
```

添加值至指定集合，若没有集合则创建再添加。

sadd固定，key键名，value值。

### 检查内容

```
smembers key
```

查看集合内所有值。

smembers固定，key键名。

### 是否存在

```
sismember key value
```

检查集合中是否存在某个值。

sismember固定，key键名，value值。

### 删除元素

```
srem key value
```

删除集合中的指定元素。

srem固定，key键名，value值。

## 4.Zset

### 设置

```
zadd setName score member
```

添加值至指定集合，若没有集合则创建再添加。

zadd固定，setName集合名，score分数，member值。

### 获取值

```
zrange setName 0 -1
```

获取指定集合的所有值。

zrange固定，setName集合名，0从头开始，-1直到末尾。

### 合并分数获取值

```
zrange setName 0 -1 withscores
```

获取指定集合的所有分数与值。

zrange固定，setName集合名，0从头开始，-1直到末尾，withscores固定。

### 获取分数

```
zscore setName memberName
```

获取指定集合中指定值的分数。

zscore固定，setName集合名，memberName成员名。

### 获取排名（小到大）

```
zrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName成员名。

### 获取排名（大到小）

```
zrevrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName成员名。

### 获取排行榜（小到大）

```
zrangebyscore setName 0 100
```

获取指定集合中所有成员的排名，按照分数从小到大排序。

zrangebyscore固定，setName集合名，0起始分数，100结束分数。

### 加分

```
zincrby setName num memberName
```

为指定集合的指定成员加分。

zincrby固定，setName集合名，num增长的分数，memberName成员名。

### 获取集合长度

```
zcard setName
```

获取指定集合的长度（成员数量）。

zcard固定，setName集合名。

### 获取区间内分数的成员数量

```
zcount setName min max
```

获取指定集合内分数于定义区间内的成员数量。

zcount固定，setName集合名，min起始数，max最大数。

### 删除区间内成员（排名后）

```
ZREMRANGEBYRANK setName min max
```

删除指定集合内分数于定义区间内的成员（分数大到小排序，就是会从小的开始删）。

zremrangebyrank固定，setName集合名，min起始数，max最大数。

### 删除区间内成员

```
zremrangebyscore setName min max
```

删除指定集合内分数于定义区间内的成员。

zremrangebyscore固定，setName集合名，min起始数，max最大数。

## 5.Hash

### 设置对

```
hset hashName key value
```

添加一个键值对至哈希组内。

hset固定，hahsName哈希组名，key键名，value值。

### 获取对

```
hget hashName key
```

根据键获取对应值。

hget固定，hashName哈希组名，key键名。

### 获取所有对

```
hgetall hashName
```

获取指定哈希组内所有键值对。

hgetall固定，hashName哈希组名。

### 删除对

```
hdel hashName key
```

删除指定哈希组内指定键的对。

hdel固定，hashName哈希组名，key键名。

### 对是否存在

```
hexists hashName key
```

检查指定哈希组内的指定对是否存在。

hexists固定。hashName哈希组名，key键名。

### 获取键组

```
hkeys hashName
```

获取指定哈希组的键组。

hkeys固定，hashName哈希组名。

### 获取哈希组长度

```
hlen hashName
```

获取指定哈希组的长度（对数量）。

hlen固定，hashName哈希组名。

## 6.Stream

### 添加至流

```
xadd streamName * key value
```

添加新的对至指定流。

xadd固定，streamName流名，*自动补充ID，key键名，value值。

### 获取流长度

```
xlen streamName
```

获取指定流的长度（对数量）。

xlen固定，streamName流名。

### 获取流所有对

```
xrange streamName - +
```

获取指定流的所有对。

xrange固定，streamName流名，-从最小ID开始，+从最大ID结束。

### 删除对

```
xdel streamName ID
```

删除指定流中的指定ID的对。

xdel固定，streamName流名，ID对ID。

### 裁剪流

```
xtrim streamName maxlen 0
```

裁剪指定流的对。

xtrim固定，streamName流名，maxlen最多保留几条消息（从最旧的开始删），0保留0条。

### 定位读取流

```
xread count num streams streamName ID
```

读取指定流中指定ID以后的指定数量的对。

xread固定，count数量标记，num读几个，streams固定，streamName流名，ID对ID。

### 阻塞读取流

```
xread block 0 streams streamName $
```

读取从执行起，指定流从指定位置产生的所有新消息（可以设置等待新消息的忍耐时间）。

xread固定，block定义阻塞，0无限等待（或毫秒），streams固定，streamName流名，$从最新消息开始。

# 3，消息代理

这玩意没有说一定要拿来做数据库。

拿这玩意当作消息转发管理器用也可以。

比如拿它做个订阅模式啥的也是没问题的。

性能还非常高。

## 1.订阅与发布

### 订阅

```
subscribe groupName
```

订阅指定组。

subscribe固定，groupName组名。

### 发布

```
publish groupName "message"
```

发布消息至指定组。

publish固定，groupName组名，massage消息内容。

## 2.流推拉

使用流（Stream）进行消息代理时，比起上面的方法，可以额外实现历史记录的数据持久化。

### 推

没有专门的推送命令或方法。

这玩意不就是操作Stream嘛，直接往Stream里面加东西就算是推送了。

### 拉

如果需要拉取指定区间的历史记录就用上面的剪裁流。

如果就是要和订阅模式一样的监听获取就用阻塞读取流。

## 3.消费者组

上面两个都是广播形式，消费者组相当于团队内发布认领。

消费者组就是一个团队，往里面甩一条消息就是发布了一个任务。

所有在这个消费者组里的消费者就是成员。

成员会认领这个任务。

且一个任务只会被一个成员认领。

跟名字一样嘛，一个东西卖掉了，一个东西只能被一个人买走。

### 创建组	

```
xgroup create streamName groupName 0/$
```

创建一个消费者组于指定流上。

xgroup固定，create固定，streamName流名，groupName组名，0从头消费所有消息，$消费新消息。

### 检查组

```
xinfo groups streamName
```

检查指定流上的消费者组信息。

xinfo固定，groups固定，streamName流名。

### 消费（创建消费者）

```
xreadgroup group groupName consumer count 1 block 0 streams streamName >
```

消费指定流中的指定组中的指定数量的消息，可设置阻塞等待最新消息（流中没有被读过的就算新消息）。

xreadgroup固定，group固定，groupName组名，consumer消费者名，count消费数量标记，1仅消费一条，block阻塞标记，0持续阻塞等待新消息（或毫秒），streams固定，streamName流名，>只消费没被消费过的消息。

### 检查消费者

```
xinfo consumers streamName groupName
```

检查指定流中指定消费者组中的消费者信息。

xinfo固定，consumers固定，streamName流名，groupName组名。

### 检查消费但未确认消息

```
xpending streamName groupName - + 10
```

检查指定流中指定消费者组中所有消费者消费但未确认的消息。

xpending固定，streamName流名，groupName组名，-从头开始，+直到末尾，10最多展示10条。

### 标记消息已处理

```
xack streamName groupName ID
```

标记指定流中指定组中某条被确认的消息已被处理。

xack固定，streamName流名，groupName组名，ID消息ID。

### 移交未处理消息

```
xclaim streamName groupName consumerName 0 ID
```

移交指定流中指定组中指定ID的未处理的信息给指定消费者。

xclaim固定，streamNAme流名，groupName组名，consumerName消费者名，0马上移交，ID消息ID。

### 删除消费者

```
xgroup delconsumer streamName groupName consumerName
```

删除指定流中指定消费者组中指定消费者。

xgroup固定，delconsumer固定，streamName流名，groupName组名，consumerName消费者名。

### 删除消费者组

```
xgroup destroy streamName groupName
```

删除指定流中指定消费者组。

xgroup固定，destroy固定，streamName流名，groupName组名。

# 4，衍生数据类型

## 1.地理空间（Geospatial）

换皮的Zset。

专门用来处理地理位置信息。

### 创建位置

```
geoadd objName E/W N/S value
```

创建一个基于经纬度的位置信息。

geoadd固定，objName对象名，E/W经度，N/S纬度，value值。

### 查询位置

```
geopos objName value
```

根据对象与值查询它的位置信息。

geopos固定，objName对象名，value值。

### 距离计算

```
geodist objName valueA valueB KM
```

计算指定对象中两个值的距离。

geodist固定，objName对象名，valueA第一个值，valueB第二个值，KM距离单位。

### 扩散查询

```
geosearch objName frommember value byradius num KM
```

查询某个对象内以某个位置（已有的值或经纬度）为原点，扩散指定距离内是否存在值（包括自己）。

geosearch固定，objName对象名，frommember固定，value值，byradius固定，num距离，KM距离单位。

## 2.去重计数器（HyperLogLog）

用来做基数统计的。

跟名字一样，就是计算去重后的数量。

只能计数，看不到放进去啥玩意的。

### 塞数

```
pfadd groupName value1 value2 value3...
```

向指定计数组塞值。

pfadd固定，groupName组名，value值。

### 基数统计

```
pfcount groupName
```

计算指定组内的基数。

pfcount固定，groupName组名。

### 合并组

```
pfmerge groupName1 groupName2
```

合并两个计数组，后者值会并入前者，后者本身不会变动。

pfmerge固定，groupName组名。

# 5，事务

## 1.是个啥

redis这个缓存玩意理应没有事务这个概念。

只是在redis的主进程外新开一条，单独处理规划好的命令组。

和传统事务支持批量顺序且允许回滚相比，这玩意就少个回滚。

命令组某条命令炸掉，已经跑了的不会撤回，没跑的会继续跑跑试试。

## 2.命令

### 批量头

```
multi
```

标记批量处理的命令组的开始。

后续写的命令都会存入预备的命令组，等待执行或放弃的命令。

multi固定。

### 执行

```
exec
```

顺序执行命令组中所有命令（先进先跑）。

exec固定。

### 放弃

```
discard
```

放弃命令组的执行，组内命令清空。

discard固定。

# 6，持久化

## 1.是个啥

就是字面意思，让这个缓存做真正数据库的本职工作。

虽然感觉一般用处不算太大。

除了做恢复快照之外感觉就没啥用了。

## 2.持久化模式

### RDB

用来记录数据快照。

似乎是默认开启。

把快照写进dump.rdb二进制文件。

新快照会覆盖旧的。

在redis.conf中找到Save the DB on disk就是RDB模式的配置。

如save 900 10就是指900秒内有10次写操作则产生快照。

可以组合多个条件。

#### 手动快照

```
save
```

这玩意可以手动创建当前快照。

自动快照是独立进程，主进程还是能正常跑命令干活。

手动快照挂在主进程中，会卡着不让干别的事，直到做完快照。

#### 优劣

适合自动数据备份。

但是会牺牲数据完整性，且缺乏即时性。

### AOF

用来记录执行的命令快照。

默认关闭，在redis.conf中将appendonly no设置为appendonly yes。

#### 策略

有三种。

- always：每次写均保存。
- everysec：每秒保存。
- no：不保存。

#### 优劣

保证数据完整性。

但会拖性能，且备份快照挺大的。

### 混合

未启用时RDB存数据，AOF存命令。

在redis.conf中将appendonly no设置为appendonly yes。

再将aof-use-rdb-preamble 设置为yes就能启动混合模式。

混合模式下会把数据和命令存进一个RDB-AOF混合文件。

一般是先塞RDB格式的快照，再补上快照后执行的AOF格式的命令记录。

说是可以加快恢复速度，减小体积。

# 7，SB集成

## 1.依赖

一个就行。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

## 2.配置

```yaml
spring:
    data:
        redis:
            # 选择数据库（0-15）
            database: 0
            # 主机地址
            host: 127.0.0.1
            # 端口号
            port: 6379
            # 密码（如果有设置）
            # password: 123456
            # 命令超时时间
            timeout: 2000
            # 连接超时时间
            connect-timeout: 2000
```

## 3.RedisTemplate API

这就是在Java中写Redis的大头了。

这个私人API装了一大堆私人方法。

几乎就是有多少命令就有多少方法。

这里仅举例最最最最常用的（应该），没有的自己查。

抄下来都嫌累。

### StringRedisTemplate API

这玩意是RedisTemplate的子类。

key和value都定义为String类型。

方便后续操作。

记得先启动Redis服务（我是用Docker镜像的Redis）。

且在使用后面所有的命令前，都要先把这玩意实例出来先。

```java
// 这是在SB的单元测试里面实例的
private StringRedisTemplate stringRedisTemplate;

@Autowired
public Ch11ApplicationTests(StringRedisTemplate stringRedisTemplate) {
    this.stringRedisTemplate = stringRedisTemplate;
}
```

#### String

##### 设置

```java
stringRedisTemplate.opsForValue().set("StringName", "value");
```

创建新的String并赋键值。

##### 获取

```java
String val = stringRedisTemplate.opsForValue().get("StringName");
```

获取指定键的String的值。

##### 定时过期

```java
stringRedisTemplate.opsForValue().set("StringName", "value", 30, TimeUnit.SECONDS);
```

创建新的String并赋键值，且定义过期（生存）时间，过期即销毁。

#### List

##### 前入列

```java
stringRedisTemplate.opsForList().leftPush("ListName", "value");
```

从集合的开头插入新数据。

##### 后入列

```java
stringRedisTemplate.opsForList().rightPush("ListName", "value");
```

从集合的末尾插入新数据。

##### 获取区间

```java
List<String> range = stringRedisTemplate.opsForList().range("ListName", 0, -1);
```

获取指定区间的值（包括start和end）。

#### Set

##### 添加

```java
stringRedisTemplate.opsForSet().add("setName", "value", "value");
```

添加值至指定集合。

##### 获取值

```java
Double score = stringRedisTemplate.opsForZSet().score("setName", member);
```

获取指定集合中指定值的分数。

##### 获取全部

```java
Set<String> members = stringRedisTemplate.opsForSet().members("setName");
```

获取指定集合的全部元素。

##### 删除值

```java
stringRedisTemplate.opsForSet().remove("setName", "value");
```

删除指定集合的指定元素。

##### 增减分数

```java
Double goodsZSet = stringRedisTemplate.opsForZSet().incrementScore("setName", member, -1);
```

增加或减少指定集合中指定值的分数（允许正负数）。

##### 值是否存在

```java
Boolean exists = stringRedisTemplate.opsForSet().isMember("setName", "value");
```

检查指定值是否存在于指定集合中。

#### Zset

##### 添加

```java
stringRedisTemplate.opsForZSet().add("zsetName", "member", sroce);
```

向指定集合中添加值与分数。

##### 获取分数

```java
Double score = stringRedisTemplate.opsForZSet().score("zsetName", "member");
```

根据指定值获取对应分数。

##### 获取值排名

```java
Long rank = stringRedisTemplate.opsForZSet().rank("zsetName", "member");
```

根据指定值获取它的排名。

##### 获取区间

```java
Set<String> range = stringRedisTemplate.opsForZSet().range("zsetName", 0, -1);
```

获取指定集合的指定区间的值。

#### Hash

##### 添加

```java
stringRedisTemplate.opsForHash().put("hashName", "key", "value");
```

添加对至指定哈希。

##### 获取某个

```java
String name = (String) stringRedisTemplate.opsForHash().get("hashName", "key");
```

根据键获取值。

##### 获取全部

```java
Map<Object,Object> map = stringRedisTemplate.opsForHash().entries("hashName");
```

获取指定哈希的全部对。

##### 是否存在

```java
boolean exists = stringRedisTemplate.opsForHash().hasKey("hashName", key);
```

判断指定键是否存在指定哈希中。

## 4.MQ/lua/redis组合

接下来整个削峰，原子执行的。

用于如秒杀或抢票情况的抗压结构。
