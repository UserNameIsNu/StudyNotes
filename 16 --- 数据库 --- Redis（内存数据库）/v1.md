[TOC]

# Redis

# 1，简介

## 1.这是啥

内存数据库。

小，快。

除了做数据持久化，也能做缓存和消息代理。

## 2.安装

先去整个Docker。

Docker装好之后去命令行跑两行命令。

```
docker pull redis/redis-stack-server:latest
```

```
docker run --name redis-stack-server -p 6379:6379 redis/redis-stack-server:latest
```

理应就会在Docker里面创建一个Redis镜像，并启动它。

后续启动就不用敲命令，在Docket的UI里面就能直接启动了。

然后再去整个Another Redis Desktop Manager。

就当成图形化的数据库管理工具。

这玩意没官网，去GitHub上下。

最后在Docker中启动扒拉下来的Redis镜像。

然后去这个图形化里面创建新连接。

所有配置都不用动，直接创建。

理应就会出来一个`IP@默认端口`名字的实例。

Redis命令啥的也是在这里敲。

# 2，数据类型

- String：字符串。
- List：列表类型（有序，可重复）。
- Set：集合类型（无序，不可重复）。
- Zset：集合类型（有序，对应分数）。
- hash：键值对。
- Stream：消息流。

## 1.String

### 设置

```
set key value
```

新建或修改一个键值对。

set固定，key设置键名，value设置值。

```
setnx key value
```

新建一个键值对，若键存在则不对其做修改。

setnx固定，key设置键名，value设置值。

### 获取

```
get key
```

获取一个键值对的值。

get固定，key设置要获取值的目标键名。

### 删除

```
del key
```

删除一个键值对。

del固定，key设置要删除的目标键名。

### 验证存在

```
exists key
```

检查某个键值对是否存在。

exists固定，key设置要检查的目标键名。

### 查看所有

```
keys *
```

检查所有存在的键值对（仅显示键名）。

keys固定，后面跟通配符。

### 删除所有

```
flushall
```

删除所有存在的键值对。

flushall固定。

### 过期检查

```
ttl key
```

检查某个键值对是否过期（过期值为null，没有设置为-1）。

ttl固定，key设置要检查的目标键名。

### 过期设置

```
expire key time
```

设置某个键值对多久过期。

expire固定，key设置要设置过期时间的键名，time设置多久后过期（时间为秒）。

```
setex key time value
```

在创建时设置键值对的过期时间。

setex固定，key设置键名，time设置过期时间，value设置值。

## 2.List

### 前追加

```
lpush key value
```

在列表前追加值，没有列表则创建后添加。

lpush固定，key键名，value值。

### 后追加

```
rpush key value
```

在列表后追加值，没有列表则创建后添加。

rpush固定，key键名，value值。

### 检查区间

```
lrange key start end
```

检查列表中指定区间的值。

lrange固定，key键名，start起始下标，end结束下标（-1表示末尾）。

### 首位删除

```
lpop key [how many]
```

从首位开始删除列表值，不加参数删除一个。

lpop固定，key键名，how many设置从头开始删除几个。

### 末位删除

```
rpop key [how many]
```

从末位开始删除列表值，不加参数删除一个。

rpop固定，key键名，how many设置从尾开始删除几个。

### 检查长度

```
llen key
```

检查列表长度。

llen固定，key键名。

### 剪裁

```
ltrim key start end
```

删除区间外的值，仅保留区间内的值。

ltrim固定，key键名，start起始下标，end结束下标。

## 3.Set

### 设置

```
sadd key value
```

添加值至指定集合，若没有集合则创建再添加。

sadd固定，key键名，value值。

### 检查内容

```
smenbers key
```

查看集合内所有值。

smembers固定，key键名。

### 是否存在

```
sismember key value
```

检查集合中是否存在某个值。

sismember固定，key键名，value值。

### 删除元素

```
srem key value
```

删除集合中的指定元素。

srem固定，key键名，value值。

## 4.Zset

### 设置

```
zadd setName score member
```

添加值至指定集合，若没有集合则创建再添加。

zadd固定，setName集合名，score分数，member值。

### 获取值

```
zrange setName 0 -1
```

获取指定集合的所有值。

zrange固定，setName集合名，0从头开始，-1直到末尾。

### 合并分数获取值

```
zrange setName 0 -1 withscores
```

获取指定集合的所有分数与值。

zrange固定，setName集合名，0从头开始，-1直到末尾，withscores固定。

### 获取分数

```
zscore setName memberName
```

获取指定集合中指定值的分数。

zscore固定，setName集合名，memberName值。

### 获取排名（小到大）

```
zrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName值。

### 获取排名（大到小）

```
zrevrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName值。

















## 5.Hash

### 设置对

```
hset hashName key value
```

添加一个键值对至哈希组内。

hset固定，hahsName哈希组名，key键名，value值。

### 获取对

```
hget hashName key
```

根据键获取对应值。

hget固定，hashName哈希组名，key键名。

### 获取所有对

```
hgetall hashName
```

获取指定哈希组内所有键值对。

hgetall固定，hashName哈希组名。

### 删除对

```
hdel hashName key
```

删除指定哈希组内指定键的对。

hdel固定，hashName哈希组名，key键名。

### 对是否存在

```
hexists hashName key
```

检查指定哈希组内的指定对是否存在。

hexists固定。hashName哈希组名，key键名。

### 获取键组

```
hkeys hashName
```

获取指定哈希组的键组。

hkeys固定，hashName哈希组名。

### 获取哈希组长度

```
hlen hashName
```

获取指定哈希组的长度（对数量）。

hlen固定，hashName哈希组名。

## 6.Stream

### 添加至流

```
xadd streamName * key value
```

添加新的对至指定流。

xadd固定，streamName流名，*自动补充ID，key键名，value值。

### 获取流长度

```
xlen streamName
```

获取指定流的长度（对数量）。

xlen固定，streamName流名。

### 获取流所有对

```
xrange streamName - +
```

获取指定流的所有对。

xrange固定，streamName流名，-从最小ID开始，+从最大ID结束。

### 删除对

```
xdel streamName ID
```

删除指定流中的指定ID的对。

xdel固定，streamName流名，ID对ID。

### 裁剪流

```
xtrim streamName maxlen 0
```

裁剪指定流的对。

xtrim固定，streamName流名，maxlen最多保留几条消息（从最旧的开始删），0保留0条。

### 定位读取流

```
xread count num streams streamName ID
```

读取指定流中指定ID以后的指定数量的对。

xread固定，count数量标记，num读几个，streams固定，streamName流名，ID对ID。

### 阻塞读取流

```
xread block 0 streams streamName $
```

读取从执行起，指定流从指定位置产生的所有新消息（可以设置等待新消息的忍耐时间）。

xread固定，block定义阻塞，0无限等待（或毫秒），streams固定，streamName流名，$从最新消息开始。

# 3，消息代理

这玩意没有说一定要拿来做数据库。

拿这玩意当作消息转发管理器用也可以。

比如拿它做个订阅模式啥的也是没问题的。

性能还非常高。

## 1.订阅与发布

### 订阅

```
subscribe groupName
```

订阅指定组。

subscribe固定，groupName组名。

### 发布

```
publish groupName "message"
```

发布消息至指定组。

publish固定，groupName组名，massage消息内容。

## 2.流推拉

使用流（Stream）进行消息代理时，比起上面的方法，可以额外实现历史记录的数据持久化。

### 推

没有专门的推送命令或方法。

这玩意不就是操作Stream嘛，直接往Stream里面加东西就算是推送了。

### 拉

如果需要拉取指定区间的历史记录就用上面的剪裁流。

如果就是要和订阅模式一样的监听获取就用阻塞读取流。

## 3.消费者组

上面两个都是广播形式，消费者组相当于团队内发布认领。

消费者组就是一个团队，往里面甩一条消息就是发布了一个任务。

所有在这个消费者组里的消费者就是成员。

成员会认领这个任务。

且一个任务只会被一个成员认领。

跟名字一样嘛，一个东西卖掉了，一个东西只能被一个人买走。

### 创建组	

```
xgroup create streamName groupName 0/$
```

创建一个消费者组于指定流上。

xgroup固定，create固定，streamName流名，groupName组名，0从头消费所有消息，$消费新消息。

### 检查组

```
xinfo groups streamName
```

检查指定流上的消费者组信息。

xinfo固定，groups固定，streamName流名。

### 消费（创建消费者）

```
xreadgroup group groupName consumer count 1 block 0 streams streamName >
```

消费指定流中的指定组中的指定数量的消息，可设置阻塞等待最新消息（流中没有被读过的就算新消息）。

xreadgroup固定，group固定，groupName组名，consumer消费者名，count消费数量标记，1仅消费一条，block阻塞标记，0持续阻塞等待新消息（或毫秒），streams固定，streamName流名，>只消费没被消费过的消息。

### 检查消费者

```
xinfo consumers streamName groupName
```

检查指定流中指定消费者组中的消费者信息。

xinfo固定，consumers固定，streamName流名，groupName组名。

### 检查消费但未确认消息

```
xpending stramName groupName - + 10
```

检查指定流中指定消费者组中所有消费者消费但未确认的消息。

xpending固定，streamName流名，groupName组名，-从头开始，+直到末尾，10最多展示10条。

### 标记消息已处理

```
xack stramName groupName ID
```

标记指定流中指定组中某条被确认的消息已被处理。

xack固定，streamName流名，groupName组名，ID消息ID。

### 移交未处理消息

```
xclaim streamName groupName consumerName 0 ID
```

移交指定流中指定组中指定ID的未处理的信息给指定消费者。

xclaim固定，streamNAme流名，groupName组名，consumerName消费者名，0马上移交，ID消息ID。

### 删除消费者

```
xgroup delconsumer streamName groupName consumerName
```

删除指定流中指定消费者组中指定消费者。

xgroup固定，delconsumer固定，streamName流名，groupName组名，consumerName消费者名。

### 删除消费者组

```
xgroup destroy streamName groupName
```

删除指定流中指定消费者组。

xgroup固定，destroy固定，streamName流名，groupName组名。
