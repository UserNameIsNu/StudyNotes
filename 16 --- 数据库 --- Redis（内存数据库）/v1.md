[TOC]

# Redis

# 1，简介

## 1.这是啥

基于内存的数据结构服务器。

小，快，手伸的很广。

## 2.安装

先去整个Docker。

Docker装好之后去命令行跑两行命令。

```
docker pull redis/redis-stack-server:latest
```

```
docker run --name redis-stack-server -p 6379:6379 redis/redis-stack-server:latest
```

理应就会在Docker里面创建一个Redis镜像，并启动它。

后续启动就不用敲命令，在Docket的UI里面就能直接启动了。

然后再去整个Another Redis Desktop Manager。

就当成图形化的数据库管理工具。

这玩意没官网，去GitHub上下。

最后在Docker中启动扒拉下来的Redis镜像。

然后去这个图形化里面创建新连接。

所有配置都不用动，直接创建。

理应就会出来一个`IP@默认端口`名字的实例。

Redis命令啥的也是在这里敲。

# 2，基本数据类型

- String：字符串。
- List：列表类型（有序，可重复）。
- Set：集合类型（无序，不可重复）。
- Zset：集合类型（有序，值对应分数用于排序）。
- hash：键值对。
- Stream：消息流。

## 1.String

### 设置

```
set key value
```

新建或修改一个键值对。

set固定，key设置键名，value设置值。

```
setnx key value
```

新建一个键值对，若键存在则不对其做修改。

setnx固定，key设置键名，value设置值。

### 获取

```
get key
```

获取一个键值对的值。

get固定，key设置要获取值的目标键名。

### 删除

```
del key
```

删除一个键值对。

del固定，key设置要删除的目标键名。

### 验证存在

```
exists key
```

检查某个键值对是否存在。

exists固定，key设置要检查的目标键名。

### 查看所有

```
keys *
```

检查所有存在的键值对（仅显示键名）。

keys固定，后面跟通配符。

### 删除所有

```
flushall
```

删除所有存在的键值对。

flushall固定。

### 过期检查

```
ttl key
```

检查某个键值对是否过期（过期值为null，没有设置为-1）。

ttl固定，key设置要检查的目标键名。

### 过期设置

```
expire key time
```

设置某个键值对多久过期。

expire固定，key设置要设置过期时间的键名，time设置多久后过期（时间为秒）。

```
setex key time value
```

在创建时设置键值对的过期时间。

setex固定，key设置键名，time设置过期时间，value设置值。

## 2.List

### 前追加

```
lpush key value
```

在列表前追加值，没有列表则创建后添加。

lpush固定，key键名，value值。

### 后追加

```
rpush key value
```

在列表后追加值，没有列表则创建后添加。

rpush固定，key键名，value值。

### 检查区间

```
lrange key start end
```

检查列表中指定区间的值。

lrange固定，key键名，start起始下标，end结束下标（-1表示末尾）。

### 首位删除

```
lpop key [how many]
```

从首位开始删除列表值，不加参数删除一个。

lpop固定，key键名，how many设置从头开始删除几个。

### 末位删除

```
rpop key [how many]
```

从末位开始删除列表值，不加参数删除一个。

rpop固定，key键名，how many设置从尾开始删除几个。

### 检查长度

```
llen key
```

检查列表长度。

llen固定，key键名。

### 剪裁

```
ltrim key start end
```

删除区间外的值，仅保留区间内的值。

ltrim固定，key键名，start起始下标，end结束下标。

## 3.Set

### 设置

```
sadd key value
```

添加值至指定集合，若没有集合则创建再添加。

sadd固定，key键名，value值。

### 检查内容

```
smembers key
```

查看集合内所有值。

smembers固定，key键名。

### 是否存在

```
sismember key value
```

检查集合中是否存在某个值。

sismember固定，key键名，value值。

### 删除元素

```
srem key value
```

删除集合中的指定元素。

srem固定，key键名，value值。

## 4.Zset

### 设置

```
zadd setName score member
```

添加值至指定集合，若没有集合则创建再添加。

zadd固定，setName集合名，score分数，member值。

### 获取值

```
zrange setName 0 -1
```

获取指定集合的所有值。

zrange固定，setName集合名，0从头开始，-1直到末尾。

### 合并分数获取值

```
zrange setName 0 -1 withscores
```

获取指定集合的所有分数与值。

zrange固定，setName集合名，0从头开始，-1直到末尾，withscores固定。

### 获取分数

```
zscore setName memberName
```

获取指定集合中指定值的分数。

zscore固定，setName集合名，memberName成员名。

### 获取排名（小到大）

```
zrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName成员名。

### 获取排名（大到小）

```
zrevrank setName memberName
```

获取指定集合中指定值的排名。

zrank固定，setName集合名，memberName成员名。

### 获取排行榜（小到大）

```
zrangebyscore setName 0 100
```

获取指定集合中所有成员的排名，按照分数从小到大排序。

zrangebyscore固定，setName集合名，0起始分数，100结束分数。

### 加分

```
zincrby setName num memberName
```

为指定集合的指定成员加分。

zincrby固定，setName集合名，num增长的分数，memberName成员名。

### 获取集合长度

```
zcard setName
```

获取指定集合的长度（成员数量）。

zcard固定，setName集合名。

### 获取区间内分数的成员数量

```
zcount setName min max
```

获取指定集合内分数于定义区间内的成员数量。

zcount固定，setName集合名，min起始数，max最大数。

### 删除区间内成员（排名后）

```
ZREMRANGEBYRANK setName min max
```

删除指定集合内分数于定义区间内的成员（分数大到小排序，就是会从小的开始删）。

zremrangebyrank固定，setName集合名，min起始数，max最大数。

### 删除区间内成员

```
zremrangebyscore setName min max
```

删除指定集合内分数于定义区间内的成员。

zremrangebyscore固定，setName集合名，min起始数，max最大数。

## 5.Hash

### 设置对

```
hset hashName key value
```

添加一个键值对至哈希组内。

hset固定，hahsName哈希组名，key键名，value值。

### 获取对

```
hget hashName key
```

根据键获取对应值。

hget固定，hashName哈希组名，key键名。

### 获取所有对

```
hgetall hashName
```

获取指定哈希组内所有键值对。

hgetall固定，hashName哈希组名。

### 删除对

```
hdel hashName key
```

删除指定哈希组内指定键的对。

hdel固定，hashName哈希组名，key键名。

### 对是否存在

```
hexists hashName key
```

检查指定哈希组内的指定对是否存在。

hexists固定。hashName哈希组名，key键名。

### 获取键组

```
hkeys hashName
```

获取指定哈希组的键组。

hkeys固定，hashName哈希组名。

### 获取哈希组长度

```
hlen hashName
```

获取指定哈希组的长度（对数量）。

hlen固定，hashName哈希组名。

## 6.Stream

### 添加至流

```
xadd streamName * key value
```

添加新的对至指定流。

xadd固定，streamName流名，*自动补充ID，key键名，value值。

### 获取流长度

```
xlen streamName
```

获取指定流的长度（对数量）。

xlen固定，streamName流名。

### 获取流所有对

```
xrange streamName - +
```

获取指定流的所有对。

xrange固定，streamName流名，-从最小ID开始，+从最大ID结束。

### 删除对

```
xdel streamName ID
```

删除指定流中的指定ID的对。

xdel固定，streamName流名，ID对ID。

### 裁剪流

```
xtrim streamName maxlen 0
```

裁剪指定流的对。

xtrim固定，streamName流名，maxlen最多保留几条消息（从最旧的开始删），0保留0条。

### 定位读取流

```
xread count num streams streamName ID
```

读取指定流中指定ID以后的指定数量的对。

xread固定，count数量标记，num读几个，streams固定，streamName流名，ID对ID。

### 阻塞读取流

```
xread block 0 streams streamName $
```

读取从执行起，指定流从指定位置产生的所有新消息（可以设置等待新消息的忍耐时间）。

xread固定，block定义阻塞，0无限等待（或毫秒），streams固定，streamName流名，$从最新消息开始。

# 3，消息代理

这玩意没有说一定要拿来做数据库。

拿这玩意当作消息转发管理器用也可以。

比如拿它做个订阅模式啥的也是没问题的。

性能还非常高。

## 1.订阅与发布

### 订阅

```
subscribe groupName
```

订阅指定组。

subscribe固定，groupName组名。

### 发布

```
publish groupName "message"
```

发布消息至指定组。

publish固定，groupName组名，massage消息内容。

## 2.流推拉

使用流（Stream）进行消息代理时，比起上面的方法，可以额外实现历史记录的数据持久化。

### 推

没有专门的推送命令或方法。

这玩意不就是操作Stream嘛，直接往Stream里面加东西就算是推送了。

### 拉

如果需要拉取指定区间的历史记录就用上面的剪裁流。

如果就是要和订阅模式一样的监听获取就用阻塞读取流。

## 3.消费者组

上面两个都是广播形式，消费者组相当于团队内发布认领。

消费者组就是一个团队，往里面甩一条消息就是发布了一个任务。

所有在这个消费者组里的消费者就是成员。

成员会认领这个任务。

且一个任务只会被一个成员认领。

跟名字一样嘛，一个东西卖掉了，一个东西只能被一个人买走。

### 创建组	

```
xgroup create streamName groupName 0/$
```

创建一个消费者组于指定流上。

xgroup固定，create固定，streamName流名，groupName组名，0从头消费所有消息，$消费新消息。

### 检查组

```
xinfo groups streamName
```

检查指定流上的消费者组信息。

xinfo固定，groups固定，streamName流名。

### 消费（创建消费者）

```
xreadgroup group groupName consumer count 1 block 0 streams streamName >
```

消费指定流中的指定组中的指定数量的消息，可设置阻塞等待最新消息（流中没有被读过的就算新消息）。

xreadgroup固定，group固定，groupName组名，consumer消费者名，count消费数量标记，1仅消费一条，block阻塞标记，0持续阻塞等待新消息（或毫秒），streams固定，streamName流名，>只消费没被消费过的消息。

### 检查消费者

```
xinfo consumers streamName groupName
```

检查指定流中指定消费者组中的消费者信息。

xinfo固定，consumers固定，streamName流名，groupName组名。

### 检查消费但未确认消息

```
xpending streamName groupName - + 10
```

检查指定流中指定消费者组中所有消费者消费但未确认的消息。

xpending固定，streamName流名，groupName组名，-从头开始，+直到末尾，10最多展示10条。

### 标记消息已处理

```
xack streamName groupName ID
```

标记指定流中指定组中某条被确认的消息已被处理。

xack固定，streamName流名，groupName组名，ID消息ID。

### 移交未处理消息

```
xclaim streamName groupName consumerName 0 ID
```

移交指定流中指定组中指定ID的未处理的信息给指定消费者。

xclaim固定，streamNAme流名，groupName组名，consumerName消费者名，0马上移交，ID消息ID。

### 删除消费者

```
xgroup delconsumer streamName groupName consumerName
```

删除指定流中指定消费者组中指定消费者。

xgroup固定，delconsumer固定，streamName流名，groupName组名，consumerName消费者名。

### 删除消费者组

```
xgroup destroy streamName groupName
```

删除指定流中指定消费者组。

xgroup固定，destroy固定，streamName流名，groupName组名。

# 4，衍生数据类型

## 1.地理空间（Geospatial）

换皮的Zset。

专门用来处理地理位置信息。

### 创建位置

```
geoadd objName E/W N/S value
```

创建一个基于经纬度的位置信息。

geoadd固定，objName对象名，E/W经度，N/S纬度，value值。

### 查询位置

```
geopos objName value
```

根据对象与值查询它的位置信息。

geopos固定，objName对象名，value值。

### 距离计算

```
geodist objName valueA valueB KM
```

计算指定对象中两个值的距离。

geodist固定，objName对象名，valueA第一个值，valueB第二个值，KM距离单位。

### 扩散查询

```
geosearch objName frommember value byradius num KM
```

查询某个对象内以某个位置（已有的值或经纬度）为原点，扩散指定距离内是否存在值（包括自己）。

geosearch固定，objName对象名，frommember固定，value值，byradius固定，num距离，KM距离单位。

## 2.去重计数器（HyperLogLog）

用来做基数统计的。

跟名字一样，就是计算去重后的数量。

只能计数，看不到放进去啥玩意的。

### 塞数

```
pfadd groupName value1 value2 value3...
```

向指定计数组塞值。

pfadd固定，groupName组名，value值。

### 基数统计

```
pfcount groupName
```

计算指定组内的基数。

pfcount固定，groupName组名。

### 合并组

```
pfmerge groupName1 groupName2
```

合并两个计数组，后者值会并入前者，后者本身不会变动。

pfmerge固定，groupName组名。

# 5，事务

## 1.是个啥

redis这个缓存玩意理应没有事务这个概念。

只是在redis的主进程外新开一条，单独处理规划好的命令组。

和传统事务支持批量顺序且允许回滚相比，这玩意就少个回滚。

命令组某条命令炸掉，已经跑了的不会撤回，没跑的会继续跑跑试试。

## 2.命令

### 批量头

```
multi
```

标记批量处理的命令组的开始。

后续写的命令都会存入预备的命令组，等待执行或放弃的命令。

multi固定。

### 执行

```
exec
```

顺序执行命令组中所有命令（先进先跑）。

exec固定。

### 放弃

```
discard
```

放弃命令组的执行，组内命令清空。

discard固定。

# 6，持久化

## 1.是个啥

就是字面意思，让这个缓存做真正数据库的本职工作。

虽然感觉一般用处不算太大。

除了做恢复快照之外感觉就没啥用了。

## 2.持久化模式

### RDB

用来记录数据快照。

似乎是默认开启。

把快照写进dump.rdb二进制文件。

新快照会覆盖旧的。

在redis.conf中找到Save the DB on disk就是RDB模式的配置。

如save 900 10就是指900秒内有10次写操作则产生快照。

可以组合多个条件。

#### 手动快照

```
save
```

这玩意可以手动创建当前快照。

自动快照是独立进程，主进程还是能正常跑命令干活。

手动快照挂在主进程中，会卡着不让干别的事，直到做完快照。

#### 优劣

适合自动数据备份。

但是会牺牲数据完整性，且缺乏即时性。

### AOF

用来记录执行的命令快照。

默认关闭，在redis.conf中将appendonly no设置为appendonly yes。

#### 策略

有三种。

- always：每次写均保存。
- everysec：每秒保存。
- no：不保存。

#### 优劣

保证数据完整性。

但会拖性能，且备份快照挺大的。

### 混合

未启用时RDB存数据，AOF存命令。

在redis.conf中将appendonly no设置为appendonly yes。

再将aof-use-rdb-preamble 设置为yes就能启动混合模式。

混合模式下会把数据和命令存进一个RDB-AOF混合文件。

一般是先塞RDB格式的快照，再补上快照后执行的AOF格式的命令记录。

说是可以加快恢复速度，减小体积。

# 7，SB集成

## 1.依赖

一个就行。

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
</dependency>
```

## 2.配置

```yaml
spring:
    data:
        redis:
            # 选择数据库（0-15）
            database: 0
            # 主机地址
            host: 127.0.0.1
            # 端口号
            port: 6379
            # 密码（如果有设置）
            # password: 123456
            # 命令超时时间
            timeout: 2000
            # 连接超时时间
            connect-timeout: 2000
```

## 3.RedisTemplate API

这就是在Java中写Redis的大头了。

这个私人API装了一大堆私人方法。

几乎就是有多少命令就有多少方法。

这里仅举例最最最最常用的（应该），没有的自己查。

抄下来都嫌累。

### StringRedisTemplate API

这玩意是RedisTemplate的子类。

key和value都定义为String类型。

方便后续操作。

记得先启动Redis服务（我是用Docker镜像的Redis）。

且在使用后面所有的命令前，都要先把这玩意实例出来先。

```java
// 这是在SB的单元测试里面实例的
private StringRedisTemplate stringRedisTemplate;

@Autowired
public Ch11ApplicationTests(StringRedisTemplate stringRedisTemplate) {
    this.stringRedisTemplate = stringRedisTemplate;
}
```

#### String

##### 设置

```java
stringRedisTemplate.opsForValue().set("StringName", "value");
```

创建新的String并赋键值。

##### 获取

```java
String val = stringRedisTemplate.opsForValue().get("StringName");
```

获取指定键的String的值。

##### 定时过期

```java
stringRedisTemplate.opsForValue().set("StringName", "value", 30, TimeUnit.SECONDS);
```

创建新的String并赋键值，且定义过期（生存）时间，过期即销毁。

#### List

##### 前入列

```java
stringRedisTemplate.opsForList().leftPush("ListName", "value");
```

从集合的开头插入新数据。

##### 后入列

```java
stringRedisTemplate.opsForList().rightPush("ListName", "value");
```

从集合的末尾插入新数据。

##### 获取区间

```java
List<String> range = stringRedisTemplate.opsForList().range("ListName", 0, -1);
```

获取指定区间的值（包括start和end）。

#### Set

##### 添加

```java
stringRedisTemplate.opsForSet().add("setName", "value", "value");
```

添加值至指定集合。

##### 获取值

```java
Double score = stringRedisTemplate.opsForZSet().score("setName", member);
```

获取指定集合中指定值的分数。

##### 获取全部

```java
Set<String> members = stringRedisTemplate.opsForSet().members("setName");
```

获取指定集合的全部元素。

##### 删除值

```java
stringRedisTemplate.opsForSet().remove("setName", "value");
```

删除指定集合的指定元素。

##### 增减分数

```java
Double goodsZSet = stringRedisTemplate.opsForZSet().incrementScore("setName", member, -1);
```

增加或减少指定集合中指定值的分数（允许正负数）。

##### 值是否存在

```java
Boolean exists = stringRedisTemplate.opsForSet().isMember("setName", "value");
```

检查指定值是否存在于指定集合中。

#### Zset

##### 添加

```java
stringRedisTemplate.opsForZSet().add("zsetName", "member", sroce);
```

向指定集合中添加值与分数。

##### 获取分数

```java
Double score = stringRedisTemplate.opsForZSet().score("zsetName", "member");
```

根据指定值获取对应分数。

##### 获取值排名

```java
Long rank = stringRedisTemplate.opsForZSet().rank("zsetName", "member");
```

根据指定值获取它的排名。

##### 获取区间

```java
Set<String> range = stringRedisTemplate.opsForZSet().range("zsetName", 0, -1);
```

获取指定集合的指定区间的值。

#### Hash

##### 添加

```java
stringRedisTemplate.opsForHash().put("hashName", "key", "value");
```

添加对至指定哈希。

##### 获取某个

```java
String name = (String) stringRedisTemplate.opsForHash().get("hashName", "key");
```

根据键获取值。

##### 获取全部

```java
Map<Object,Object> map = stringRedisTemplate.opsForHash().entries("hashName");
```

获取指定哈希的全部对。

##### 是否存在

```java
boolean exists = stringRedisTemplate.opsForHash().hasKey("hashName", key);
```

判断指定键是否存在指定哈希中。

## 4.高并发案例

接下来整个削峰，原子执行的。

用于如秒杀或抢票情况的抗压结构。

就是把redis，rabbit，lua脚本，caffeine啥的全用上。

因为这个案例迭代了三个版本，这里只把最终版本记上。

有些类里面的导入依赖应该是没删干净的，不用管它先。

### 依赖

```xml
<dependencies>
    <!--  咖啡因用来做二级缓存  -->
    <dependency>
        <groupId>com.github.ben-manes.caffeine</groupId>
        <artifactId>caffeine</artifactId>
        <version>3.1.8</version>
    </dependency>
    <!--  rabbit队列做请求削峰  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-amqp</artifactId>
    </dependency>
    <!--  redis做库存抢购  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>

    <!--  方便的妙妙工具  -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
    </dependency>
    <dependency>
        <groupId>com.fasterxml.jackson.core</groupId>
        <artifactId>jackson-databind</artifactId>
    </dependency>

    <!--  数据库  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-jdbc</artifactId>
    </dependency>
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter</artifactId>
        <version>3.0.5</version>
    </dependency>
    <dependency>
        <groupId>org.mybatis.spring.boot</groupId>
        <artifactId>mybatis-spring-boot-starter-test</artifactId>
        <version>3.0.5</version>
        <scope>test</scope>
    </dependency>

    <!--  框架  -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

### 响应对象

水一水文档长度。

```java
package com.example.ch12.common.result;

import lombok.Data;

@Data
public class ResultVO {
    private Integer code;
    private String message;
    private Object Data;

    public ResultVO(Integer code, String message, Object data) {
        this.code = code;
        this.message = message;
        Data = data;
    }

    public static <T> ResultVO success(T data) {
        return new ResultVO(200, null, data);
    }

    public static ResultVO success() {
        return new ResultVO(200, null, null);
    }

    public static ResultVO error(int code, String message) {
        return new ResultVO(code, message, null);
    }
}
```

### 错误捕获

#### 运行异常拦截

```java
package com.example.ch12.common.exception;

public class GlobalException extends RuntimeException{
    private Integer errorCode;

    public GlobalException(String message, Integer errorCode) {
        super(message);
        this.errorCode = errorCode;
    }

    public Integer getErrorCode() {
        return errorCode;
    }
}
```

#### 重新定义异常

```java
package com.example.ch12.common.exception;

import com.example.ch12.common.result.ResultVO;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;

@RestControllerAdvice(basePackages = "com.example.ch12")
public class GlobalExceptionAdvice {
    @ExceptionHandler(GlobalException.class)
    public ResultVO handleGlobalException(GlobalException globalException) {
        return ResultVO.error(globalException.getErrorCode(), globalException.getMessage());
    }

    @ExceptionHandler(Exception.class)
    public ResultVO handleException(Exception e) {
        return ResultVO.error(500, "服务器异常：" + e);
    }
}
```

#### 自定义异常

```java
package com.example.ch12.common.exception;

public class OrderException extends GlobalException{
    public OrderException(String message, Integer errorCode) {
        super(message, errorCode);
    }
}
```

### 创建对象

#### 商品对象

```java
package com.example.ch12.entity;

import lombok.Data;

@Data
public class Goods {
    private Integer goodsId;
    private String goodsName;
    private Integer goodsStock;
}
```

#### 订单对象

```java
package com.example.ch12.entity;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class Order {
    private Integer orderId;
    private Integer goodsId;
    private Integer userId;
    private Integer num;
}
```

### 兔子队列配置

```java
package com.example.ch12.common.config;

import org.springframework.amqp.core.*;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class RabbitConfig {

    public static final String ORDER_QUEUE = "order-queue";
    public static final String ORDER_EXCHANGE = "order-exchange";
    public static final String ORDER_ROUTING_KEY = "order";

    @Bean
    public Queue orderQueue() {
        return QueueBuilder.nonDurable(ORDER_QUEUE).build();
    }

    @Bean
    public DirectExchange orderExchange() {
        return new DirectExchange(ORDER_EXCHANGE, false, false);
    }

    @Bean
    public Binding orderBinding(Queue orderQueue, DirectExchange orderExchange) {
        return BindingBuilder.bind(orderQueue).to(orderExchange).with(ORDER_ROUTING_KEY);
    }
}
```

### mapper类

#### 商品mapper

```java
package com.example.ch12.mapper;

import com.example.ch12.entity.Goods;

import java.util.List;

public interface GoodsMapper {
    /**
     * 根据指定的商品ID，查询匹配的商品的全部信息
     * @param goodsId 商品ID
     * @return 商品全部信息
     */
    Goods getGoodsById(int goodsId);

    /**
     * 根据指定的商品ID，减少匹配的商品的库存数量（单件）
     * @param goodsId 商品ID
     * @return 是否成功
     */
    int decrStockById(int goodsId);

    /**
     * 根据指定的商品ID，减少匹配的商品的库存数量（多件）
     * @param goodsId
     * @param num
     * @return
     */
    int decrStocksById(int goodsId, int num);

    /**
     * 获取全部商品
     * @return
     */
    List<Goods> getList();
}
```

#### 订单mapper

```java
package com.example.ch12.mapper;

import com.example.ch12.entity.Order;
import org.apache.ibatis.annotations.Options;

public interface OrderMapper {
    /**
     * 创建订单
     * @param order 订单全部信息
     */
    void addOrder(Order order);
}
```

### mapper映射

#### 商品mapper

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.ch12.mapper.GoodsMapper">

    <resultMap id="goodsMap" type="com.example.ch12.entity.Goods">
        <id property="goodsId" column="g_id"/>
        <result property="goodsName" column="g_name"/>
        <result property="goodsStock" column="stock"/>
    </resultMap>

    <select id="getGoodsById" resultMap="goodsMap">
        select g_id, g_name, stock from goods_info where g_id = #{goodsId}
    </select>

    <update id="decrStockById">
        update goods_info set stock = stock - 1 where stock > 0 and g_id = #{goodsId}
    </update>

    <update id="decrStocksById">
        update goods_info set stock = stock - #{num} where stock > 0 and g_id = #{goodsId}
    </update>
    
    <select id="getList" resultMap="goodsMap">
        select g_id, g_name, stock from goods_info
    </select>

</mapper>
```

#### 订单mapper

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.example.ch12.mapper.OrderMapper">

    <resultMap id="orderMap" type="com.example.ch12.entity.Order">
        <id property="orderId" column="order_id"/>
        <result property="goodsId" column="goods_id"/>
        <result property="userId" column="user_id"/>
        <result property="num" column="num"/>
    </resultMap>

    <insert id="addOrder">
        insert into order_infopro(goods_id, user_id, num) values(#{goodsId}, #{userId}, #{num})
    </insert>
    
</mapper>
```

### lua脚本

在resource下的lua目录内做个seckill.lua文件。

```lua
-- KEYS[1] = 商品库存ZSet key ("goodsZSet")
-- KEYS[2] = 订单Hash key ("ordersHash")
-- ARGV[1] = 商品ID
-- ARGV[2] = 订单ID（UUID）
-- ARGV[3] = 用户ID
-- ARGV[4] = 数量

local stock = redis.call('ZSCORE', KEYS[1], ARGV[1])
if (not stock) or (tonumber(stock) < tonumber(ARGV[4])) then
    return 0
end

redis.call('ZINCRBY', KEYS[1], -tonumber(ARGV[4]), ARGV[1])

local order = cjson.encode({orderId=ARGV[2], goodsId=ARGV[1], userId=ARGV[3], num=ARGV[4]})
redis.call('HSET', KEYS[2], ARGV[2], order)

return 1
```



### 队列消费者

```java
package com.example.ch12.common.consumer;

import com.example.ch12.common.config.RabbitConfig;          // RabbitMQ 队列/交换机配置
import com.fasterxml.jackson.databind.ObjectMapper;    // JSON 序列化/反序列化
import org.springframework.amqp.rabbit.annotation.RabbitListener;  // 消费者监听注解
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.core.io.ClassPathResource;             // 加载 Lua 脚本
import org.springframework.data.redis.core.StringRedisTemplate;   // Redis 操作模板
import org.springframework.data.redis.core.script.DefaultRedisScript; // Redis Lua 脚本执行
import org.springframework.stereotype.Component;                  // Spring 组件注解

import java.util.List;
import java.util.Map;

@Component
public class OrderConsumer {

    private final StringRedisTemplate redisTemplate;
    private final CacheManager cacheManager;

    public OrderConsumer(StringRedisTemplate redisTemplate, CacheManager cacheManager) {
        this.redisTemplate = redisTemplate;
        this.cacheManager = cacheManager;
    }

    @RabbitListener(queues = RabbitConfig.ORDER_QUEUE)
    public void handleOrder(String msgJson) {
        try {
            Map<String, Object> msg = new ObjectMapper().readValue(msgJson, Map.class);
            String orderId = (String) msg.get("orderId");
            int goodsId = (Integer) msg.get("goodsId");
            int num = (Integer) msg.get("num");

            // 调用 Redis Lua 扣库存
            DefaultRedisScript<Long> script = new DefaultRedisScript<>();
            script.setLocation(new ClassPathResource("lua/seckill.lua"));
            script.setResultType(Long.class);

            Long result = redisTemplate.execute(
                    script,
                    List.of("goodsZSet", "ordersHash"),
                    String.valueOf(goodsId),
                    orderId,
                    String.valueOf(msg.get("userId")),
                    String.valueOf(num)
            );

            if (result == null || result == 0) {
                Cache soldOutCache = cacheManager.getCache("soldOutCache");
                soldOutCache.put(goodsId, true);
                System.out.println("库存不足:" + orderId);
            }

        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

### service层

```java
package com.example.ch12.service;

import com.example.ch12.common.config.RabbitConfig;
import com.example.ch12.common.exception.GlobalException;
import com.example.ch12.common.exception.OrderException;
import com.example.ch12.entity.Order;
import com.example.ch12.mapper.GoodsMapper;
import com.example.ch12.mapper.OrderMapper;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.springframework.amqp.rabbit.core.RabbitTemplate;
import org.springframework.cache.Cache;
import org.springframework.cache.CacheManager;
import org.springframework.core.io.ClassPathResource;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;

import java.util.*;

// 需要参与抢购的商品数据先被caffeine进行售空拦截
// 未售空商品则将请求甩入队列慢慢吃
// 消费者使用lua脚本做原子操作
// redis中对应商品库存减少,一并创建保存订单
// 支付后redis数据同步至数据库

@Service
public class OrderService {
    private final GoodsMapper goodsMapper;
    private final OrderMapper orderMapper;
    private final StringRedisTemplate stringRedisTemplate;
    private ObjectMapper objectMapper;
    private final RabbitTemplate rabbitTemplate;
    private CacheManager cacheManager;

    public OrderService(GoodsMapper goodsMapper, OrderMapper orderMapper, StringRedisTemplate stringRedisTemplate, ObjectMapper objectMapper, RabbitTemplate rabbitTemplate, CacheManager cacheManager) {
        this.goodsMapper = goodsMapper;
        this.orderMapper = orderMapper;
        this.stringRedisTemplate = stringRedisTemplate;
        this.objectMapper = objectMapper;
        this.rabbitTemplate = rabbitTemplate;
        this.cacheManager = cacheManager;

        initStock(List.of(
                Map.of("goodsId", 1, "stock", 1),
                Map.of("goodsId", 2, "stock", 1),
                Map.of("goodsId", 3, "stock", 1)
        ));
    }

    public void initStock(List<Map<String, Object>> goodsList) {
        String goodsKey = "goodsZSet";

        // 清空原库存
        stringRedisTemplate.delete(goodsKey);
        stringRedisTemplate.delete("ordersHash");

        // 初始化库存
        for (Map<String, Object> goods : goodsList) {
            Integer goodsId = (Integer) goods.get("goodsId");
            Integer stock = (Integer) goods.get("stock");
            stringRedisTemplate.opsForZSet().add(goodsKey, String.valueOf(goodsId), stock);
        }
    }
    
    // MQ前置削峰，caffeine售空拦截，lua原子执行（他妈的卡在单机极限了，并发线程死在2000上不去了，我电脑应该没这么飞舞呀，硬件也没跑满啊，不知道啥玩意干的好事）

    // 下单
    public String placeOrderProMaxUltra(int goodsId, int userId, int num) {
        Cache soldOutCache = cacheManager.getCache("soldOutCache");

        if (soldOutCache.get(goodsId) != null) {
            System.out.println("商品已售罄（本地缓存）");
            throw new OrderException("商品已售罄（本地缓存）", 1002);
        }

        String orderId = UUID.randomUUID().toString();
        Map<String, Object> msg = new HashMap<>();
        msg.put("orderId", orderId);
        msg.put("goodsId", goodsId);
        msg.put("userId", userId);
        msg.put("num", num);

        try {
            String msgJson = new ObjectMapper().writeValueAsString(msg);
            rabbitTemplate.convertAndSend(
                    RabbitConfig.ORDER_EXCHANGE,
                    RabbitConfig.ORDER_ROUTING_KEY,
                    msgJson
            );
        } catch (JsonProcessingException e) {
            throw new RuntimeException("MQ发送失败", e);
        }

        return orderId;
    }

    // 付款
    public void payOrderProMax(String orderId) {
        try {
            // 获取订单
            Object json = stringRedisTemplate.opsForHash().get("ordersHash", orderId);
            Order order = objectMapper.readValue(json.toString(), Order.class);
            // 同步数据库订单
            orderMapper.addOrder(order);
            // 同步数据库库存
            goodsMapper.decrStocksById(order.getGoodsId(), order.getNum());
            // 删除订单
            stringRedisTemplate.opsForHash().delete("ordersHash", orderId);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    // 取消
    public void cancelOrderProMax(String orderId) {
        try {
            // 获取订单
            Object json = stringRedisTemplate.opsForHash().get("ordersHash", orderId);
            Order order = objectMapper.readValue(json.toString(), Order.class);
            // 获取订单下单商品数量
            int num = order.getNum();
            // 删除订单
            stringRedisTemplate.opsForHash().delete("ordersHash", orderId);
            // 恢复库存
            stringRedisTemplate.opsForZSet().incrementScore("goodsZSet", String.valueOf(order.getGoodsId()), num);
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
    }

    // 商品售空检查
    private Cache soldOutCache() {
        return cacheManager.getCache("soldOutCache");
    }
}
```

### controller层

```java
package com.example.ch12.web;

import com.example.ch12.common.result.ResultVO;
import com.example.ch12.service.OrderService;
import lombok.RequiredArgsConstructor;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RestController;

@RestController
@RequiredArgsConstructor
public class OrderController {
    private final OrderService orderService;
    
    /**
     * 下单
     * @param goodsId
     * @param userId
     * @param num
     * @return
     */
    @GetMapping("/order/proMaxUltra/{goodsId}/{userId}/{num}")
    public ResultVO createOrderProMaxUltra(@PathVariable("goodsId") int goodsId,
                                      @PathVariable("userId") int userId,
                                      @PathVariable("num") int num) {
        return ResultVO.success(orderService.placeOrderProMaxUltra(goodsId, userId, num));
    }

    /**
     * 支付成功
     * @param orderId
     * @return
     */
    @GetMapping("/order/pay/proMax/{orderId}")
    public ResultVO payOrderProMax(@PathVariable("orderId") String orderId) {
        orderService.payOrderProMax(orderId);
        return ResultVO.success();
    }

    /**
     * 取消支付
     * @param orderId
     * @return
     */
    @GetMapping("/order/cancel/proMax/{orderId}")
    public ResultVO cancelOrderProMax(@PathVariable("orderId") String orderId) {
        orderService.cancelOrderProMax(orderId);
        return ResultVO.success();
    }
}
```

### SB启动器

```java
package com.example.ch12;

import com.example.ch12.entity.Goods;
import com.example.ch12.mapper.GoodsMapper;
import com.example.ch12.mapper.OrderMapper;
import com.example.ch12.service.OrderService;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cache.annotation.EnableCaching;
import org.springframework.data.redis.core.StringRedisTemplate;

import java.util.List;

@SpringBootApplication
@MapperScan("com.example.ch12.mapper")
@EnableCaching
public class Ch12Application {
    public static void main(String[] args) {
        SpringApplication.run(Ch12Application.class, args);
    }
}
```

