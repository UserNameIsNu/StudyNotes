[TOC]

# Java

# 1，简介与概念

## 1.这是啥

​	一种高级编程语言。

​	多用于桌面应用，企业应用，移动应用，服务器系统，大数据开发和游戏开发（基本啥都能干）。

​	（写代码的宗旨：优雅！简洁！高效！（让别人看不懂！））。

## 2.技术体系

​	分为三种：

​	Java SE（标准版），包含 Java 的核心，也是基础。

​	Java EE（企业版），专门为企业应用开发创建的解决方案。

​	Java ME（小型版），专门为移动应用开发创建的解决方案。

## 3.安装

​	没啥好说的，百度。

​	反正建议使用长期支持版（LTS版）。

​	进到安装完的根目录，命令行执行 `java`，`javac` 和 `java -version`，蹦出东西和版本号就算是安装好了。

​	安装的 Java 版本也叫 JDK 版本。

​	其中 `java` 和 `javac` 两个命令程序一个负责执行，一个负责编译。

## 4.开发步骤

​	三步。	

​	写代码，出现 `.java` 文件。

​	编译代码，出现 `.class` 文件。

​	运行代码。

​	也算是因为多一个编译步骤，使用虚拟机区别化编译。

​	所以可以把代码变成不同设备认识的形式，使得 Java 可以在不同设备上兼容运行。

​	可以使用记事本试试。

​	先创建一个 `HelloWord.java` 文件，记事本打开编写代码。

```java
public class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```

​	原地打开命令行执行命令。

```powershell
javac HelloWord.java
```

​	然后理应出现一个 `HelloWord.class` 文件。

​	继续执行命令。

```powershell
java HelloWord
```

​	理应显示 ‘Hello World’。

## 5.JDK的组成

​	JVM，Java 虚拟机，运行 Java 程序的地方。

​	核心类库，存放预先写好的一些方法程序，写代码时经常会调用。

​	JRE，由 JVM 和核心类库共同组成，是 Java 的运行环境。

​	开发工具，包括 Java 和 Javac。

​	上面四个加起来就是一个完整的 JDK 了。

## 6.API

​	就是 Java 预留的程序接口，已经实现了很多特定情况的任务。

​	有需要时直接使用。

​	比如有一个获取用户键盘按了什么按键的需求。

​	不用自己编写逻辑，判断。

​	调用相应的 API 就能直接获取到按了哪个按键。

​	API 文档可以在官网查到。

# 2，基础语法

## 1.注释

​	就是给写代码的看的，不会被执行，也不会影响执行。

​	一般有三种。

​	单行注释和多行注释就是字面意思，只能写一行或写好几行注释。

​	文档注释最常用的时候就是给方法（函数）加，用于描述方法（函数）。

​	(敲代码记得加注释，别人看不懂，自己也看不懂)。

```java
// 单行注释

/*
	多行注释
*/

/**
	文档注释
*/
```

##  2.关键字

​	被 Java 占用的，在写代码时不能用于类名，变量名等。

​	就说挺多的，但是不用记，反正会报错，错了改嘛。

## 3.标识符，命名规定

​	就是类名，变量名等名字。	

​	一般由数字，字母，下划线和美元号组成。

​	不能用数字开头，不能用关键字。

​	变量命名满足驼峰式命名规定，即首字母小写，后续每个单词首字母大写和上面所有。

​	类命名也是满足驼峰式命名规定和上面所有，就是首字母要大写。

​	且 Java 对大小写敏感。

​	命名尽量有意义，直接易懂。

## 4.数据类型

​	虽然存储的数据都是二进制形式，但是 Java 中如变量是需要定义明确的数据类型的。

​	指定了变量存储的数据的类型。

​	基本数据类型是四类八种。

​	整型：byte，short，int，long。

​	浮点型：float，double。

​	字符型：char。

​	布尔型：boolean。

​	引用数据类型：String，类，接口，数组...

## 5.类型转换

​	反正就是会有这种情况。

​	类型转换的根本就是二进制位数的增减。

​	有三种转换形式。

​	第一就是自动类型转换，就是类型范围小的可以转成类型范围大的。

​	如 byte 可以转为 int。

​	也可以跳跃转换，如 byte 转为 long。

​	下面就是一个发生了自动类型转换的例子。

​	常见的转换链是：

​	byte - short - int - long - float - double。

​	其中 char 能转为 int。

```java
byte a = 10;
int b = a;
```

​	第二种就是表达式自动类型转换。

​	就是在表达式中，参与运算的数据类型会全部自动转换成最大的那个。

​	所以最终结果的类型会由最高级的那个决定。

​	其中注意 byte，short 和 char 会先变为 int 再参与表达式的运算。

```java
byte a = 1;
int b = 1;
long c = 1;
long sum = a + b + c;
```

​	最后就是强制类型转换，就是需要把大类型反向变为小类型。

​	小变大只需要补零即可。

​	而大变小时若大的太大，超出了小的二进制位数的上限，那么就会发生截断，也就是数据溢出。

​	数据就丢失了，坏掉了。

​	还要注意任何浮点型数据强转为整型时，小数位全都会丢失。

```java
// 输出20，没有问题
int a = 20;
byte b = (byte)a; 

// 输出-36，数据溢出
int a = 1500;
byte b = (byte)a;

// 输出99，小数位截断
double a = 99.5;
int b = (int)d;
```

# 3，运算符

## 1.常用算数运算符

​	就是比如加减乘除这种，反正就是用在表达式中的符号。

​	有很多种。

​	先是基本的算数运算符，用于数学运算。

​	有 `+`，`-`，`*`，`%`，`/` 五个。

​	其中加号除了数学运算还能做字符串的拼接工作。

​	若字符串与数字共同运算，数字会被强行变成字符串做拼接动作，不论顺序。

```java
int a = 10;
int b = 3;
System.out.println(a + b); // 13，加法
System.out.println(a - b); // 7，减法
System.out.println(a * b); // 30，乘法
System.out.println(a % b); // 1，除法（只保留除不尽的余数）
System.out.println(a / b); // 3，除法（除不尽的余数丢弃）

String c = "AB";
String d = "C";
System.out.println(c + d); // ABC，字符串拼接
System.out.println(a + d); // 10C，字符串拼接
System.out.println(a + d + b); // 10C3，字符串拼接
System.out.println(a + b + c); // 103AB，字符串拼接
```

## 2.常用自增减运算符

​	然后是自增减运算符。

​	就 `++`，`--` 两个。

​	让变量加一或减一。

​	这玩意只能操作数字变量，其它字面量之类的全都不行。

​	这玩意放在前面后面区别就是先自增减再执行运算，还是先执行运算再自增减。

```java
int a = 0;
a++;
System.out.println(a); // 1，自增
a--;
System.out.println(a); // -1，自减

int c = 10;
int C = ++c;
System.out.println(a); // 11，先自增
int d = 10;
int D = d++;
System.out.println(a); // 10，后自增
```

## 3.常用赋值运算符

​	然后是赋值运算符。

​	用于给变量赋值。

​	有 `=`，`+=`，`—=`，`*=`，`%=`，`/=` 六个。

```java
int a = 1; // 这些都是在赋值
int b += a; // b = b + a
int c -= a; // c = c - a
int d *= a; // d = d * a
int e %= a; // e = e % a
int f /= a; // f = f / a
System.out.println(b); // 11
System.out.println(c); // 9
System.out.println(d); // 10
System.out.println(e); // 10
System.out.println(f); // 0
```

## 4.常用关系运算符

​	主要判断条件。

​	也是六个。

​	`>`，`>=`，`<`，`<=`，`==`，`!=`。

​	判断后返回 `true` 或 `false`。

​	其中的等于判断是 `==`，不要和 `=` 赋值符搞混（这是敲代码，不是数学题）。

```java
int a = 1;
int b = 2;
System.out.println(a > b); // false，判断是否大于
System.out.println(a >= b); // false，判断是否大于等于
System.out.println(a < b); // true，判断是否小于
System.out.println(a <= b); // true，判断是否小于等于
System.out.println(a == b); // false，判断是否等于
System.out.println(a != b); // true，判断是否不等于
```

## 5.常用逻辑运算符

​	也是判断条件，但是它是判断多个条件。

​	`&&`，`||`，`!` 三个。

​	还有单写的 `&` 和 `|`。

​	单写时，左右均会判断，然后输出结果。

​	双写时，`&` 一判为 false 二判就不会执行，`|` 一判为 true 二判就不会执行。

​	所以双写单写结果上其实一样，但是双写执行效率会高一点。

```java
int a = 1;
int b = 2;
System.out.println(a > b && a < b); // false，是否均成立
System.out.println(a > b & a < b); // false，是否均成立
System.out.println(a > b || a < b); // true，是否存在成立
System.out.println(a > b | a < b); // true，是否存在成立
System.out.println(!(a > b)); // true，结果取反
```

## 6.三元运算符

​	最后一个，用于判断表达式是否成立的。

​	若成立，取值1，反之。

```java
// 表达式 ? 值1 : 值2;
int a = 1 > 2 ? "yes" : "no";
System.out.println(a); // no，表达式不成立
```

## 7.优先级

​	这一堆运算符是有执行优先级的。

​	优先级越高，越先执行。

​	记不住就上网查，我也懒得打表了：）。

# 4，流程控制

## 1.分支结构

​	根据条件执行不同代码。

​	如果怎样就怎样，否则怎样。

​	第一个就是 `if`，判断条件选择语句。

​	有四种常见结构。

```java
// 如果...就...
if(表达式) {
    ...
}

// 如果...就...否则就...
if(表达式) {
    ...
} else {
    ...
}

// 如果...就...否则如果...就...否则...（可以创建无限多的可能）
if(表达式) {
    ...
} else if(表达式) {
    ...
}
...
else {
    ...
}

// 如果...就...否则如果...就...否则就...
if(表达式) {
    ...
} else {
    if(表达式) {
        ...
    } else {
        ...
    }
}
```

​	第二个就是 `switch`，比较值选择语句。

​	遇到匹配值就会执行对应语句。

​	但是这个执行完某个分支是不会像 `if` 一样退出结构的。

​	它会继续下面的判断，除非主动退出结构。

​	所以不要忘记给每个分支加 `break`;

​	但是有个例外，若某些分支执行的语句相同，可以主动拒绝退出，故意使得这几种分支全部指向同一段语句。

​	注意 `switch` 只支持 `byte`，`short`，`int`，`char` 这四种类型外加字符串和枚举。

​	且 `case` 的值不能重复出现，也不能是变量，之能是字面量。

```java
// 如果...就...如果...就...否则就...
switch(表达式) {
    case 值1:
        ...
        break;
    ...
    case 值n:
        ...
        break;
    default:
        ...
}

// 主动拒绝退出
switch(表达式) {
    case 值1:
    case 值2:
    case 值3:
        ...
        break
    case 值4:
        ...
        break;
    default:
        ...
}
```

​	`if` 适合条件判断或区间判断，`switch` 适合比较值。

​	且后者代码好看，性能也好一点（判断的分支多了谁都不好看，性能都差）。

## 2.循环结构

​	用于将同一段代码重复执行指定次数，或无限执行也可以。

​	第一个是 `for`。

​	三段参数分别是初始化，循环条件与迭代。

```java
// 从0开始，若小于5，加一，并执行一次结构内语句
for(int i = 0; i < 5; i++) {
    ...
}
```

​	第二个是 `while`。

​	这个循环结构的初始化需要在结构外创建，内部迭代，括号内只有循环条件。

​	功能是一样的，也就写法不一样。

​	一般建议知道确切次数的循环用 `for`，否则用 `while`（仅仅只是建议，手长在你身上不是吗）。

```java
// 从0开始，若小于5，执行一次结构内语句，并加一
int i = 0;
while(i < 5) {
    ...
    i++;
}
```

​	第三个是 `do-while`。

​	和第二种的区别就在将循环条件放在了语句后。

​	前两种都是先判断再执行，这个是先执行再判断。

```java
// 从0开始，执行一次结构内语句，加一，若小于5就重复操作
int i = 0;
do {
    ...
    i++;
} while(i < 5);
```

​	有一种例外情况是死循环，即不会停止的循环。

​	虽然一般来说这是很该死的问题。

​	但在如服务器程序这种需要24小时运行的情况下，死循环还是挺好使的。

```java
// for 类型的死循环
for( ; ; ) {
    ...
}

// while 类型的死循环
while(true) {
    ...
}

// do-while 类型的死循环
do {
    ...
} while(true);
```

​	还~有一种例外情况，就是嵌套。

​	分支可以嵌套，循环也能嵌套。

​	父循环每单次迭代，子循环就会完整迭代。

​	但是注意嵌套的循环的初始化的值的名字不能重复。

```java
for(int i = 0; i < 5; i++) {
    for(int j = 0; j < 5; j++) {
        ...
    }
}
```

## 3.中断与跳过

​	`break` 可以中断循环并退出循环结构。

​	`continue` 可以跳过单次迭代，但循环会继续直到迭代完成。

​	前者多在结束循环或结束 `switch` 的分支穿透时使用（也能用于条件中断）。

​	而后者多在循环中使用，和语句一窝。

## 4.小结：生成随机数

​	生成一个随机数。

​	每次迭代均需输出当前随机获得的数。

​	若在10次内出现0，退出循环，输出 ’ 迭代 x 次 ‘。

​	若在10次内没有0，输出‘未出现 ‘ 0 ’。

```java
import java.util.Random;

public class RandomTest {
    public static void main(String[] args) {
        Random random = new Random();
        for (int i = 0; i < 10; i++) {
            int num = random.nextInt(10);
            if (num == 0) {
                System.out.println(num);
                System.out.println("迭代" + (i + 1) + "次");
                break;
            } else {
                System.out.println(num);
            }
            if (i == 9) {
                System.out.println("未出现0");
            }
        }
    }
}
```

# 5，数组

## 1.初始化数组

​	一组数据。

​	排着队。

​	存储批量数据时，数据形式远远好过变量（一个一个变量去声明要死的）。

​	一般就是直接静态初始化。

​	注意什么数据类型就只能放什么类型的数据。

```java
// 数据类型[] 数组名 = new 数据类型[]{值1, ..., 值n};
int[] name = new int[]{1, 2, 3};

// 也可以简化声明
int[] name = {1, 2, 3};
```

​	还有一个动态初始化。

​	就是不指定里面的值，只是规定数组长度。

​	动态初始化之后，没有赋予值的位置为填充默认值。

​	byte，short，int，char，long 的默认值为 0。

​	float，double 的默认值为 0.0。

​	boolean 的默认值为 false。

​	其它类型的默认值为 null。

```java
// 数据类型[] 数组名 = new 数据类型[长度];
int[] name = new int[5];

name[0] = 10; // 将这个数组的第1位指定为10
System.out.println(name[0]); // 输出10
```

​	注意静态初始化和动态初始化不能混用。

```java
int[] name = new int[5]{1, 2, 3}; // 会爆炸
```

​	一般吧，确定值的时候用静态初始化。

​	不确定值的时候用动态初始化。

## 2.访问数据

​	数组就是给数据排队了嘛。

​	既然排队了，当然会有序号嘛。

​	数组中有个概念叫下标（或叫索引），这就是序号，代表了某个数据处在这个队列（数组）中的第几个位置。

​	注意，这里的下标是从0开始的，且使用时下标不要超出数组指向不存在的位置。

```java
int[] name = {1, 2, 3};

System.out.println(name[0]); // 输出1
System.out.println(name.length); // 输出3（检查数组长度）
System.out.println(name[name.length - 1]); // 输出3（长度减一可以直接获取最后一个）
```

## 3.数组遍历

​	上面的访问就是直接指定要第几个。

​	而遍历就是一个一个的拿到数组的每一个数据。

​	既然这样，循环是不是目前来看最合适的了？

```java
int[] name = {1, 2, 3};
// 输出1，2，3
for(int i = 0; i < name.length; i++) {
    System.out.print(name[i]);
}
```

## 4.存储区别

​	声明变量时，变量名下属的变量值会直接保存在栈中。

​	而声明数组时，栈只会保存数组名，这个数组名下属的是值在堆中的位置。

​	实际的数据本身是被存在了堆中。

​	使用栈中的地址在堆里找出数组的数据，然后才能拿到它。

​	还有就是当多个数组名指向同一个数组时，因为这个名字只是存了地址，所以实际上它们都是指向了相同的数据实体。

​	通过其中一个数组名修改了这个数据实体，再用另外一个数组名访问时，数据就会与先前不同。

​	就像一个人可以有好几个外号一样。

​	还有一种情况，就是这个数组名直接存储了 null。

​	代表这个数组名没有保存任何地址，相当于没有指向任何对象（数据实体）。

​	这种情况虽然可以输出它（输出结果为 null），但是如果要获取下标数据或长度，那就会直接爆炸。

## 5.小结：计算销售额，考试最高分

​	有个飞舞公司。

​	它一年的销售额为1，1，1，1，1，1，1，1，1，3，6，1（万元）。

​	计算这个公司这一年赚了多少。

​	最后输出 ” 今年一共赚了x万元 “。

```java
int[] name = {1，1，1，1，1，1，1，1，1，3，6，1};
int sum = 0;
for(int i = 0; i < name.length; i++) {
    sum += name[i];
}
System.out.println("今年一共赚了" + sum + "万元");
```

​	有个飞舞班级。

​	他们刚考完试。

​	一共4个学生。

​	需要拿到其中的最高分。

​	最后输出 " 最高分是x "。

```java
int[] name = new []{10, 15, 60};
int max = 0;
for(int i = 0; i < name.length; i++) {
    if(name[i] < max) {
        max = name[i];
    }
}
System.out.println("最高分是" + max);
```

# 6，方法

## 1.这是啥

​	这是一种语法结构，可以把某段代码封装成一个功能包。

​	之后遇到相同情况时可以重复使用。

​	就是为了提高代码的复用性，提高了效率。

​	更是能让代码逻辑变清晰明了。

​	记住方法必须主动调用才会执行。

​	且返回值必须与定义的数据类型相同。

```java
修饰符 返回值数据类型 方法名([形参...]) {
    语句...
    [返回值]
}

// 打包一个求两数和的方法，并使用
public static int sum(int a, int b) {
    return a + b;
}
System.out.println(sum(10, 10)); // 输出20
```

​	要接受数据才加形参。

​	有返回值才要加返回值。

```java
// 无参数，无返回值方法
public static void sum() {
    ...
}
```

​	方法还有个小特点。

​	方法被调用时是在栈内存中运行。

​	因为栈的特点是先进的后出去，可以实现如 A方法调用 B 方法时。

​	B 方法执行完之后可以回到 A 方法继续后续步骤。

## 2.常见问题

​	方法内部不能嵌套另一个方法。

​	不要返回值时，方法内不要加 `return` 关键字。

​	`return` 属于方法的结束，后面不加代码（加了也不执行）。

​	方法不调用就不执行，调用必须按照方法的要求调用。

​	调用有返回值的三种方法：

​	可以定义变量接收返回，直接输出返回，直接调用不接收返回。

​	调用没返回值的一方法：

​	直接调用。

## 3.参数传递

​	首先就是形参与实参的区别。

​	形参就是没有定义的，形参就是方法内的被声明赋值的变量。

​	在调用方法传值时，值本身不会动，传递的是值的副本。

​	不过这可只是基本数据类型。

​	在传递引用数据类型时，传递的就不是副本的，而是这个数据的地址。

​	相当于基本数据类型传递并修改后，回来是不会变化的。

​	而引用数据类型传递并修改后，是会变化的。

```java
public static void a() {
    int[] arr = new int[]{1, 2, 3};
    int num = 1;
    change(arr, num);
    System.out.println(arr[0]); // 输出2
    System.out.println(num); // 输出1
}

public static void change(int[] arr, int num) {
    arr[0] = 2;
    num = 2;
} 
```

## 4.方法的重载

​	就是在同一个类中，出现的多个方法名相同，但形参不同的。

​	这些方法就算是重载的。

​	注意，重载的判断条件仅限于形参，其他修饰符返回值啥的都么关系。

​	且形参需要个数，数据类型或顺序不同，名字无所谓

​	一般就是需要给同一种业务或问题提供多种解决方案时，可以使用重载。

```java
// 下面两个方法就算是构成了重载
public static void name(int num) {
    ...
}
public static void name(String str) {
    ...
}
```

## 5.return关键字

​	一般就是在有返回值的方法的末尾使用。

​	为啥要单独提它？

​	因为它还能作为中断退出用途。

​	如数字除0时会炸是吧，万一就是有傻子输入了0咋办？

​	提前判断，若为0就先行退出就好。

```java
public static void name(int num) {
    if (num == 0) {
        System.out.println("不能除0");
        return;
    } else {
        System.out.println(10 / num);
    }
}
```



## 6.小结：判断奇偶数，求1-n个数字的和

​	向方法传入一个数字，判断这个数字是奇数还是偶数。

​	奇数返回0，偶数返回1。

​	不用调用。

```java
public static int check(int num) {
    if (num / 2 == 0) {
        return 1;
    } else {
        return 0;
    }
}
```

​	向方法传入一个数组，求数组内全部数的和。

​	调用直接输出返回。

```java
public static int sum(int[] list) {
    int sum = 0;
    for(int i = 0; i < list.length; i++) {
        sum += list[i];
    }
    return sum;
}
int[] list = {1, 4, 10, 3};
System.out.println(sum(list));
```

# 7.阶段案例

## 1.买机票

​	用户购买机票时，机票原价会按照淡季、旺季，头等舱还是经济舱的情况进行相应的优惠。

​	优惠方案如下:

​	5-10月为旺季，头等舱9折，经济舱8.5折;11月到来年4月为淡季，头等舱7折，经济舱6.5折。

​	请开发程序计算出用户当前机票的优惠价。

```java
public static void main(String[] args) {
        System.out.println(price(2, 1));
    }
    public static String price(int month, int plase) {
        int normalPrice = 100;
        double finalPrice = 0;
        if (month < 1 || month > 12) {
            System.out.println("不是月份");
            return "error";
        } else if (month >= 5 && month <= 10) {
            if (plase == 0) {
                finalPrice = normalPrice * 0.95;
            } else if (plase == 1) {
                finalPrice = normalPrice * 0.85;
            } else {
                System.out.println("无效的仓位（0头等舱，1经济舱）");
                return "error";
            }
        } else {
            if (plase == 0) {
                finalPrice = normalPrice * 0.7;
            } else if (plase == 1) {
                finalPrice = normalPrice * 0.65;
            } else {
                System.out.println("无效的仓位（0头等舱，1经济舱）");
                return "error";
            }
        }
        return String.valueOf(finalPrice);
    }
```

## 2.生成验证码

​	开发一个程序，可以生成指定位数的验证码。

​	每位可以是数字、大小写字母

```java
public static void main(String[] args) {
        System.out.println(code(6));
    }
    public static String code(int num) {
        Random random = new Random();
        String code = "";
        String[] word = {"a", "b", "C"};
        for (int i = 0; i < num; i++) {
            int index = random.nextInt(num + word.length);
            if (index < num) {
                code += index;
            } else {
                code += word[index - num];
            }
        }
        return code;
    }
```

## 3.比赛打分

​	在唱歌比赛中，可能有多名评委要给选手打分。

​	分数是[0-100]之间的整数。

​	选手最后得分为:去掉最高分、最低分后剩余分数的平均分。

​	请编写程序能够录入多名评委的分数，并算出选手的最终得分。

```java
public static void main(String[] args) {
        int[] list = {30, 40, 70};
        System.out.println(point(list));
    }
    public static int point(int[] list) {
        int max = 0;
        int min = 0;
        int sum = 0;
        for (int i = 0; i < list.length; i++) {
            if (list[i] > max) {
                max = list[i];
            }
            if (list[i] < min) {
                min = list[i];
            } else if (min == 0) {
                min = list[i];
            }
        }
        for (int point : list) {
            if (point != max && point != min) {
                sum += point;
            }
        }
        return sum;
    }
```

## 4.抽奖

​	分别有:9、666、188、520、99999五个红包。

​	请模拟粉丝来抽奖，按照先来先得随机抽取，抽完即止。

​	一个红包只能被抽一次，先抽或后抽哪一个红包是随机的。

```java
public static void main(String[] args) {
    int[] money = {1, 10, 20, 50, 100};
    Scanner scanner = new Scanner(System.in);
    while (money.length > 0) { // 当 money 数组不为空时继续循环
        money = getMoney(money); // 更新 money 数组
    }
    System.out.println("抽完了");
}

public static int[] getMoney(int[] money) {
    Random random = new Random();
    int index = random.nextInt(money.length); // 随机选择一个索引
    System.out.println("抽到了" + money[index] + "元"); // 输出抽中的金额

    // 创建新数组，长度为原数组长度减 1
    int[] newList = new int[money.length - 1];
    int newIndex = 0; // 新数组的索引

    // 将未抽中的金额复制到新数组中
    for (int i = 0; i < money.length; i++) {
        if (i != index) { // 跳过抽中的金额
            newList[newIndex] = money[i];
            newIndex++;
        }
    }

    return newList; // 返回新数组
}
```

## 5.找素数

​	输入范围，搜寻其内有无素数，有即输出。

​	素数为除了1和本身，不能被其它正整数整除的。

```java
public static void main(String[] args) {
        int min = 10;
        int max = 30;
        find(min, max);
    }

    private static void find(int min, int max) {
        for (int i = min; i <= max; i++) { // 遍历区间
            if (isPrime(i)) { // 判断
                System.out.println(i);
            }
        }
    }

    public static boolean isPrime(int num) {
        if (num <= 1) { // 必须为正数
            return false;
        }
        // 2为最小素数，故从此开始。
        // 小于等于这个数的平方根足矣，因为若这个A数能被B数整除，那么也一定能被A/B整除
        for (int i = 2; i <= Math.sqrt(num); i++) { 
            if (num % i == 0) { // 必须为整数
                return false;
            }
        }
        return true;
    }
```

## 6.打印乘法表

​	字面意思。

```java
for (int i = 1; i <= 9; i++) {
    for (int j = 1; j <= i; j++) {
        System.out.print(j * i + "    ");
    }
    System.out.println();
}
```

# 8，面向对象编程

## 1.什么是对象

​	所有东西，事物，数据，状态等均可以成为对象（也叫实体类）。

​	对象包含了目标中的关键所需属性。

​	官话就是为了更好地组织代码，提高代码的可维护性、可扩展性和可重用性。

​	（有个家伙说：“因为这是面向对象的语言，所以要用面向对象思想编程。”）

​	注意实体类只负责定义数据与保存数据，操作数据等其它业务在外部完成。

## 2.OOP的三个特性

​	在面向对象编程（OOP）中，有三大特性。

​	封装：

​	封装就是将数据（属性）和操作数据的行为放在一起，打包到方法中。

​	核心为了将主要代码隐藏，对外只开放使用接口。

​	属性之类的私有部分使用 `private` 修饰，表示只对内可访问。

​	供外部调用的方法之类的公开部分使用 `public` 修饰，表示对外开放。

​	避免从外部直接访问甚至修改数据，保护数据安全性。

​	继承：

​	允许子类继承父类，获得父类的所有属性与方法。

​	更好的提升复用性。

​	而这种做法产生的层级结构也更方便管理与扩展。

​	多态：

​	允许一个接口或方法存在多种不同的实现方式。

​	可以根据需要切换不同实现。

​	比如支付可以用微信，支付宝或是银行卡。

​	造一个支付接口，分别实现三种支付方式即可。

​	同样为了提高扩展性与可维护性。

​	封装最典型的例子就是对象了。

​	而继承的多态下面会提到的。

## 3.创建和声明对象

​	创建对象类时，只能算是一个蓝图。

​	规定了对象长啥样，有啥属性，有啥方法。

​	一般有属性（定义有啥），构造方法（声明对象时的预设方案），获取与修改方法（获取或修改属性值）和展示方法（展示对象的属性值）。

```java
public class Test {
    /**
    * 对象的属性
    */
    private int name;

    /**
    * 对象的构造方法
    */
    public Test() {
    }

    public Test(int name) {
        this.name = name;
    }

    /**
    * 对象的获取与修改方法
    */
    public int getName() {
        return name;
    }

    public void setName(int name) {
        this.name = name;
    }

    /**
    * 对象的展示方法
    */
    @Override
    public String toString() {
        return "BuyPlaneTicket{" +
                "name=" + name +
                '}';
    }
}
```

​	有了模板，创建时用上就行。

​	对象一定要实例化才能用，要不然就是个图纸罢了。

​	当声明对象时，会在堆内存中开一个专属于这个对象的地方。

​	这个对象名保存的就是指向这个地方的地址。

​	每次声明对象时都会开一个全新区域，哪怕使用了同一个实体类（蓝图）。

```java
// 对象类名 对象名 = new 对象类名();
```

​	一般来说，若一个被声明的对象没有任何东西指向它时，Java 的垃圾回收机制会自己把它删掉。

## 4.构造器

​	就是上面创建实体类时，里面加的构造方法。

​	当声明对象时，就会自动调用构造器来构造一个新的对象。

​	除了直接声明一个空白对象（有属性，但没有属性值），也可以声明一个有值对象。

​	只需要在蓝图内重载一个包含属性值的构造方法就行。

​	 如果不加构造器，默认还是会给一个无参构造器的。

​	但如果有了一个有参构造器，那么就不会有自动加的无参构造器了。

​	这是若需要声明空白对象就要手动加一个无参构造器了。

```java
Test t = new Test(); 
// 相当于调用了
public Test() {
}

Test t = new Test(1, "name"); 
// 相当于调用了
public Test(int id, String name) {
    this.id = id;
    this.name = name;
}
```

## 5.成员变量与局部变量

​	主要有五个区别：

| 区别     | 成员变量     | 局部变量             |
| -------- | ------------ | -------------------- |
| 类位置   | 类中或方法外 | 方法中               |
| 初始化值 | 有默认值     | 无默认值，需手动赋值 |
| 内存位置 | 堆内存       | 栈内存               |
| 作用域   | 整个对象     | 所属大括号内         |
| 生命周期 | 和对象一起死 | 和方法一起死         |

## 6.小结：展示与查询

​	创建一个学生类，包含学号，姓名，年龄与性别。

​	初始化三个学生对象存入数组。

​	控制台展示所有学生对象的所有信息。

​	输入学号显示目标学生对象的所有信息。

```java
// 学生对象
public class Stu {
    private int id;
    private String name;
    private int age;
    private String sex;

    public Stu() {
    }

    public Stu(int id, String name, int age, String sex) {
        this.id = id;
        this.name = name;
        this.age = age;
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Objeckt{" +
                "id=" + id +
                ", name='" + name + '\'' +
                ", age=" + age +
                ", sex='" + sex + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }
}
```

```java
// Main方法
public static void main(String[] args) {
    ObjectClass[] ObjectClass = new ObjectClass[]{
        new ObjectClass(1, "nameA", 12, "男"),
        new ObjectClass(2, "nameB", 13, "男"),
        new ObjectClass(3, "nameC", 14, "女")
    };
    for(Object o : ObjectClass) {
        System.out.println(o.toString());
    }
    Scanner scanner = new Scanner(System.in);
    int id = scanner.nextInt();
    for(int i = 0; i < ObjectClass.length; i++) {
        if (ObjectClass[i].getId() == id) {
            System.out.println(ObjectClass[i].toString());
        }
    }
}
```

# 9，普通的常用 API

## 1.包

​	可以简单理解成文件夹。

​	用于分类管理不同的程序或功能，有利于项目的搭建与后续管理。

​	en，话说创建包的语法我是不知道的。

​	毕竟被 IDEA 之类的编译器惯坏了，图形化界面点一点就好了。

​	包之间的相互调用有四种情况：

​	若调用同一个包内的东西，直接调。

​	若调用其它包内的东西，需先导包再调。

​	若调用 Java 提供的包，也需要先导包再调。

​	若调用多个包，每个包都导入就行。

​	一般来说调用了一个 A 包，其中的 A-1，A-2 之类的子包都会被一起导入。

## 2.String字符串

​	一般来说，所有用双引号包裹的全都算是 String 引用数据类型（也算是一个对象）。

​	给变量定义数据类型时，同时也算是创建了一个对象。

​	除了直接声明变量，既然是对象，那么当然也能调用构造方法声明。

```java
// 传入字符串创建 
String a = "a";

// 空声明
String b = new String();

// 传入字符数组创建
char[] chars = {'1', '2', '3'};
String c = new String(chars);

// 传入字节数组创建
byte[] bytes = {97, 98, 99};
String d = new String(bytes);
```

​	然后就是一堆常用方法。

​	其中特别指出，对比字符串时最好用内置方法。

​	`==` 对比的是地址，基本数据类型可以随便用。

​	字符串这玩意用内置的 equals 方法。

```java
// public int length()，获取字符串长度（字符个数）
String str = "hello";
int length = str.length();
System.out.println("字符串长度: " + length); // 输出：5

// public char charAt(int index)，获取指定索引的字符
String str = "hello";
char c = str.charAt(0);
System.out.println("索引 0 的字符: " + c); // 输出：h

// public char[] toCharArray()，将字符串转为字符数组
System.out.print("字符数组内容: ");
for (char c : charArray) {
    System.out.print(c + " "); // 输出：h e l l o
}

// public String substring(int beginIndex, int endIndex)，按照区间截取字符串（取前不取后）
String str = "Hello World";
String sub = str.substring(6, 11); // 索引从 0 开始，取 6 到 10（不包含 11）
System.out.println("截取的字符串: " + sub); // 输出：World

// public String substring(int beginIndex)，从指定下标开始截取至末尾
String str = "Hello World";
String sub = str.substring(6); // 从索引 6 开始截取
System.out.println("截取的字符串: " + sub); // 输出：World

// public String replace(CharSequence target, CharSequence replacment)，替换字符
String str = "hello world";
String replaced = str.replace("world", "Java");
System.out.println("替换后的字符串: " + replaced); // 输出：hello Java

// public boolean contains(CharSequence s)，是否包含指定字符
String str = "hello";
boolean contains = str.contains("ll");
System.out.println("是否包含 'll': " + contains); // 输出：true

// public boolean startsWith(String prefix)，是否以指定字符开始
String str = "Hello World";
boolean startsWith = str.startsWith("Hello");
System.out.println("是否以 'Hello' 开头: " + startsWith); // 输出：true

// public String[] split(String regex)，按照指定字符分割
System.out.print("分割后的数组内容: ");
for (String part : parts) {
    System.out.print(part + " "); // 输出：apple banana cherry
}

// public boolean equals(Object anObject)，对比字符串
String str1 = "Hello, World!";
String str2 = "Hello, World!";
boolean result1 = str1.equals(str2); // 输出: true
```

​	注意 String 是不可变字符串。

​	就是说每次截断拼接等看似发生变化的操作，实际上是创建了一个新的 String 对象。

​	声明类型赋值的方式创建的字符串变量会被保存到字符串常量池，若有相同内容的字符串则只保存一个。

​	但若使用 new 声明的字符串对象，是会被保存到堆内存中。

## 3.ArrayList集合

​	类似数组，可变数组。

​	数组定义完长度后就不能动了。

​	集合可以随时添加或删除内容，长度会自己适应。

​	且集合属于泛型类，可以接收不同类型的数据（泛型类下面会讲）。

```java
// public ArrayList(),直接声明没啥特殊的
ArrayList name = new ArrayList<>();
```

​	然后就是常用方法。

```java
// public boolean add(E e)，将元素添加至末尾
List<String> list = new ArrayList<>();
list.add("Element1"); // 在列表末尾添加元素
list.add("Element2");
System.out.println(list); // 输出: [Element1, Element2]

// public void add(int index, E element)，在指定位置插入元素
List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element3");
list.add(1, "Element2");
System.out.println(list); // 输出: [Element1, Element2, Element3]

// public E get(int index)，返回指定位置的元素
List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element2");
String element = list.get(1);
System.out.println(element); // 输出: Element2

// public int size()，返回集合元素数量
List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element2");
int size = list.size();
System.out.println("List size: " + size); // 输出: List size: 2

// public E remove(int index)，删除指定位置的元素并返回这个元素
List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element2");
list.add("Element3");
String removedElement = list.remove(1);
System.out.println(removedElement); // 输出: Element2
System.out.println(list); // 输出: [Element1, Element3]

// public boolean remove(Object o)，删除指定位置的元素并返回是否删除成功
 List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element2");
boolean isSuccess = list.remove("Element2");
System.out.println("Is removal successful? " + isSuccess); // 输出: Is removal successful? true
System.out.println(list); // 输出: [Element1]

// public E set(int index, E element)，修改指定位置的元素并返回被修改的元素
List<String> list = new ArrayList<>();
list.add("Element1");
list.add("Element2");
String oldElement = list.set(1, "NewElement");
System.out.println("Old element: " + oldElement); // 输出: Old element: Element2
System.out.println(list); // 输出: [Element1, NewElement]
```

## 4.小结：控制台登录，生成验证码，购物车

​	预设账号密码：admin / 123。

​	最多输入3次。

```java
public static void main(String[] args) {
    String name = "admin";
    String pass = "123";
    int num = 3;
    boolean flag = true;
    Scanner scanner = new Scanner(System.in);
    while (flag) {
        if (num == 0) {
            System.out.println("没机会了");
            break;
        }
        System.out.println("输入账号");
        String inName = scanner.next();
        if (!inName.equals(name)) {
            System.out.println("账号错误");
            System.out.println("还有" + (num - 1) + "次");
            num--;
            continue;
        }
        System.out.println("输入密码");
        String inPass = scanner.next();
        if (!inPass.equals(pass)) {
            System.out.println("密码错误");
            System.out.println("还有" + (num - 1) + "次");
            num--;
            continue;
        }
        System.out.println("登录成功");
        break;
    }
}
```

​	生成4位数验证码。

​	包含数字和大小写字母。

​	使用定义的字符串内的字符生成验证码。

​	定义字符串：`String data = "0123456789abcABC`。

```java
public static void main(String[] args) {
    String data = "0123456789abcABC";
    String code = "";
    Random random = new Random();
    for (int i = 0; i < 4; i++) {
        code += data.charAt(random.nextInt(data.length()));
    }
    System.out.println(code);
}
```

​	预设购物车有点东西。

​	实现添加或删除商品。

```java
ArrayList car = new ArrayList<>();
boolean flag = true;
Scanner scanner = new Scanner(System.in);
 while (flag) {
     System.out.println("1.检查购物车 2.添加商品 3.删除商品");
     String index = scanner.next();
     switch (index) {
         case "1":
             for (Object name : car) {
                 System.out.println(name);
             }
             break;
         case "2":
             System.out.println("新商品名");
             String newName = scanner.next();
             car.add(newName);
             break;
         case "3":
             System.out.println("要删除的商品名");
             String delName = scanner.next();
             for (int i = 0; i < car.size(); i++) {
                 if (car.get(i).equals(delName)) {
                     car.remove(i);
                 }
             }
             break;
     }
 }
```

# 10.阶段案例

## 1.ATM

​	一个提款机（挺假的）。

​	账户包含用户名，密码与余额即可。

​	使用对象创建。

​	使用集合保存所有用户对象。

​	实现开户，销户，登录，退出，存款，取款，转账，修改密码。

​	所有功能须在登陆后操作。

```java
// 用户对象
public class User {
    private String name;
    private int pass;
    private int deposit;

    public User() {
    }

    public User(String name, int pass, int deposit) {
        this.name = name;
        this.pass = pass;
        this.deposit = deposit;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getPass() {
        return pass;
    }

    public void setPass(int pass) {
        this.pass = pass;
    }

    public int getDeposit() {
        return deposit;
    }

    public void setDeposit(int deposit) {
        this.deposit = deposit;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", pass=" + pass +
                ", deposit=" + deposit +
                '}';
    }
}
```

```java
// main方法
import java.util.ArrayList;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        // 初始化
        ArrayList<User> users = new ArrayList<>();
        Scanner input = new Scanner(System.in);
        boolean flag = true;
        User currentUser = null; // 当前登录的用户

        // 主循环
        while (flag) {
            // 主页面
            if (currentUser == null) {
                System.out.println("1. 登录 2. 注册 3. 退出");
            } else {
                System.out.println("1. 存款 2. 取款 3. 转账 4. 修改密码 5. 销户 6. 退出");
            }
            String loginInputCheck = input.next();

            // 登录
            if (loginInputCheck.equals("1") && currentUser == null) {
                System.out.println("请输入用户名：");
                String name = input.next();
                System.out.println("请输入密码：");
                int pass = Integer.parseInt(input.next());
                // 遍历用户组检查匹配情况
                for (User user : users) {
                    if (user.getName().equals(name) && user.getPass() == pass) {
                        currentUser = user;
                        System.out.println("登录成功，当前用户：" + currentUser.getName());
                        break;
                    }
                }
                if (currentUser == null) {
                    System.out.println("用户名或密码错误");
                }
            }
            // 注册
            else if (loginInputCheck.equals("2") && currentUser == null) {
                System.out.println("请输入用户名：");
                String name = input.next();
                System.out.println("请输入密码：");
                int pass = Integer.parseInt(input.next());
                // 添加用户对象至用户组
                users.add(new User(name, pass, 0));
                System.out.println("注册成功，当前用户：" + name);
            }
            // 退出
            else if (loginInputCheck.equals("3") && currentUser == null) {
                System.out.println("退出系统");
                flag = false;
            }
            // 存款
            else if (loginInputCheck.equals("1") && currentUser != null) {
                System.out.println("请输入存款金额：");
                int amount = Integer.parseInt(input.next());
                currentUser.setDeposit(currentUser.getDeposit() + amount);
                System.out.println("存款成功，当前余额：" + currentUser.getDeposit());
            }
            // 取款
            else if (loginInputCheck.equals("2") && currentUser != null) {
                System.out.println("请输入取款金额：");
                int amount = Integer.parseInt(input.next());
                if (currentUser.getDeposit() >= amount) {
                    currentUser.setDeposit(currentUser.getDeposit() - amount);
                    System.out.println("取款成功，当前余额：" + currentUser.getDeposit());
                } else {
                    System.out.println("余额不足，取款失败");
                }
            }
            // 转账
            else if (loginInputCheck.equals("3") && currentUser != null) {
                System.out.println("请输入接收方用户名：");
                String targetName = input.next();
                System.out.println("请输入转账金额：");
                int amount = Integer.parseInt(input.next());
                User targetUser = null;
                for (User user : users) {
                    if (user.getName().equals(targetName) && user != currentUser) {
                        targetUser = user;
                        break;
                    }
                }
                if (targetUser != null && currentUser.getDeposit() >= amount) {
                    currentUser.setDeposit(currentUser.getDeposit() - amount);
                    targetUser.setDeposit(targetUser.getDeposit() + amount);
                    System.out.println("转账成功，当前余额：" + currentUser.getDeposit());
                } else {
                    System.out.println("转账失败");
                }
            }
            // 修改密码
            else if (loginInputCheck.equals("4") && currentUser != null) {
                System.out.println("请输入新密码：");
                int newPass = Integer.parseInt(input.next());
                currentUser.setPass(newPass);
                System.out.println("密码修改成功");
            }
            // 销户
            else if (loginInputCheck.equals("5") && currentUser != null) {
                users.remove(currentUser);
                currentUser = null;
                System.out.println("销户成功");
            }
            // 退出
            else if (loginInputCheck.equals("6") && currentUser != null) {
                System.out.println("退出系统");
                currentUser = null;
            }
            // 其他输入
            else {
                System.out.println("无效输入，请重新选择");
            }
        }
    }
}
```

# 11，面向对象高级编程

## 1.static静态修饰符

​	和 `public` 和 `private` 一样，都是修饰符。

​	用来定义变量，方法或类等玩意的访问级别。

​	前面用到的 `public` 是公开访问，随便哪里的什么人都能用到。

​	`private` 是私有访问，只有一个类里面的才能用到。

​	而 `static` 就不一样了。

​	首先，它修饰类中的变量时，这个变量是共享的。

​	没有用它修饰的话，每个对象的相同属性就都是独立的。

```java
// User类
public class User {
    // 类变量，属于这个类（不管这个类炸出了多少衍生对象）
    // 与类一起加载，且只有一个，被这个类与所有衍生自这个类的对象共同访问
    static String name;
    
    // 实例变量，属于对象
    // 每个对象的实例变量都是独立存在的，互不干扰
   int age;
}
```

```java
// main方法
public class Main {
    public static void main(String[] args) {
        // 类变量
        User.name = "A";

        // 对象变量
        User u1 = new User();
        u1.name = "B";
        
        User u2 = new User();
        u2.name = "C";
        
        // 因为这个name字段被static修饰过，所以不管用哪种方法，只要来自这个类，那它就是共享的
        System.out.println(u1.name); // 输出C
        System.out.println(u2.name); // 输出C
        System.out.println(User.name); // 输出C
        
        // age字段没有被static修饰，所以只能有被声明的对象访问各自的age
        u1.age = 23;
        u2.age = 18;
        System.out.println(u1.age); // 输出23
        System.out.println(u2.age); // 输出18
        System.out.println(User.age); // 写出来就会报错，因为User类中没有公共的age变量
    }
}
```

​	例如，有某个数据，需要保证唯一性，且还能够被共享修改等。

​	那么就可以用类变量保存。

​	如，让用户类保存这个项目一共被声明了多少用户对象（统计注册用户数量）。

​	然后，还能用于修饰方法。

​	被修饰的方法属于了类方法，属于这个类。

​	没有被修饰的就是实例方法，任何对象都能动。

```java
// Student类
public class Student {
    double score;

    // 类方法
    public static void printStrA() {
        System.out.println("A");
    }

    // 实例方法
    public void printStrB() {
        System.out.println("成绩：" + score);
    }
}
```

```java
// main方法
public static void main(String[] args) {
    Student.printStrA();

    Student student = new Student(); // 输出A
    student.printStrA(); // 输出A

    student.printStrB(); // 输出成绩：0.0
    Student.printStrB(); // 也是写出来就报错，不是静态的类方法
}
```

​	类方法最常用的地方就是作为工具类的方法，方便任意地方调用。

​	实例方法需要创建对象进行调用，数量较多时也会浪费性能。

​	而类方法应为直接用类名调用，又方便又节省开销。

​	而工具类又是啥？

​	就是用来服务其它类，给它们提供公共方法的东西。

```java
// 工具类，里面有一个求和方法
public class Student {
    public static int sum(int a, int b) {
        return a + b;
    }
}
```

```java
// mian方法（或其它地方），调用工具方法
public static void main(String[] args) {
    System.out.println(Student.sum(1, 2));
}
```

​	还有些注意事项。

​	类方法可以访问类成员，但不能直接访问实例成员。

​	实例方法均可访问。

​	实例方法可以使用 `this` 关键字，而类方法不行。

​	还有代码块（傻鸟 static，越写越多）。

​	类有五个成员：成员变量，构造器，方法，代码块和内部类。

​	成员变量就是属性字段。

​	构造器，方法啥的也是都用过了。

​	内部类不急。

​	先讲代码块。

​	分为静态代码块的实例代码块。

​	静态代码块使用 `static` 关键字实现。

​	类加载时会一起加载，且只加载一次。

​	初始化时可以用。

​	实例代码块就是创建对象时执行，且先于构造器执行。

​	用于对象初始化。

```java
// 某个类
public class Student {
    static int num = 10;
    // 静态代码块
    static {
        System.out.println("static");
    }
    // 实例代码块
    {
        System.out.println("normal");
    }
}
```

```java
// mian方法
public static void main(String[] args) {
    // 调用类变量，使类加载
    System.out.println(Student.num);

    // 声明类实例（创建对象）
    Student student = new Student();
}
```

## 2.设计原则和设计模式

​	傻鸟 `static` 终于结束了。

​	但没完全结束。

​	有一个问题，可以有很多种解决方法。

​	但总会有一个最优解法，这个最优解法就是设计模式。

​	似乎有二十几种，对应二十几个不同情况和问题的理论最优解。

​	就拿单例模式举例，它意在确保一个类只有一个对象。

​	构造器私有，定义一个类变量保存这个类的唯一实例，定义类方法返回这个唯一实例。

```java
// 这就是一个单例模式下的类
public class Student {
    // 类变量保存唯一类实例
    private static Student stu = new Student();

    // 私有构造方法，避免被外部实例
    private Student() {}

    // 公开获取唯一实例的类方法
    public static Student getStudent() {
        return stu;
    }
}
```

​	而单例模式又能细分，如饿汉式单例（获取类对象前已经创建完唯一实例了）或懒汉式单例（获取对象后才创建唯一实例）等。

​	单例模式一般用在如任务管理器，获取运行时对象之类的情况。

​	可以避免内存浪费。

​	上面的例子就是饿汉式单例的简单示例。

在设计模式前还有一个设计原则。

用于指导，明确面向对象的理念。

- 单一职责原则
  - 一个类或方法应该，只能由一个引起它变化的原因。
  - （事不关己高高挂起，管那么多干嘛）。
- 开闭原则
  - 类，模块，函数等应该对于扩展开放，对于修改封闭。
  - 建议通过抽象或接口进行扩展，而不是改代码。
- 依赖倒置原则
  - 调用者不能依赖被调用者。
  - 且任何类应该依赖接口或抽象，不能依赖实现。
- 里式替换原则
  - 子类可以接替父类的工作，且不会出问题。
- 接口隔离原则
  - 不能强迫依赖用不上的接口。
  - （需要啥就拿啥，没用的没必要拿，尤其不允许瑞士军刀接口的出现）。

这是第一版。

1. **单一职责原则**

- **问题**：`Triangle`类继承自`Graphics`类，但`Triangle`类本身又作为`EquilateralTriangle`和`IsoscelesTriangle`的父类。这种设计可能导致`Triangle`类的职责不清晰。
- **改进建议**：`Triangle`类应该是一个具体的图形类，而不是其他三角形类的父类。如果需要区分不同类型的三角形，可以直接让`EquilateralTriangle`和`IsoscelesTriangle`继承自`Graphics`类。

2. **开闭原则**

- **问题**：代码中没有使用工厂模式或其他设计模式来创建图形对象，导致每次添加新的图形类型时，都需要修改客户端代码（如`Main`类）。
- **改进建议**：引入一个图形工厂类，用于创建具体的图形对象，这样可以避免修改现有代码。

3. **依赖倒置原则**

- **问题**：`Main`类直接依赖具体的图形类（如`Circular`、`Square`等），而不是依赖抽象。
- **改进建议**：`Main`类应该依赖`Graphics`抽象类，而不是具体的实现类。

4. **里式替换原则**

- **问题**：`Triangle`类继承自`Graphics`类，但`Triangle`类本身没有实现任何逻辑，而`EquilateralTriangle`和`IsoscelesTriangle`类也没有覆盖`draw`方法。这可能导致行为不一致。
- **改进建议**：确保所有子类都正确实现`draw`方法，或者让`Triangle`类成为一个抽象类。

5. **接口隔离原则**

- **问题**：`Graphics`类中的`draw`方法是`void`类型，没有返回值，这可能会限制扩展性。
- **改进建议**：可以考虑让`draw`方法返回一个结果，或者提供更细粒度的接口。

 [Circular.java](设计原则案例\第一版\Circular.java) 

 [EquilateralTriangle.java](设计原则案例\第一版\EquilateralTriangle.java) 

 [Graphics.java](设计原则案例\第一版\Graphics.java) 

 [IsoscelesTriangle.java](设计原则案例\第一版\IsoscelesTriangle.java) 

 [Main.java](设计原则案例\第一版\Main.java) 

 [Square.java](设计原则案例\第一版\Square.java) 

 [Triangle.java](设计原则案例\第一版\Triangle.java) 

然后是第二版。

 [Circular.java](设计原则案例\第二版\Circular.java) 

 [EquilateralTriangle.java](设计原则案例\第二版\EquilateralTriangle.java) 

 [Graphics.java](设计原则案例\第二版\Graphics.java) 

 [IsoscelesTriangle.java](设计原则案例\第二版\IsoscelesTriangle.java) 

 [Main.java](设计原则案例\第二版\Main.java) 

 [ShapeFactory.java](设计原则案例\第二版\ShapeFactory.java) 

 [Square.java](设计原则案例\第二版\Square.java) 

 [Triangle.java](设计原则案例\第二版\Triangle.java) 

## 3.继承

​	用关键字 `extends` 实现。

​	继承可以让两个类建立所谓父子关系。

​	子类可以继承父类的非私有成员（成员变量或成员方法）。

​	若一个类继承了别的类，创建这个子类对象时。

​	除了子类自己的成员，还会包含父类的成员。

​	最后产生的对象可以访问哪些成员由成员是否公开决定（父类中的私有成员也会获取到，只是不能用）。

​	注意 Java 中继承是只允许垂直多重继承，不支持水平多重继承。

​	就是说，你可以有爸爸，有爷爷，有曾爷爷。

​	但不能有两个爸爸，三个妈妈啥的。

​	顺便提一嘴 Object 类（所有类的父类）。

```java
// 父类
public class A {
    // 公有变量
    public int i;
    // 公有方法
    public void print1() {
        System.out.println("print1");
    }
    
    // 私有变量
    private int j;
    // 私有方法
    private void print2() {
        System.out.println("print2");
    }
}
```

```java
// 子类，继承父类，享有父类的公有成员
public class B extends A{
    // 私有便变量
    private int k;
    // 公有方法
    public void print3() {
        // 调用父类的公有变量
        System.out.println(i);
        // 调用父类的公有方法
        print1();

        // 调用父类的私有变量，报错，拉不到
        System.out.println(j);
        // 调用父类的私有方法，报错，拉不到
        print2();
    }
}
```

```java
// main方法
public static void main(String[] args) {
    // 实例子类
    B b = new B();
    
    // 调用子类获得的父类的公有变量，输出0
    System.out.println(b.i);
    // 调用子类获得的父类的公有方法，输出print1
    b.print1();
    
    // 调用父类的私有方法，报错，拉不到
    b.print2();
    // 调用子类自己的公有方法，输出0，print1
    b.print3();
}
```

​	举一个使用例子。

​	如有个学校用的哔哩吧啦系统。

​	其中有老师账户和学生账户。

​	虽然说两个账户权限功能有不同。

​	但是如姓名，年龄，性别等基本信息是相同的。

​	所以就可以创建一个 ‘ 人类 ’ 父类。

​	再创建两个子类代表学生和老师。

​	继承这个人类父类，就能共享姓名，年龄，性别等基本字段了。

​	子类中只需要写自己特有的字段或方法了。

​	总而言之，使用继承还是为了减少重复代码，提升复用性。

​	（听都听烦了不是吗，写代码基本就是围绕着复用性啊，可维护性啊，降低耦合啊这些玩意巴拉巴拉）。

## 4.权限修饰符（就是上面一直提到的修饰符）

​	终于到这玩意了是吧。

​	用着这么久，也算是到它了。

​	权限修饰符就是用来定义成员的可访问权限的。

​	一般就四种。

​	`private` 私有修饰，只允许本类访问。

```java
class PrivateExample {
    private int privateVar = 10; // 私有变量

    private void privateMethod() { // 私有方法
        System.out.println("This is a private method.");
    }
}

public class AccessModifierExample {
    public static void main(String[] args) {
        PrivateExample example = new PrivateExample();
        // example.privateVar = 20; // 错误：无法访问私有变量
        // example.privateMethod(); // 错误：无法访问私有方法
    }
}
```

​	不修饰，在前基础上增大到同包内访问。

```java
// 文件：DefaultExample.java
class DefaultExample {
    int defaultVar = 20; // 默认访问权限变量

    void defaultMethod() { // 默认访问权限方法
        System.out.println("This is a default method.");
    }
}

// 文件：SamePackageExample.java（同一包内）
import java.util.Scanner;

public class SamePackageExample {
    public static void main(String[] args) {
        DefaultExample example = new DefaultExample();
        example.defaultVar = 30; // 正确：同一包内可以访问
        example.defaultMethod(); // 正确：同一包内可以访问
    }
}

// 文件：DifferentPackageExample.java（不同包内）
// import SamePackage.DefaultExample; // 无法导入，因为默认访问权限不能跨包
```

​	`protected` 家族修饰？？？在前基础上增大到任意包下的子类内访问。

```java
// 父类
class Parent {
    protected int protectedVar = 30; // 受保护变量

    protected void protectedMethod() { // 受保护方法
        System.out.println("This is a protected method.");
    }
}

// 子类（同一包内）
class Child extends Parent {
    public void accessProtected() {
        System.out.println(protectedVar); // 正确：子类可以访问父类的 protected 成员
        protectedMethod(); // 正确：子类可以访问父类的 protected 成员
    }
}

// 子类（不同包内）
// 文件：DifferentPackageChild.java
import SamePackage.Parent;

class DifferentPackageChild extends Parent {
    public void accessProtected() {
        System.out.println(protectedVar); // 正确：子类可以访问父类的 protected 成员
        protectedMethod(); // 正确：子类可以访问父类的 protected 成员
    }
}

// 测试类
public class AccessModifierExample {
    public static void main(String[] args) {
        Child child = new Child();
        child.accessProtected(); // 正确：子类可以访问父类的 protected 成员

        DifferentPackageChild dpChild = new DifferentPackageChild();
        dpChild.accessProtected(); // 正确：不同包的子类也可以访问父类的 protected 成员
    }
}
```

​	`public` 公有修饰，在前基础上增大到任意包的任意类内访问。

```java
// 文件：PublicExample.java
public class PublicExample {
    public int publicVar = 40; // 公有变量

    public void publicMethod() { // 公有方法
        System.out.println("This is a public method.");
    }
}

// 文件：DifferentPackageExample.java（不同包内）
import SamePackage.PublicExample;

public class DifferentPackageExample {
    public static void main(String[] args) {
        PublicExample example = new PublicExample();
        example.publicVar = 50; // 正确：不同包内可以访问公有变量
        example.publicMethod(); // 正确：不同包内可以访问公有方法
    }
}
```

​	(累了，不想写案例的，偷个懒让AI来写案例（就这一次！）)。

​	一般也就用私有和公有罢了。

## 5.方法重写和重载

​	父类的方法不好用，或是根本没用，可以重写一下。

​	能把父类继承下来的没用玩意覆盖修改成有用的好东西。

​	方法重写要用 `@Override` 关键字。

​	且重写的方法的可访问性必须大于等于重写的父方法。

​	而返回值范围必须小于等于父方法。

​	私有和静态方法不能重写。

```java
// 父类
public class Animal {
    // 父类的方法
    public void makeSound() {
        System.out.println("The animal makes a sound.");
    }
}
```

```java
// 子类
public class Dog extends Animal {
    // 重写父类的方法
    @Override
    public void makeSound() {
        System.out.println("The dog barks.");
    }
}
```

```java
// main方法
public class Main {
    public static void main(String[] args) {
        // 创建父类对象
        Animal animal = new Animal();
        animal.makeSound(); // 输出：The animal makes a sound.

        // 创建子类对象
        Dog dog = new Dog();
        dog.makeSound(); // 输出：The dog barks.

        // 多态示例
        Animal animal2 = new Dog();
        animal2.makeSound(); // 输出：The dog barks.
    }
}
```

​	一般较为常用的就是重写 `toString()`  方法。

​	这个方法一般用于输出对象的所有成员变量。

​	通过重写子类的 `toString()` 方法，可以输出子类自己的成员变量搭配。

​	在访问方法时，一般依照就近原则使用。

​	如调用了一个方法 A，先在子类局部寻找，没有就去子类成员寻找。

​	还是没有跑到父类看看有没有，再没有就报错，全家都没这玩意。

​	若子类和父类有重名成员，优先使用子类的。

​	上面一大堆都是描述重写。

​	还有个重载。

​	重写就是方法名，参数个数，参数类型，返回值类型均相同。

​	重载就是方法名相同，但参数个数或参数类型不同即可。

## 6.super关键字

​	有一种情况就是，如果一定要用父类的成员怎么办？

​	那就用 `super` 关键字指定父类成员。

```java
// 父类
class Parent {
    String name = "Parent";
}

// 子类
class Child extends Parent {
    String name = "Child";

    public void printName() {
        System.out.println("子类变量: " + name); // 访问子类变量
        System.out.println("父类变量: " + super.name); // 访问父类变量，这里指定使用父类的name
    }
}

// main方法
public class Main {
    public static void main(String[] args) {
        Child child = new Child();
        child.printName();
    }
}
```

## 7.子类构造器特点

​	当这个类是某个类的子类时，它的构造器会有点不同。

​	首先就是它会优先调用父类的构造器，，然后才是自己的。

​	且子类构造器默认第一行都有 `super()`  ，没有手动添加也会默认存在。

​	用于调用父类的无参构造器，保证父类优先正常加载。

​	若父类没有无参构造器，那么就要在 `super(...)` 这里面手写调用父类的有参构造器。

​	反正就是要保证父类的优先加载。

```java
public class Parent {
    public Parent() {
        System.out.println("Parent's no-argument constructor");
    }

    public Parent(String name) {
        System.out.println("Parent's constructor with argument: " + name);
    }
}
```

```java
public class Child extends Parent {
    public Child() {
        // 默认调用父类的无参数构造器
        System.out.println("Child's no-argument constructor");
    }

    public Child(String name) {
        super(name); // 显式调用父类的有参数构造器
        System.out.println("Child's constructor with argument: " + name);
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        Child child1 = new Child(); // 调用子类的无参数构造器
        Child child2 = new Child("Child"); // 调用子类的有参数构造器
    }
}
```

## 8.this关键字

​	`this` 存在于对象蓝图，就是实体类中时，指向的就是这个对象本身。

​	使用了哪个对象的 `this` 就会获取到哪个对象（引用当前对象）。

​	可以解决比如对象名和对象方法名冲突的问题。	

​	若当前类继承了别的类，当自己没有时会跑到父类找找。

```java
public class Test {
    ...
    public void printThisObject() {
        System.out.println(this);
    }
}
```

```java
public static void main(String[] args) {
    Test t = new Test();
    t.printThisObject(); // 输出这个对象（一般会喷哈希码）
}
```

​	上面的 `super()` 用于调用父类的成员，这个 `this()` 除了用自己的和父类的，还能用于调用子类的兄弟成员。

```java
public class Student {
    private String schoolName;
    private String name;

    // 构造器1：调用构造器2
    public Student(String name) {
        this(name, "黑马程序员"); // 调用构造器2
    }

    // 构造器2：初始化所有成员变量
    public Student(String name, String schoolName) {
        this.name = name;
        this.schoolName = schoolName;
    }
}
```

​	注意这俩都要放在第一行，所以不能同时存在。

​	（虽然吧，`super()` 和 `this()` 到目前为止我是很少用的）。

## 9.多态

​	这玩意是在继承或实现的情况下的一种现象（包括重写与重载）。

​	可以是对象多态，也能是行为多态（不包括变量（它做不到））。

​	达成多态的前提是至少存在继承关系，实现关系，父类使用子类对象，存在方法重写中的其中一个情况。

​	一样的东西，不同的情况，出现不同的结果。

```java
// 两种不同的对 Color 类的实现
Color red = new Red();
Color blue = new Blue();
```

​	多态可以更好的实现解耦的需求。

​	可以增强扩展性。

​	并且使用父类类型的变量作为方法的形参时，可以接收一切子类对象。

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

class Cat extends Animal {
    public void meow() {
        System.out.println("Cat is meowing");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // 父类引用指向子类对象
        animal.eat(); // 调用父类方法

        animal = new Cat(); // 父类引用指向另一个子类对象
        animal.eat(); // 调用父类方法
    }

    public static void showAnimal(Animal animal) {
        animal.eat(); // 可以接收任何子类对象，并调用父类方法
    }
}
```

​	但是多态下不能直接调用子类的独有方法。

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // 父类引用指向子类对象
        animal.eat(); // 调用父类方法
        // animal.bark(); // 错误：Cannot invoke bark() on the instance of type Animal
    }
}
```

​	如果就是要调用子类的独有方法，倒是可以强制转换为子类引用。

​	这就算是下面对象转换的内容了。

```java
class Animal {
    public void eat() {
        System.out.println("Animal is eating");
    }
}

class Dog extends Animal {
    public void bark() {
        System.out.println("Dog is barking");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog(); // 父类引用指向子类对象
        animal.eat(); // 调用父类方法

        if (animal instanceof Dog) { // 检查是否为 Dog 类型
            Dog dog = (Dog) animal; // 强制类型转换
            dog.bark(); // 调用子类独有方法
        }
    }
}
```

## 10.对象转换

​	上面提到了强制转为子类引用。

​	这就属于对象的强制转换。

​	还有一个自动对象转换。

```java
// 自动
// 父类 变量名 = new 子类()
Animal animal = new dog(); 

// 强制
// 子类 变量名 = (子类)父类变量
Dog dog = (Dog)animal;
```

​	注意进行强制转换时，只要存在继承关系或实现关系，那么编译是可以通过的。

​	但如果运行时发现对象的真实类型和强转后的类型不同，就会直接在运行时炸类型转换异常。

​	你也不想看报错吧，所以可以先检查一下嘛。

​	用 `instanceof` 就可以检查对象类型了。

```java
if (animal instanceof Dog) { // 检查是否为 Dog 类型
    Dog dog = (Dog) animal; // 强制类型转换
    dog.bark(); // 调用子类独有方法
}
```

## 11.final修饰符与常量

​	使用 `final` 修饰。

​	代表这是最终版，不会再动了（也不能再动了）。

​	可以修饰类，方法或变量。

​	被修饰的类不可被继承。

​	被修饰的方法不可被重写。

​	被修饰的变量只能被赋值一次。

```java
// 修饰类
public final class FinalClass {
    // 类的内容
}

// 以下代码会报错，因为 FinalClass 不能被继承
public class SubClass extends FinalClass {
    // 类的内容
}
```

```java
// 修饰方法
public class BaseClass {
    public final void finalMethod() {
        System.out.println("This is a final method.");
    }
}

public class SubClass extends BaseClass {
    // 以下代码会报错，因为 finalMethod() 不能被重写
    @Override
    public void finalMethod() {
        System.out.println("This is an overridden method.");
    }
}
```

```java
// 修饰变量
public class FinalVariableExample {
    public static void main(String[] args) {
        final int finalVariable;
        finalVariable = 10; // 第一次赋值
        // finalVariable = 20; // 错误：Cannot assign a value to final variable finalVariable
        System.out.println(finalVariable);
    }
}
```

​	注意修饰基本数据类型的变量时，变量储存的的数据不能改变。

​	修饰引用类型数据类型的变量时，变量储存的的地址不能改变。

```java
// 禁止数据变化
public class FinalVariableExample {
    public static void main(String[] args) {
        final int finalVariable = 10; // 初始化赋值
        // finalVariable = 20; // 错误：Cannot assign a value to final variable finalVariable
        System.out.println(finalVariable); // 输出：10
    }
}

// 禁止地址变化
public class FinalReferenceExample {
    public static void main(String[] args) {
        final List<String> finalList = new ArrayList<>();
        finalList.add("Element1"); // 允许修改对象内容
        finalList.add("Element2");
        System.out.println(finalList); // 输出：[Element1, Element2]

        // finalList = new ArrayList<>(); // 错误：Cannot assign a value to final variable finalList
    }
}
```

​	然后就是常量。

​	使用 `static final` 修饰的就是常量。

​	比如很后面要连数据库时，数据库的配置可以用常量保存。

​	常量命名建议使用全大写字母，多个单词用 `_` 连接。

​	使用常量记录系统信息可以提供更好的可维护性和可读性。

```java
public class Test {
    // 这个就属于常量
    public static final String FOR_SYSTEM = "13";
}
```

## 12.抽象类

​	也是用修饰符修饰一下。

​	这次是用 `abstract` 来定义。

​	可以定义类，也可以定义方法。

​	啥时候用呢？

​	还是那支付打比方。

​	每种付款方式本质上都一样。

​	但是不同的付款方式有不同的付款流程。

​	使用抽象类定义付款这个行为，用子类实现，去定义不同的独特的流程。

```java
public abstract class Test {
    // 抽象方法不能有方法体（就是不能有'{}'）
    public abstract void methodName();
}
```

​	抽象类中不一定有抽象方法，但有抽象方法的类一定是抽象类。

​	正常类有的东西抽象类全都可以有（成员变量，方法和构造器啥的）。

​	抽象类不能创建对象，只能作为一种特殊父类，让子类实现。

​	一个继承了抽象类的子类，必须实现抽象类包含的所有抽象方法。

​	若不全部实现，这个子类也必须定义为抽象类。

```java
// 抽象类
public abstract class Animal {
    // 成员变量
    private String name;

    // 构造器
    public Animal(String name) {
        this.name = name;
    }

    // 抽象方法
    public abstract void makeSound();

    // 普通方法
    public void eat() {
        System.out.println("Animal is eating");
    }

    // Getter 和 Setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

```java
// 子类
public class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }

    // 实现抽象方法
    @Override
    public void makeSound() {
        System.out.println("Dog barks");
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // 不能创建抽象类的对象
        // Animal animal = new Animal("Animal"); // 错误：Cannot instantiate the type Animal

        // 创建子类对象
        Dog dog = new Dog("Dog");
        dog.makeSound(); // 输出：Dog barks
        dog.eat(); // 输出：Animal is eating
    }
}
```

​	（AI生成案例属实方便）。

​	话说有一种抽象类用的设计模式，叫模板方法。

​	用于解决重复代码的问题。

​	就两个步骤。

​	先定义一个抽象类。

​	然后在里面定义两种方法，模板方法（所有子类公用的）和抽象方法（子类根据需要不同实现的）。

​	注意模板方法建议使用 `final` 修饰，避免被子类拿去玩坏。

## 13.接口

​	使用 `interface` 定义。

​	弥补了单继承的不足，且方便业务功能的切换与修改。

​	其中。

​	抽象方法定义基本行为，必须实现。

​	默认方法定义默认实现，可以选择覆盖。

​	私有方法定义内部辅助功能，不可被访问。

​	静态方法定义内部工具方法，不可被继承或覆盖。

​	这四种方法均默认被 `public` 修饰。

```java
public interface 接口名 {
	// 成员变量（常量）
	// 成员方法（抽象方法，默认方法，私有方法，静态方法）
}
```

​	接口不能创建对象，只能由别的类实现。

​	这个实现接口的类不叫子类，叫实现类。

```java
修饰符 class 实现类名 implements 接口名, ...,接口名 {}
```

​	可以同时实现多个接口，但接口内的抽象方法需全部实现。

​	若没有全部实现，那这实现类就变成抽象类了。

​	注意，抽象类和接口很像，但还是不太一样。

​	抽象类可以创建构造器用于实例，接口不行。

​	抽象类可以包含抽象方法或具体方法，接口只能包含抽象方法，默认方法和静态方法。

​	一个类只能继承一个抽象类，但可以继承多个接口。

​	使用上。

​	需要定义一个标准，表示层次，和定义一组类的共性等情况可以使用抽象类。

​	需要定义一组规范，同时继承实现多组规范，扩展，和预留扩展等情况可以使用接口。

​	还有个要注意的。

​	要避免接口污染。

​	例如某个类实现了某接口，但没有实现这个接口的所有方法（因为不需要）。

​	那么这个接口就算是被污染了。

​	建议推行单一职责原则和接口隔离原则。

​	如给动物行为接口定义了吃睡飞。

​	狗实现了动物行为接口，但狗明显不会飞。

​	这个动物行为接口就算是污染了。

​	咋办？

​	拆开就好了。

​	拆接口又解决的接口污染，又满足了单一职责和接口隔离。

​	不想拆？

​	倒也可以用默认方法（默认方法不强制实现嘛）。

​	但肯定是不如拆接口好的。

​	默认方法给的多了，这个接口也会肿起来的。

## 14.小结：学生信息管理模块

​	请设计一个班级学生的信息管理模块:学生的数据有：姓名、性别、成绩。

​	功能1：要求打印出全班学生的信息。

​	功能2：要求打印出全班学生的平均成绩。

​	需要两套实现方案。

​	第1套方案：能打印出班级全部学生的信息，能打印班级全部学生的平均分。

​	第2套方案：能打印出班级全部学生的信息(包含男女人数)，能打印班级全部学生的平均分(要求是去掉最高分、最低分)

​	且系统可以支持灵活的切换这些实现方案。

```java
// 定义抽象类，描述人的名字与性别
/**
 * 定义人
 * 包含：名字，性别
 */
public abstract class Person {
    private String name;
    private String sex;

    public Person() {
    }

    public Person(String name, String sex) {
        this.name = name;
        this.sex = sex;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSex() {
        return sex;
    }

    public void setSex(String sex) {
        this.sex = sex;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", sex='" + sex + '\'' +
                '}';
    }
}
```

```java
// 定义实现类，实现人，创建学生
/**
 * 定义学生，实现人
 * 包含：成绩
 */
public class Student extends Person {
    private double score;

    public Student() {
    }

    public Student(String name, String sex, double score) {
        super(name, sex);
        this.score = score;
    }

    public double getScore() {
        return score;
    }

    public void setScore(double score) {
        this.score = score;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + getName() + '\'' +
                ", sex='" + getSex() + '\'' +
                "score='" + score + '\'' +
                '}';
    }
}
```

```java
// 定义接口，默认两个方法
/**
 * 定义打印方法
 */
public interface Print {
    /**
     * 打印全部学生信息
     */
    default void printStuMessage(Student[] students) {
        for (Student student : students) {
            System.out.println(student.toString());
        }
    }

    /**
     * 打印全部学生平均分
     */
    default void avgScore(Student[] students) {
        int sum = 0;
        for (Student student : students) {
            sum += student.getScore();
        }
        System.out.println("平均分是：" + sum / students.length);
    }
}
```

```java
// 定义实现类，实现方案A
/**
 * 方案A
 */
public class ProjectA implements Print{
    /**
     * 直接打印全部学生信息
     * 不包括性别
     */
    @Override
    public void printStuMessage(Student[] students) {
        for (Student student : students) {
            System.out.println("Student{" +
                    "name='" + student.getName() + '\'' +
                    "score='" + student.getScore() + '\'' +
                    '}');
        }
    }
}
```

```java
// 定义实现类，实现方案B
/**
 * 方案B
 */
public class ProjectB implements Print{
    /**
     * 直接打印全部学生平均分
     * 去除最高与最低分
     */
    @Override
    public void avgScore(Student[] students) {
        double sum = 0;
        double max = Double.MIN_VALUE;
        double min = Double.MAX_VALUE;
        for (Student student : students) {
            double score = student.getScore();
            sum += score;
            if (score > max) {
                max = score;
            }
            if (score < min) {
                min = score;
            }
        }
        sum -= (max + min);
        double avg = sum / (students.length - 2);
        System.out.println("平均分是：" + avg);
    }
}
```

```java
// 定义主方法，用于执行
import java.util.Map;

public class Test {
    public static void main(String[] args) {
        // 初始化学生
        Student[] students = new Student[] {
            new Student("张三", "男", 50),
            new Student("李四", "男", 90),
            new Student("王五", "男", 40),
            new Student("赵六", "男", 80)
        };

        Print pA = new ProjectA();
        Print pB = new ProjectB();

        System.out.println("A方案");
        pA.printStuMessage(students);
        pA.avgScore(students);

        System.out.println("B方案");
        pB.printStuMessage(students);
        pB.avgScore(students);
    }
}
```

## 15.内部类

​	这回就到内部类咯。

​	到这里类的五个成员算是讲完了。

​	若在某个类肚子里再创建一个类，里面的这个就是内部类。

​	若某个类包含了某个东西，没有大到创建对象，有没有小到创建字段。

​	那么可以把这个不大不小的玩意做成内部类放在这个外部类里。

​	成员内部类依赖于外部类的实例，不能拥有静态成员。

​	静态内部类不依赖外部类的实例，可以拥有静态成员。

​	匿名内部类还算是一个子类，会立刻创建一个子对象。

```java
public class Car {
	// 这玩意是成员内部类，其它类可以在外面获取，一起玩它
	public class Engine {
	}
    
    // 还有这玩意，静态类，属于外部类自己持有的内部类，别的类不能玩它
    public static class Customer {
    }
    
    // 最后就是匿名内部类
    @Override
    public void driver() {}
}
```

​	这个内部类的声明也有点不一样。

```java
// 成员内部类声明方法
// 外部类名.内部类名 对象名 = 外部类名(...).new 内部类名(...);
Car.Engine engine = Car().new Engine();

// 静态内部类声明方法
// 外部类名.内部类名 对象名 = new 外部类名.内部类名();
Car.Customer customer = new Car().Customer();
```

​	这个内部类可以访问外部类的实例或静态成员。

​	还有个不知道啥时有有用的玩法。	

​	可以在成员内部类的实例方法中，获取到当前外部类的对象。

```java
// 外部类名.this
Car.this
```

​	主要还是匿名内部类有点不好理解。

​	一般用于作为参数传给方法。

​	整个类成为参数。

```java
// 声明接口，用于实现打电话
public interface Call {
    void call();
}
```

```java
public class Test {
    public static void main(String[] args) {
        // 声明匿名内部类，这个内部类包含一个方法
        Call c1 = new Call() {
            @Override
            public void call() {
                System.out.println("给A打电话");
            }
        };
        // 执行go方法，将这个匿名内部类传过去
        go(c1);

        // 执行go方法，形参中声明匿名内部类，这个内部类包含一个方法
        go(new Call() {
            @Override
            public void call() {
                System.out.println("给B打电话");
            }
        });
    }

    public static void go(Call c) {
        // 调用接收的类的方法
        c.call();
    }
}
```

## 16.枚举

​	枚举算是一种特殊类。

​	枚举类的第一行一般用来罗列常量，每个常量都属于枚举类的对象。

​	第二行开始可以定义其它成员。

​	枚举类的构造器均为私有，所以做不出对象。

​	枚举类全都为最终类，不可继承。

​	所有枚举类均继承 `java.lang.Enum` 类。

```java
public class Main {
    public static void main(String[] args) {
        // 访问枚举值
        System.out.println(A.x); // 输出：A.x
        System.out.println(A.y); // 输出：A.y
        System.out.println(A.z); // 输出：A.z

        // 遍历枚举值
        for (A a : A.values()) {
            System.out.println(a);
        }

        // 根据名称获取枚举值
        A enumValue = A.valueOf("x");
        System.out.println(enumValue); // 输出：A.x
    }
    
    // 声明枚举类
    public enum A {
    	x, y, z;
	}
}
```

​	枚举类一般用于表示一组常量，如颜色，方向啥的。

```java
public static void main(String[] args) {
    // 遍历枚举中的所有值，使用’枚举名.values()‘时会把枚举类中的枚举值全都干成数组装起来。
    for (Color color : Color.values()) {
        // 打印枚举值，与枚举值的描述信息
        System.out.println(color + ": " + color.getDescription());
    }
}

public enum Color {
    // 枚举值(枚举描述)
    RED("红色"), GREEN("绿色"), BLUE("蓝色");

    // 定义私有不变的值，保存每个枚举值的描述
    private final String description;

    // 构造器，用于初始化每个枚举值的描述字段
    Color(String description) {
        this.description = description;
    }

    // 定义方法，提供外部访问枚举值描述的口子
    public String getDescription() {
        return description;
    }
}
```

​	或者用于实现单例模式。

```java
public enum Singleton {
    INSTANCE;

    public void doSomething() {
        System.out.println("Doing something");
    }
}
```

​	又或者用于实现策略模式（没到设计模式，没听过的化先自己去紧急百度一下）。

```java
public enum Strategy {
    STRATEGY_ONE, STRATEGY_TWO, STRATEGY_THREE;

    public void execute() {
        System.out.println("Executing " + this.name());
    }
}
```

​	且枚举拉出来的值是可以用于如 `for` 或 `switch` 判断的（上面有循环案例了，来个判断案例）。

```java
public enum Color {
    RED, GREEN, BLUE
}

public class Main {
    public static void main(String[] args) {
        Color color = Color.RED;

        switch (color) {
            case RED:
                System.out.println("Red color");
                break;
            case GREEN:
                System.out.println("Green color");
                break;
            case BLUE:
                System.out.println("Blue color");
                break;
        }
    }
}
```

## 17.泛型

​	在定义类，接口或方法时，同时声明了多个类型变量（<E>），这时候就算是泛型了。

​	泛型类，泛型接口或泛型方法都可以叫做达成泛型。

​	泛型提供了在编译阶段约束能操作的数据类型，并自动检查的能力。

​	可以避免强制类型转换与相关异常。

​	本质就是把数据类型最为参数传递给变量（类也可以传递）。

```java
// 修饰符 class 类名<类型变量, ..., 类型变量> {}
public class ArrayList<E> {}
```

​	先是泛型类的例子。

```java
public class Box<E> {
    // 定义一个成员变量，类型为传入类型
    private E content;

    // 构造器
    public Box(E content) {
        this.content = content;
    }

    // 获取值
    public E getContent() {
        return content;
    }

    // 定义值
    public void setContent(E content) {
        this.content = content;
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        // 声明Box类，指定传入为String类型的数据
        Box<String> stringBox = new Box<>("Hello");
        System.out.println(stringBox.getContent()); // 输出：Hello

        // 声明Box类，指定传入为Integer类型的数据
        Box<Integer> integerBox = new Box<>(10);
        System.out.println(integerBox.getContent()); // 输出：10
    }
}
```

​	然后是泛型接口。

```java
public interface Container<E> {
    // 定义抽象方法，接收任意类型的值
    void add(E element);
    // 定义抽象方法，返回这个类型
    E get();
}
```

```java
// 实现泛型接口
public class Box<E> implements Container<E> {
    // 私有成员变量
    private E content;

    // 实现方法，成员变量的值为传入值
    @Override
    public void add(E element) {
        this.content = element;
    }

    // 实现方法，返回成员变量的值
    @Override
    public E get() {
        return content;
    }
}
```

```java
public static void main(String[] args) {
    // 实例泛型接口
    Container c = new Box();
    
    // 定义不同类型的值，保存并输出值
    int a = 1;
    String b = "1";
    
    c.add(a);
    System.out.println(c.get());
    c.add(b);
    System.out.println(c.get());
    c.add(c);
    System.out.println(c.get());
}
```

​	最后是泛型方法。

```java
public class Main {
    // 定义了一个泛型方法
    public static <E> void printArray(E[] array) {
        // 遍历接收到的泛型数组
        for (E element : array) {
            System.out.println(element);
        }
    }

    public static void main(String[] args) {
        String[] strings = {"Hello", "World"};
        printArray(strings); // 输出：Hello, World

        Integer[] integers = {1, 2, 3};
        printArray(integers); // 输出：1, 2, 3
    }
}
```

​	泛型中，还有最后三个要点。

​	泛型通配符，类型参数和上下限。

```java
// `?` 通配符
// 表示未知类型，用于表示不确定具体类型的情况下，可以接受任意类型。
public class Main {
    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();
        List<Integer> integerList = new ArrayList<>();

        printList(stringList);
        printList(integerList);
    }

    public static void printList(List<?> list) {
        for (Object element : list) {
            System.out.println(element);
        }
    }
}

// 参数 `E`
// 表示泛型类或泛型方法中的元素类型，通常用于集合类。
public class Main {
    public static void main(String[] args) {
        List<String> stringList = new ArrayList<>();
        stringList.add("Hello");
        stringList.add("World");

        for (String s : stringList) {
            System.out.println(s);
        }
    }
}

// 参数 `T`
// 表示泛型类或泛型方法中的任意类型，通常用于泛型类或泛型方法中。
public class Main {
    public static void main(String[] args) {
        Box<String> stringBox = new Box<>("Hello");
        Box<Integer> integerBox = new Box<>(10);

        System.out.println(stringBox.getContent()); // 输出：Hello
        System.out.println(integerBox.getContent()); // 输出：10
    }
}

public class Box<T> {
    private T content;

    public Box(T content) {
        this.content = content;
    }

    public T getContent() {
        return content;
    }

    public void setContent(T content) {
        this.content = content;
    }
}

// 参数 `E,V`
// 表示映射类中的键类型和值类型，通常用于 Map 类。
public class Main {
    public static void main(String[] args) {
        Map<String, Integer> map = new HashMap<>();
        map.put("One", 1);
        map.put("Two", 2);

        for (Map.Entry<String, Integer> entry : map.entrySet()) {
            System.out.println(entry.getKey() + ": " + entry.getValue());
        }
    }
}

// 泛型上限
// 指定类型参数的上限，表示类型参数必须是某个类或其子类。
public class Main {
    public static void main(String[] args) {
        List<? extends Number> list = new ArrayList<>();
        list.add(10);
        list.add(20.5);

        for (Number num : list) {
            System.out.println(num);
        }
    }
}

// 泛型下限
// 指定类型参数的下限，表示类型参数必须是某个类或其父类。
public class Main {
    public static void main(String[] args) {
        List<? super String> list = new ArrayList<>();
        list.add("Hello");
        list.add("World");

        for (Object obj : list) {
            System.out.println(obj);
        }
    }
}

// 多泛型
// 同时定义多个泛型
public class People <P extends Pet, D extends Dog, E, T> {}
```

​	最后提一种特殊情况，泛型擦除。

​	这玩意就是因为 Java 编译时将泛型相关部分（如泛型通配符和泛型参数等）更换为原始类型导致的。

​	Java 虚拟机不认识泛型代码，要换成认识的才行。

​	有可能导致运行时无法获取原始信息，导致类型错误。

​	一般可以用后面会讲的反射解决绝大部分泛型擦除的问题。

​	但是会让代码变得复杂起来（但似乎也没办法）。

## 18.设计模式

### 工厂模式

#### 基本工厂（小作坊）

首先就是最基本的工厂实现。

使用无数的 if。

if 条件中有的类才能被创建。

```java
package factory.simple;

import factory.product.IPhone;
import factory.product.XiaoMi;

public class Factory {
    public static Object create(String name) {
        if ("iphone".equals(name)) {
            return new IPhone();
        } else if ("xiaomi".equals(name)) {
            return new XiaoMi();
        } else {
            throw new IllegalArgumentException("不存在");
        }
    }
}
```

```java
Phone phone = (IPhone) Factory.create("iphone");
```

#### 专一工厂

然后是专一工厂实现。

给不同的类专门的一个工厂。

这玩意其实吧也就是一个创建实例的方法罢了。

调用一次方法就创建一个对象。

且类多了对应的专一工厂数量也就炸了。

```java
package factory.pro;

import factory.product.Phone;

public interface ProductFactory {
    Phone create();
}
```

```java
package factory.pro;

import factory.product.IPhone;
import factory.product.Phone;

public class IPhoneFactory implements ProductFactory{
    @Override
    public Phone create() {
        return new IPhone();
    }
}
```

```java
ProductFactory factory = new IPhoneFactory();
Phone iPhone = factory.create();
```

#### 系列工厂

第三个就是系列工厂实现。

定义用于生产某一类对象的工厂。

五个品牌的手机上面就要十个类，这个只要两个类。

```java
package factory.proMax;

import factory.product.Phone;

public interface AbsFactory {
    Phone createPhone();
    Pad createPad();
}
```

```java
package factory.proMax;

import factory.product.IPhone;
import factory.product.Phone;

public class AppleFactory implements AbsFactory{
    @Override
    public Phone createPhone() {
        return new IPhone();
    }

    @Override
    public Pad createPad() {
        return new IPad();
    }
}
```

```java
AbsFactory factory_a = new AppleFactory();
Phone phone_a = new IPhone();
Pad pad_a = new IPad();
```

#### 预生产通用工厂

最后就是预生产通用工厂。

预先把所有可以生产的类全部生产出来（这个生产当然是自动的，不用一个一个手动生产）。

要哪个对象直接取就好了。

这里使用注解标记可以生产的类。

```java
package factory.myFactoryPro___homeWork;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {
}
```

```java
package factory.product;

import factory.myFactoryPro___homeWork.Component;

@Component
public class IPhone implements Phone{
    @Override
    public void call() {
        System.out.println("用苹果打电话");
    }
}
```

```java
package factory.myFactoryPro___homeWork;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

public class ContainerFactory {
    /**
     * 对象组
     */
    private Map<String, Object> warehouse = new LinkedHashMap<>();

    { this.load(); }

    /**
     * 扫描项目根包下所有文件
     */
    private void load() {
        String packageName = "factory";
        List<Class<?>> classes = new ArrayList<>();
        String path = packageName.replace('.', '/');
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        try {
            URL resource = classLoader.getResource(path);
            if (resource != null) {
                String decodedPath = URLDecoder.decode(resource.getPath(), "UTF-8");
                File directory = new File(decodedPath);
                if (directory.exists()) {
                    scanClasses(directory, packageName, classes);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        addToWareHouse(classes);
    }

    /**
     * 获取文件名
     * @param directory
     * @param packageName
     * @param classes
     */
    private void scanClasses(File directory, String packageName, List<Class<?>> classes) {
        File[] files = directory.listFiles();
        if (files != null) {
            for (File file : files) {
                if (file.isDirectory()) {
                    scanClasses(file, packageName + "." + file.getName(), classes);
                } else if (file.getName().endsWith(".class")) {
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    try {
                        Class<?> clazz = Class.forName(className);
                        classes.add(clazz);
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * 装填至组
     * @param classes
     */
    private void addToWareHouse(List<Class<?>> classes) {
        for (Class<?> clazz : classes) {
            if (clazz.isAnnotationPresent(Component.class)) {
                Constructor<?> constructor = null;
                try {
                    constructor = clazz.getConstructor();
                    warehouse.put(clazz.getSimpleName(), constructor.newInstance());
                } catch (NoSuchMethodException | InvocationTargetException | InstantiationException |
                         IllegalAccessException e) {
                    throw new RuntimeException(e);
                }
            }
        }
        System.out.println(warehouse);
    }

    /**
     * 获组内取某个对象
     * @return
     */
     public Object getBean(String OName) {
         return warehouse.get(OName);
     }
}
```

```java
ContainerFactory containerFactory = new ContainerFactory();

System.out.println(containerFactory.getBean("IPhone"));
System.out.println(containerFactory.getBean("XiaoMi"));
System.out.println(containerFactory.getBean("IPad"));
System.out.println(containerFactory.getBean("XiaoMiPad"));
```

#### 超级工厂

基于依赖注入，直接注册所有的可实例类。

不用客户端创建对象了。

客户端要啥直接拿。

连上面的工厂实例也不需要建立了。

```java
package factory.myFactoryPro___homeWork;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

/**
 * 标记可生产的类
 */
@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
public @interface Component {}
```

```java
package factory.myFactoryPro___homeWork;

import java.io.File;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * 工厂
 */
public class ContainerFactory {
    /**
     * 仓库
     */
    private Map<String, Object> warehouse = new LinkedHashMap<>();

    // 开工
    { this.load(); }

    /**
     * 扫描项目根包下所有文件
     */
    private void load() {
        // 根包名
        String packageName = "factory";
        // 文件组
        List<Class<?>> classes = new ArrayList<>();
        // 包名转路径
        String path = packageName.replace('.', '/');
        // 获取类加载器
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        // 获取类
        try {
            // 获取指定地址的资源
            URL resource = classLoader.getResource(path);
            // 若地址存在资源
            if (resource != null) {
                // 对地址路径编码
                String decodedPath = URLDecoder.decode(resource.getPath(), "UTF-8");
                // 将路径转为文件对象
                File directory = new File(decodedPath);
                // 若文件存在
                if (directory.exists()) {
                    // 遍历内部的.class文件
                    scanClasses(directory, packageName, classes);
                }
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
        // 将文件组添加至仓库
        addToWareHouse(classes);
    }

    /**
     * 获取文件名
     * @param directory 文件对象
     * @param packageName 包名
     * @param classes 文件组
     */
    private void scanClasses(File directory, String packageName, List<Class<?>> classes) {
        // 获取文件对象中的所有文件
        File[] files = directory.listFiles();
        // 若有文件
        if (files != null) {
            // 遍历所有文件
            for (File file : files) {
                // 若为文件夹
                if (file.isDirectory()) {
                    // 递归
                    scanClasses(file, packageName + "." + file.getName(), classes);
                } else if (file.getName().endsWith(".class")) {
                    // 截取路径获取类名
                    String className = packageName + "." + file.getName().substring(0, file.getName().length() - 6);
                    try {
                        // 获取类的class对象
                        Class<?> clazz = Class.forName(className);
                        // 添加至文件组
                        classes.add(clazz);
                    } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                    }
                }
            }
        }
    }

    /**
     * 装填至工厂仓库
     * @param classes 文件组
     */
    private void addToWareHouse(List<Class<?>> classes) {
        for (Class<?> clazz : classes) {
            if (clazz.isAnnotationPresent(Component.class)) {
                try {
                    // 创建实例
                    Constructor<?> constructor = clazz.getConstructor();
                    // 创建对象
                    Object instance = constructor.newInstance();
                    // 将实现类实例注册到它的所有接口上（Phone iPhone = new IPhone()）
                    for (Class<?> intf : clazz.getInterfaces()) {
                        // 装填实例
                        warehouse.put(intf.getName(), instance);
                    }
                    // 将实现类实例注册到自己身上（IPhone iPhone = new IPhone()）
                    warehouse.put(clazz.getName(), instance);
                } catch (NoSuchMethodException | InvocationTargetException
                         | InstantiationException | IllegalAccessException e) {
                    throw new RuntimeException("Failed to instantiate component: " + clazz.getName(), e);
                }
            }
        }
    }

    /**
     * 获取组件
     * @param interfaceClass 接口类
     * @return 实现类的实例
     */
    @SuppressWarnings("unchecked")
    public <T> T getBean(Class<T> interfaceClass) {
        // 在仓库里找组件
        return (T) warehouse.get(interfaceClass.getName());
    }
}
```

```java
package factory.myFactoryPro___homeWork;

public class FactoryOnly {
    /**
     * 唯一工厂
     */
    private static final ContainerFactory containerFactory;

    // 实例工厂
    static { containerFactory = new ContainerFactory(); }

    /**
     * 获取组件
     * @param interfaceClass 接口类
     * @return 实现类
     */
    public static <T> T getBean(Class<T> interfaceClass) {
        // 获取对象
        return containerFactory.getBean(interfaceClass);
    }
}
```

```java
Phone iPhone13 = FactoryOnly.getBean(IPhone.class);
IPhone iPhone14 = FactoryOnly.getBean(IPhone.class);
Phone xiaomi = FactoryOnly.getBean(XiaoMi.class);
Pad iPad = FactoryOnly.getBean(IPad.class);
Pad xiaoMiPad = FactoryOnly.getBean(XiaoMiPad.class);

System.out.println(iPhone13);
System.out.println(iPhone14);
System.out.println(xiaomi);
System.out.println(iPad);
System.out.println(xiaoMiPad);
```

# 12，高级一点的常用API

## 1.Object 基类

​	这玩意是 Java 所有类的基类（所有类的祖宗）。

​	所有类默认继承 Object 类（除非显式的继承了别的类）。

​	基于 Java 继承的特色，所有类都可以访问使用到这个基类的方法。

​	反正常用的就三个方法。

```java
// public String toString() 返回对象，以字符串形式展示成员
// public boolean equals(Object a, Object b) 比较两个对象是否相等
// protected Object clone() 创建当前对象的拷贝
// public static boolean isNull(Object o) 判断是否为空
// public static boolean nonNull(Object o) 判断是否不为空
```

​	第一个方法就是用于让子类重写后，输出子类自己的成员信息。

​	第二个方法就是用于让子类重写后，比较指定的两个对象是否相等，且比较的是两个对象的地址。

​	第三个方法就是用于让子类重写后，创建一个和当前对象一模一样的玩意出来。

​	四五个方法就是字面意思了，判断一下空不空。

​	应为这个基类属于所有类的祖宗，在声明时，当然也可以把 `Object` 赋予给任何类型的变量。

​	这个特性尤其是在泛型和之后的集合框架中非常有用。

## 2.包装类

​	就是把基本数据类型包装成对象。

​	这些基本数据类型是没有对象的性质的，对象方法这种方便好用的玩意也没有（如转换类型的方法）。

​	且包装后允许初始化时留空，就是可以为 null。

​	所以把它们重新倒腾一遍。

​	byte 变成 Byte。

​	short 变成 Short。

​	int 变成 Integer。

​	long 变成 Long。

​	char 变成 Character。

​	float 变成 Float。

​	double 变成 Double。

​	boolean 变成 Boolean。

​	包装类也有三个最最基本常用的方法。

```java
// 将字符串解析为包装类型
Integer i = Integer.valueOf("456"); // 获取 Integer 对象

// 将字符串解析为基本类型
int i = Integer.parseInt("789"); // 获得 int 类型的值

// 将包装类型解析为字符串
String str = Integer.toString(1001); // 结果为 "1001"
```

## 3.StringBuilder，Buffer，Joiner 可变字符串

​	讲人话就是可变字符串对象。

​	一般的字符串不能像数组一样随便加减字符，这个可以把字符串变得和数组一样随便加减字符。

​	比直接新建覆盖啥的，这样子操作字符串更加高效，代码更加简洁。

​	有五个常用方法。

```java
public StringBuilder() // 构造器，创建一个空白可变字符串对象

public StringBuilder(String str) // 构造器，创建一个指定内容的可变字符串对象
    
public StringBuilder append(任何类型) // 添加数据，然后返回这个可变字符串对象本身
    
public StringBuilder reverse() // 将内容反转
    
public int length() // 返回内容长度
    
public String toString() // 将StringBuilder对象转为String对象
```

​	反正就是若操作频率高，要频繁修改拼接删除啥的，用 builder 效率高。

​	若基本不用操作，或只为了定义字符串变量，String 就够了。

​	还有个玩意叫 StringBuffer。

​	buffer 和 builder 几乎一样，只是 builder 线程不安全。

​	还有个 Joiner。

​	在经历了 builder 和buffer 后，又出现了 joiner。

​	也是几乎一样，反正说是更好（个人感觉用谁都没差）。

​	也是五个常用方法。	

```java
public StringJoiner(间隔符号) // 创建一个对象，指定拼接时的间隔符号
    
public StringJoiner(间隔符号, 开始符号, 结束符号) // 创建一个对象，指定拼接时的间隔符号, 开始符号, 结束符号
    
public StringJoiner add(添加的内容) // 添加数据，返回对象本身
    
public int length() // 返回长度（字符出现的个数）
    
public String toString() // 返回一个字符串（拼接后的结果）
```

​	总的来说。

​	Builder 用于单线程下的字符串拼接，且性能最好。

​	Buffer 用于多线程下的字符串拼接，为了线程安全而性能较差。

​	Joiner 用于需要灵活定义拼接规则时。

## 4.Math 数学工具

​	提供了各种运算操作与常量。

​	这玩意里面的所有方法都是静态的，静态方法的其中一个小特点就是可以直接通过类名调用，不用实例对象。

​	有七种常用方法。

```java
// public static int abs(int a) 返回绝对值
public class Main {
    public static void main(String[] args) {
        int result = Math.abs(-5);
        System.out.println(result); // 输出：5
    }
}
    
// public static double ceil(double a) 返回大于等于参数的最小整数
public class Main {
    public static void main(String[] args) {
        double result = Math.ceil(3.14);
        System.out.println(result); // 输出：4.0
    }
}
    
// public static double floor(double a) 返回小于等于参数的最大整数
public class Main {
    public static void main(String[] args) {
        double result = Math.floor(3.14);
        System.out.println(result); // 输出：3.0
    }
}
    
// public static int round(float a) 返回最接近参数的整数
public class Main {
    public static void main(String[] args) {
        int result = Math.round(3.6f);
        System.out.println(result); // 输出：4
    }
}
    
// public static int max(int a, int b) 返回两个参数中大的那个
public class Main {
    public static void main(String[] args) {
        int result = Math.max(5, 10);
        System.out.println(result); // 输出：10
    }
}
    
// public static double pow(double a, double b) 返回a的b次方
public class Main {
    public static void main(String[] args) {
        double result = Math.pow(2, 3);
        System.out.println(result); // 输出：8.0
    }
}
    
// public static double random() 返回大于等于0.0且小于等于1.0的随机数
public class Main {
    public static void main(String[] args) {
        double result = Math.random();
        System.out.println(result); // 输出：0.123456789（随机数）
    }
}
```

​	这玩意没啥好说的，就是帮忙算数的方法。

## 5.System 系统工具类

​	提供了一系列用于执行系统级操作的方法和属性（感觉很少用到的说）。

​	所有方法也是静态的。

​	有两个常用方法。

```java
// public static void exit(int status) 终止当前运行的Java虚拟机
public class Main {
    public static void main(String[] args) {
        System.out.println("程序即将退出");
        System.exit(0); // 正常退出
    }
}

// public static long currentTimeMillis() 返回当前系统的时间，毫秒形式
public class Main {
    public static void main(String[] args) {
        long currentTime = System.currentTimeMillis();
        System.out.println("当前系统时间（毫秒）：" + currentTime);
    }
}
```

​	关于毫秒，包括有个玩意叫时间戳，似乎都是从1970-1-1/00:00:00开始计算的。

## 6.Runtime 运行实例

​	提供与 Java 虚拟机（JVM）相关的操作和信息。

​	每个 Java 程序都会有一个运行实例。

​	既然是这个程序的运行实例，那么这可不就是一个单例类嘛，设计模式还记得吗？

​	比起上面 System 这玩意，这个 Runtime有用多了，也好玩多了。

​	主要用来（我用来）获取可用内存，处理器核心数，手动垃圾回收和退出程序等。

```java
// public static Runtime getRuntime() 返回当前程序的运行实例
public class Main {
    public static void main(String[] args) {
        Runtime runtime = Runtime.getRuntime();
        System.out.println("Runtime instance: " + runtime);
    }
}

// public static int availableProcessors() 获取当前系统可用处理器核心数量
public class Main {
    public static void main(String[] args) {
        int processors = Runtime.getRuntime().availableProcessors();
        System.out.println("Available processors: " + processors);
    }
}

// public long freeMemory() 返回当前JVM可用内存量，字节为单位
public class Main {
    public static void main(String[] args) {
        long freeMemory = Runtime.getRuntime().freeMemory();
        System.out.println("Free memory: " + freeMemory + " bytes");
    }
}

// public long totalMemory() 返回当前JVM使用的总内存量，也是字节为单位
public class Main {
    public static void main(String[] args) {
        long totalMemory = Runtime.getRuntime().totalMemory();
        System.out.println("Total memory: " + totalMemory + " bytes");
    }
}

// public long maxMemory() 返回当前JVM最大可用内存量，还是字节为单位
public class Main {
    public static void main(String[] args) {
        long maxMemory = Runtime.getRuntime().maxMemory();
        System.out.println("Max memory: " + maxMemory + " bytes");
    }
}

// public void gc() 现在立刻回收一下垃圾，释放一下内存
public class Main {
    public static void main(String[] args) {
        Runtime.getRuntime().gc();
        System.out.println("Garbage collection executed");
    }
}

// public void exit(int status) 终止当前运行的JVM，并返回状态码
public class Main {
    public static void main(String[] args) {
        System.out.println("Program is about to exit");
        Runtime.getRuntime().exit(0); // 正常退出
    }
}
```

## 7.BigDecimal 大型精确浮点

​	用于解决高精度计算或长小数运算时，因为装不下出现的结果失真。

​	常用下面这种构造方法。

​	还有一种传入双精度浮点的方式创建，但似乎说是有可能丢失一点点精度。

​	虽然比常规浮点好，但既然说了这是精确浮点，那么越精确越好嘛。

```java
// public BigDecimal(String val) // 以字符串创建大型精确浮点
public class Main {
    public static void main(String[] args) {
        BigDecimal bd = new BigDecimal("123.45");
        System.out.println(bd); // 输出：123.45
    }
}
```

​	然后就是一些常用方法。

```java
// public BigDecimal add(BigDecimal augend) 当前对象与指定对象的和
public class Main {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal("10.5");
        BigDecimal bd2 = new BigDecimal("20.3");
        BigDecimal result = bd1.add(bd2);
        System.out.println(result); // 输出：30.8
    }
}

// public BigDecimal subtract(BigDecimal subtrahend) 当前对象与指定对象的差
public class Main {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal("20.5");
        BigDecimal bd2 = new BigDecimal("10.3");
        BigDecimal result = bd1.subtract(bd2);
        System.out.println(result); // 输出：10.2
    }
}

// public BigDecimal multiply(BigDecimal multiplicand) 当前对象与指定对象的积
public class Main {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal("10.5");
        BigDecimal bd2 = new BigDecimal("2");
        BigDecimal result = bd1.multiply(bd2);
        System.out.println(result); // 输出：21.0
    }
}

// public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) 当前对象除以指定对象的结果，指定精度和舍入模式
import java.math.RoundingMode;
public class Main {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal("10.5");
        BigDecimal bd2 = new BigDecimal("3");
        BigDecimal result = bd1.divide(bd2, 2, RoundingMode.HALF_UP);
        System.out.println(result); // 输出：3.50
    }
}

// public int compareTo(BigDecimal val) 比较当前对象与指定对象的大小（-1小于，0等于，1大于）
public class Main {
    public static void main(String[] args) {
        BigDecimal bd1 = new BigDecimal("10.5");
        BigDecimal bd2 = new BigDecimal("20.3");
        int result = bd1.compareTo(bd2);
        System.out.println(result); // 输出：-1
    }
}

// public String toString() 对象转换为字符串
public class Main {
    public static void main(String[] args) {
        BigDecimal bd = new BigDecimal("123.45");
        String result = bd.toString();
        System.out.println(result); // 输出：123.45
    }
}
```

## 8.Date，SimpleDateFormat 时间类型

​	Date 用于表示特定时间点，可以精确到毫秒。

​	似乎就是基于毫秒级的时间戳（从1970-1-1/00:00:00开始）计算时间。

​	这玩意功能有限（有新版的时间日期处理对象了），也是不咋用，认识一下就行。

​	两个构造器。

```java
// public Date() 创建一个当前时间的时间对象
Date date = new Date(); // 创建一个表示当前时间的 Date 对象

// public Date(long time) 创建一个指定时间的时间对象，传入指定时间的时间戳
long time = 1672502400000L; // 例如，表示 2023 年 1 月 1 日 00:00:00 GMT 的时间戳
Date date = new Date(time); // 创建一个表示该时间戳对应时间的 Date 对象
```

​	两个常见方法。

```java
// public long getTime() 获取这个时间对象的时间戳
Date date = new Date(); // 获取当前时间
long time = date.getTime(); // 返回当前时间对应的毫秒时间戳

// public void setTime(long time) 修改这个时间对象的时间戳
Date date = new Date(); // 创建一个 Date 对象
long time = 1672502400000L; // 时间戳
date.setTime(time); // 设置 Date 对象的时间为指定时间戳对应的时间
```

​	而 SimpleDateFormat 用于将死人时间戳（根本看不懂）格式化。

​	变成指定的，能看懂的日期格式。

​	一种构造方法。

```java
//public SimpleDateFormat(String pattern) 创建一个新的对象，传入格式
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
```

​	两个常用方法。

```java
//public final String format(Date date) 格式化为字符串格式
Date date = new Date(); // 创建一个 Date 对象
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
String formattedDate = formatter.format(date); // 将 Date 对象格式化为字符串
System.out.println(formattedDate); // 输出格式化后的日期和时间

// public Date parse(String source) 把字符串变成时间对象
String dateString = "2023-10-20"; // 示例日期字符串
SimpleDateFormat formatter = new SimpleDateFormat("yyyy-MM-dd"); // 定义日期格式
Date date = formatter.parse(dateString); // 将日期字符串解析为 Date 对象
System.out.println("解析后的日期对象: " + date);
```

​	这个玩意是有格式的，根据格式输出。

​	下面是常见的格式组合。

| 格式                | 输出内容            | 示例格式化后的结果  |
| :------------------ | :------------------ | :------------------ |
| yyyy-MM-dd          | 2023-10-19          | 2023-10-19          |
| yyyy/MM/dd          | 2023/10/19          | 2023/10/19          |
| MMMM d, yyyy        | October 19, 2023    | October 19, 2023    |
| E, MMM d, yyyy      | Thu, Oct 19, 2023   | Thu, Oct 19, 2023   |
| HH:mm:ss            | 14:30:45            | 14:30:45            |
| H:mm:ss a           | 14:30:45 PM         | 14:30:45 PM         |
| yyyy-MM-dd HH:mm:ss | 2023-10-19 14:30:45 | 2023-10-19 14:30:45 |

## 9.小结：判断是否秒杀成功

​	有两个家伙，A 和 B。

​	分别在 2023-11-11 00:01:18 和 2023-11-11 00:10:51 下单。

​	活动在 2023-11-11 00:00:00 开始，2023-11-11 00:10:00 结束。

​	判断 A 和 B 是否成功下单。

```java
// 初始化
String timeA = "2023-11-11 00:01:18";
String timeB = "2023-11-11 00:10:51";
String startTime = "2023-11-11 00:00:00";
String endTime = "2023-11-11 00:10:00";

// 转换目标格式
SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");

// 转换为日期
Date dateA;
Date dateB;
Date dateStart;
Date dateEnd;
try {
    dateA = sdf.parse(timeA);
    dateB = sdf.parse(timeB);
    dateStart = sdf.parse(startTime);
    dateEnd = sdf.parse(endTime);
} catch (ParseException e) {
    throw new RuntimeException(e);
}

// 转换为时间戳
long A = dateA.getTime();
long B = dateB.getTime();
long S = dateStart.getTime();
long E = dateEnd.getTime();

// 判断
if (A >= S && A <= E) {
    System.out.println("A下单成功");
}
if (B >= S && B <= E) {
    System.out.println("B下单成功");
}
```

## 10.Calendar 时间类型

​	感觉，特殊一点吧。

​	这玩意代表的是系统此刻时间对应的日历（右下角那个日历（你是Windows的话））。

​	它可以单独获取或修改时间中的年月日时分秒，而上面两种事件类型就很麻烦了。

​	有六个常见方法。

```java
// public static Calendar getInstance() 获取当前日历对象，包含当前日期与时间
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        System.out.println("当前日历对象：" + calendar);
    }
}

// public int get(int field) 获取日历中的某个信息，如年月日
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        int year = calendar.get(Calendar.YEAR);
        int month = calendar.get(Calendar.MONTH) + 1; // 月份从0开始
        int day = calendar.get(Calendar.DAY_OF_MONTH);
        System.out.println("当前日期：" + year + "-" + month + "-" + day);
    }
}

// public final Date getTime() 获取日期对象
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        Date date = calendar.getTime();
        System.out.println("日期对象：" + date);
    }
}

// public long getTimeInMillis() 获取时间毫秒值（又是从1970...这个时间点开始计算）
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        long timeInMillis = calendar.getTimeInMillis();
        System.out.println("时间毫秒值：" + timeInMillis);
    }
}

// public void set(int field, int value) 修改日历的某个信息，如年月日
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        calendar.set(Calendar.YEAR, 2025);
        calendar.set(Calendar.MONTH, 11); // 月份从0开始
        calendar.set(Calendar.DAY_OF_MONTH, 1);
        System.out.println("设置后的日期：" + calendar);
    }
}

// public void add(int field, int amount) 为某个信息增加减少指定的值
public class Main {
    public static void main(String[] args) {
        Calendar calendar = Calendar.getInstance();
        calendar.add(Calendar.DAY_OF_MONTH, 10); // 增加10天
        System.out.println("增加10天后的日期：" + calendar);
    }
}
```

## 11.时间类型的全新代替品

​	上面巴拉巴拉半天，结果告诉我 JDK8 有新增类型可以全面代替老旧类型...	

​	下面几个用于代替 Calendar...

```java
// LocalDate 年月日
import java.time.LocalDate;
public class Main {
    public static void main(String[] args) {
        LocalDate date = LocalDate.now();
        System.out.println("当前日期：" + date);
    }
}

// LocalTime 时分秒
import java.time.LocalTime;
public class Main {
    public static void main(String[] args) {
        LocalTime time = LocalTime.now();
        System.out.println("当前时间：" + time);
    }
}

// LocalDateTime 年月日时分秒
import java.time.LocalDateTime;
public class Main {
    public static void main(String[] args) {
        LocalDateTime dateTime = LocalDateTime.now();
        System.out.println("当前日期和时间：" + dateTime);
    }
}

// ZoneId 时区
import java.time.ZoneId;
public class Main {
    public static void main(String[] args) {
        ZoneId zoneId = ZoneId.systemDefault();
        System.out.println("系统默认时区：" + zoneId);
    }
}

// ZonedDateTime 带时区的时间
import java.time.ZonedDateTime;
public class Main {
    public static void main(String[] args) {
        ZonedDateTime zonedDateTime = ZonedDateTime.now();
        System.out.println("当前带时区的日期和时间：" + zonedDateTime);
    }
}
```

​	下面一个用于代替 SimplDateFormat...

```java
// DateTimeFormatter 格式化时间与解析
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
public class Main {
    public static void main(String[] args) {
        LocalDateTime dateTime = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String formattedDateTime = dateTime.format(formatter);
        System.out.println("格式化后的日期和时间：" + formattedDateTime);
    }
}
```

​	下面一个用于代替 Date...

```java
// Instant 时间戳
import java.time.Instant;
public class Main {
    public static void main(String[] args) {
        Instant instant = Instant.now();
        System.out.println("当前时间戳：" + instant);
    }
}
```

## 12.Arrays 数组工具类

​	用于操作数组的工具类。

​	个人觉得比数组好用太多了。

```java
// public static String toString(类型[] arr) 返回数组内容
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        String result = Arrays.toString(arr);
        System.out.println(result); // 输出：[1, 2, 3, 4, 5]
    }
}

// public static int[] copyOfRange(类型[] arr, 起始索引, 结束索引) 拷贝数组（指定范围）
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = Arrays.copyOfRange(arr, 1, 4);
        System.out.println(Arrays.toString(result)); // 输出：[2, 3, 4]
    }
}

// public static copyOf(类型[] arr, int newLength) 拷贝数组
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        int[] arr = {1, 2, 3, 4, 5};
        int[] result = Arrays.copyOf(arr, 3);
        System.out.println(Arrays.toString(result)); // 输出：[1, 2, 3]
    }
}

// public static setAll(double[] array, IntToDoubleFunction generator) 把数组中的原数据改为新数据
import java.util.Arrays;
import java.util.function.IntToDoubleFunction;
public class Main {
    public static void main(String[] args) {
        double[] array = new double[5];
        Arrays.setAll(array, index -> Math.random() * 100);
        System.out.println(Arrays.toString(array)); // 输出：[随机数, 随机数, 随机数, 随机数, 随机数]
    }
}

// public static void sort(类型[] arr) 对数组进行排序（默认升序）
import java.util.Arrays;
public class Main {
    public static void main(String[] args) {
        int[] arr = {5, 2, 8, 1, 9};
        Arrays.sort(arr);
        System.out.println(Arrays.toString(arr)); // 输出：[1, 2, 5, 8, 9]
    }
}
```

## 13.Lambda 表达式

​	JDK8 后出现的新语法。

​	用于简化匿名内部类的代码。

​	一般只能简化函数式接口的匿名内部类。

​	回忆一下 JS 中的箭头函数，很像。

```java
Arrays.setAll(score, new IntToDoubleFunction() {
   @Override
	public double applyAsDouble(int value) {
        return scores[value] * 0.8;
    }
});

// 可以简化为
Arrays.setAll(scores, (int value) -> {
    return scores[value] * 0.8;
})
```

​	关于函数式接口，就是有且仅有一个抽象方法的接口。

​	这个坏人还可以简化（我觉得过于简化的反而不好懂了）。

​	参数类型可以不写。

​	若只有一个参数，除了类型，连 `()` 都可以不写。

​	若方法体只有一行代码，大括号，分号与返回标记全都不写。

## 14.方法引用运算符 “ :: ”

​	用于引用类或对象的方法或构造器。

​	可以更加简化代码，更好理解（简化是真，好理解扯淡）。

​	第一个是静态方法引用。

```java
// 类名::静态方法
import java.util.function.Predicate;

public class Main {
    public static void main(String[] args) {
        // 使用 Lambda 表达式
        Predicate<Integer> isEven = (num) -> MyMath.isEven(num);

        // 使用静态方法引用
        Predicate<Integer> isEvenRef = MyMath::isEven;

        System.out.println(isEven.test(4));  // 输出：true
        System.out.println(isEvenRef.test(5)); // 输出：false
    }
}

class MyMath {
    public static boolean isEven(int num) {
        return num % 2 == 0;
    }
}
```

```java
// 对象::实例方法
// 类名::实例方法
import java.util.function.Consumer;

public class Main {
    public static void main(String[] args) {
        String str = "hello";

        // 使用 Lambda 表达式
        Consumer<String> printUpperCase = (s) -> s.toUpperCase();

        // 使用实例方法引用
        Consumer<String> printUpperCaseRef = String::toUpperCase;

        System.out.println(printUpperCase.apply(str)); // 输出：HELLO
        System.out.println(printUpperCaseRef.apply(str)); // 输出：HELLO
    }
}
```

```java
// 类名::new（构造器引用）
import java.util.function.Supplier;

public class Main {
    public static void main(String[] args) {
        // 使用 Lambda 表达式
        Supplier<List<String>> listSupplier = () -> new ArrayList<>();

        // 使用构造器引用
        Supplier<List<String>> listSupplierRef = ArrayList::new;

        System.out.println(listSupplier.get()); // 输出：[]
        System.out.println(listSupplierRef.get()); // 输出：[]
    }
}
```

## 15.小结：订单管理系统

​	你需要开发一个简单的订单管理系统，满足以下功能（禁止使用：IO流，多线程，反射，注解，Map/Set/List等集合框架，正则表达式）：

​	**订单类定义**：

​	订单包含订单 ID、商品名称、订单金额、创建时间。

​	使用 `BigDecimal` 存储订单金额，确保金额的精确性。

​	使用 Java 8 的新时间日期类 `Instant` 表示订单创建时间。

​	**订单生成**：

​	使用 `Runtime` 获取当前系统可用的处理器数量，结合 `System.currentTimeMillis()` 生成一个唯一的订单 ID。

​	提供一个静态方法，随机生成订单金额（1000 - 5000）和商品名称（从预定义列表中随机选择）。

​	使用 `Math.random()` 来辅助生成随机值。

​	**订单操作**：

​	使用 `StringBuilder` 拼接订单信息，方便订单内容的动态显示。

​	提供一个方法，按照随机折扣计算订单折后金额（折扣范围 0.5 - 0.9）。

​	**订单比较**：

​	实现 `Object` 的 `equals()` 方法，比较两个订单是否为同一订单（订单 ID 相同）。

​	**时间处理**：

​	使用 `SimpleDateFormat` 将订单创建时间转换为可读的日期格式（如 `yyyy-MM-dd HH:mm:ss`）。

​	**批量订单处理**：

​	使用 `Arrays` 提供批量生成订单的功能。

​	使用 Lambda 表达式过滤出金额大于 3000 的订单。

​	（不会（傻鸟Lambda，麻烦又复杂））使用方法引用简化订单创建时间格式化的代码。

​	**思考与解答：**

​	**订单类实现**：如何使用 `BigDecimal` 存储金额并防止精度丢失？

​	**订单ID生成**：如何结合 `Runtime` 和 `System.currentTimeMillis()` 生成唯一订单 ID？

​	**折扣计算**：随机折扣的计算逻辑如何实现？

​	**时间处理**：如何将 `Instant` 转换为 `LocalDateTime` 以便于格式化？

​	**Lambda 表达式**：如何高效地使用 Lambda 表达式过滤和处理订单数组？

```java
import java.math.BigDecimal;
import java.text.SimpleDateFormat;
import java.time.Instant;
import java.util.Arrays;
import java.util.Date;

public class Main {
    public static void main(String[] args) throws InterruptedException {
        // 测试随机商品名与价格输出
//        for (int i = 0; i < 10; i++) {
//            System.out.println(randomNameAndPrice()[1]);
//        }

        // 测试创建订单
//        Order newOrder = createOrder();
//        System.out.println(newOrder.toString());

        // 测试拼接订单信息
//        Order newOrder = createOrder();
//        System.out.println(showOrder(newOrder));

        // 测试随机打折计算价格
//        Order newOrder = createOrder();
//        System.out.println(discount(newOrder.getPrice()));

        // 测试两个订单是否相同
//        Order newOrderA = createOrder();
//        Order newOrderB = createOrder();
//        System.out.println(checkOrder(newOrderA, newOrderA));
//        System.out.println(checkOrder(newOrderA, newOrderB));

        // 测试转换订单创建时间
//        Order newOrder = createOrder();
//        System.out.println(transformTime(newOrder.getCreateTime()));

        // 测试批量生成订单的方法
//        for (int i = 0; i < 5; i++) {
//            Order[] orders = createSomeOrder(2);
//            for (Order order : orders) {
//                System.out.println(order.toString());
//            }
//            TimeUnit.SECONDS.sleep(1);
//        }

        // 使用Lambda判断订单金额大于3000
//        Order order = createOrder();
//        Predicate<BigDecimal> isOver = a -> a.compareTo(BigDecimal.valueOf(3000)) > 0;
//        System.out.println(isOver.test(order.getPrice()));
    }

    /**
     * 随机商品名与价格
     * @return 返回价格与商品名
     */
    public static Object[] randomNameAndPrice() {
        String[] orderName = new String[]{"商品A", "商品B"};
        int price = (int) (Math.random() * (5000 - 1000 + 1)) + 1000;
        int index = (int)(Math.random() * orderName.length);
        String name = orderName[index];
        return new Object[]{name, price};
    }

    /**
     * 创建订单（随机）
     * @return 返回订单对象
     */
    public static Order createOrder() {
        Object[] obj = randomNameAndPrice();
        return new Order((String)obj[0], new BigDecimal((Integer)obj[1]));
    }

    /**
     * 拼接订单所有信息
     * @param order 订单对象
     * @return 返回拼接完成的信息字符串
     */
    public static StringBuilder showOrder(Order order) {
        return new StringBuilder("商品ID：" + order.getId() + "\n" +
                "商品名：" + order.getName() + "\n" +
                "商品价格：" + order.getPrice() + "\n" +
                "订单创建日期：" + order.getCreateTime());
    }

    /**
     * 随机打折计算折后价格
     * @param price 商品价格
     * @return 返回折后价格
     */
    public static BigDecimal discount(BigDecimal price) {
        int discount = (int)(Math.random() * (9 - 5 + 1)) + 5;
        String last = "0." + discount;
        return price.multiply(new BigDecimal(last));
    }

    /**
     * 检查ID以确认是否为同一订单
     * @param a 第一个订单对象
     * @param b 第二个订单对象
     * @return 是或否
     */
    public static boolean checkOrder(Order a, Order b) {
        return a.getId().equals(b.getId());
    }

    /**
     * 转换订单创建时间的格式
     * @param date 订单创建时间
     * @return 返回转换格式之后的订单创建时间
     */
    public static String transformTime(Instant date) {
        Date newDate = Date.from(date);
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        return sdf.format(newDate);
    }

    /**
     * 按照指定数量生成订单
     * @param num 生成的订单数
     * @return 返回订单对象数组
     */
    public static Order[] createSomeOrder(int num) {
        Order[] orderList = new Order[num];
        for (int i = 0; i < num; i++) {
            Arrays.setAll(orderList, index -> createOrder());
        }
        return orderList;
    }
}
```

# 13，认识算法与正则

## 1.冒泡排序

​	算法就是解决某个问题的方法（没啥听着那么高级的，搓个1+1=2也是算法）。

​	先认识一下冒泡排序。

​	就是从第一位开始，若大于下一位就交换位置，最大的数就会一路提升到末尾。

​	如，有一个字符串，要把里面的数字从小到大排序。

```java
public static void main(String[] args) throws InterruptedException {
    int[] startList = new int[]{13, 5, 10, 4, 7};
    int[] finalList = new int[]{13, 5, 10, 4, 7};

    // 数组长度
    int n = finalList.length;
    // 交换标记（本轮是否交换过）
    boolean swapped;

    // 排序循环
    for (int i = 0; i < n - 1; i++) {
        // 重置交换标记
        swapped = false;

        // 每一轮将未排序部分的最大值提升到正确的位置
        for (int j = 0; j < n - i - 1; j++) {
            // 若当前数大于它的下一个数
            if (finalList[j] > finalList[j + 1]) {
                // 交换 j 和 j + 1
                int temp = finalList[j];
                finalList[j] = finalList[j + 1];
                finalList[j + 1] = temp;
                // 本轮进行过交换了
                swapped = true;
            }
        }

        // 如果没有发生交换，说明数组已经有序，提前退出
        if (!swapped) {
            break;
        }
    }

    // 输出
    for (int value : startList) {
        System.out.print(value + " ");
    }
    System.out.println();
    for (int value : finalList) {
        System.out.print(value + " ");
    }
}
```

## 2.选择排序

​	也是一种排序算法。

​	会给数组添加一组一样长度的对应下标组。

​	逐一遍历，遍历完成后，把最小的降至开头，下一轮从第二个开始。

​	也是用数组排序举例子。

```java
public static void main(String[] args) throws InterruptedException {
	int[] startList = new int[]{13, 5, 10, 4, 7};
    int[] finalList = new int[]{13, 5, 10, 4, 7};

    for (int i = 0; i < finalList.length - 1; i++) {
        int minIndex = i; // 假设当前索引是最小值的位置

        // 查找未排序部分的最小值
        for (int j = i + 1; j < finalList.length; j++) {
            if (finalList[j] < finalList[minIndex]) {
                minIndex = j;
            }
        }

        // 交换最小值到当前位置
        int temp = finalList[minIndex];
        finalList[minIndex] = finalList[i];
        finalList[i] = temp;
    }

    // 输出
    for (int value : startList) {
        System.out.print(value + " ");
    }
    System.out.println();
    for (int value : finalList) {
        System.out.print(value + " ");
    }
}
```

## 3.二分查找

​	一种查找算法。

​	若有个很长很长的数组，你要拿其中一个值，一个一个从头开始找就会很慢。

​	这种算法就是用折半的方法查找。

​	若小于，向左。

​	若大于，向右。

​	前提是这个数组必须是有序的。

```java
int[] list = new int[]{1, 2, 3, 4, 5, 6};
int target = 5;

int left = 0; // 左边界
int right = list.length - 1; // 右边界

while (left <= right) {
    int mid = left + (right - left) / 2; // 防止溢出
    if (list[mid] == target) {
        System.out.println(mid); // 找到目标值，返回索引
        break;
    } else if (list[mid] < target) {
        left = mid + 1; // 目标值在右半部分
    } else {
        right = mid - 1; // 目标值在左半部分
    }
}
```

## 4.脑瘫正则表达式

​	正则表达式。

​	又爱又恨。

​	语法简洁，但属实难以理解。

​	一般用不太到，但就是会有非它不可的情况。

​	尤其为了优化代码时。

​	正则 + 流 + Lambda 三贱客的组合也是避不开的。

### 1.基本语法

- 直接匹配单个字符本身。

  ```java
  String str = "abc";
  System.out.println(str.matches("a")); // false，因为 matches 方法会检查整个字符串是否匹配
  System.out.println(str.matches("abc")); // true
  ```

### 2.特殊字符

- `.` 匹配换行符之外的任意单个字符。

  ```java
  String str = "a";
  System.out.println(str.matches(".")); // true
  String str2 = "ab";
  System.out.println(str2.matches(".")); // false，因为 matches 方法会检查整个字符串是否匹配
  System.out.println(str2.matches("..")); // true
  ```

- `^` 匹配字符串的开始位置。

  ```java
  String str = "abc";
  System.out.println(str.matches("^a")); // false，因为 matches 方法会检查整个字符串是否匹配
  System.out.println(str.startsWith("a")); // true
  ```

- `$` 匹配字符串的结束位置。

  ```java
  String str = "abc";
  System.out.println(str.matches("c$")); // false，因为 matches 方法会检查整个字符串是否匹配
  System.out.println(str.endsWith("c")); // true
  ```

- `|` 匹配多个表达式中的任意一个。

  ```java
  String str = "abc";
  System.out.println(str.matches("a|b")); // false，因为 matches 方法会检查整个字符串是否匹配
  System.out.println(str.matches("a.*|b.*")); // true
  ```

### 3.字符集

- `[abc]` 匹配括号内的任意一个字符。

  ```java
  String str = "a";
  System.out.println(str.matches("[abc]")); // true
  String str2 = "d";
  System.out.println(str2.matches("[abc]")); // false
  ```

- `[^abc]` 匹配不在括号内的任意一个字符。

  ```java
  String str = "d";
  System.out.println(str.matches("[^abc]")); // true
  String str2 = "a";
  System.out.println(str2.matches("[^abc]")); // false
  ```

- `[a-z]` 匹配括号内指定范围内的任意一个字符。

  ```java
  String str = "m";
  System.out.println(str.matches("[a-z]")); // true
  String str2 = "A";
  System.out.println(str2.matches("[a-z]")); // false
  ```

- `[a-zA-Z]` 匹配大小写字符。

  ```java
  String str = "M";
  System.out.println(str.matches("[a-zA-Z]")); // true
  ```

### 4.量词

- `*` 匹配前面的表达式0次或多次。

  ```java
  String str = "";
  System.out.println(str.matches("a*")); // true，因为空字符串符合零次匹配
  String str2 = "aaaa";
  System.out.println(str2.matches("a*")); // true
  ```

- `+` 匹配前面的表达式1次或多次。

  ```java
  String str = "a";
  System.out.println(str.matches("a+")); // true
  String str2 = "";
  System.out.println(str2.matches("a+")); // false
  ```

- `?` 匹配前面的表达式0次或1次。

  ```java
  String str = "";
  System.out.println(str.matches("a?")); // true
  String str2 = "a";
  System.out.println(str2.matches("a?")); // true
  String str3 = "aa";
  System.out.println(str3.matches("a?")); // false
  ```

- `{n}` 匹配前面的子表达式刚好n次。

  ```java
  String str = "aa";
  System.out.println(str.matches("a{2}")); // true
  ```

- `{n,}` 匹配前面的子表达式至少n次。

  ```java
  String str = "aaa";
  System.out.println(str.matches("a{2,}")); // true
  String str2 = "a";
  System.out.println(str2.matches("a{2,}")); // false
  ```

- `{n, m}` 匹配前面的子表达式至少n次，最多m次。

  ```java
  String str = "aaa";
  System.out.println(str.matches("a{2,4}")); // true
  String str2 = "a";
  System.out.println(str2.matches("a{2,4}")); // false
  String str3 = "aaaaa";
  System.out.println(str3.matches("a{2,4}")); // false
  ```

### 5.元字符

- `\d` 匹配一个数字字符，等价于 `[0-9]`。

  ```java
  String str = "5";
  System.out.println(str.matches("\\d")); // true
  String str2 = "a";
  System.out.println(str2.matches("\\d")); // false
  ```

- `\D` 匹配一个非数字字符，等价于 `[^0-9]`。

  ```java
  String str = "a";
  System.out.println(str.matches("\\D")); // true
  String str2 = "5";
  System.out.println(str2.matches("\\D")); // false
  ```

- `\w` 匹配包括下划线的任意单词字符，等价于 `[A-Za-z0-9_]`。

  ```java
  String str = "a";
  System.out.println(str.matches("\\w")); // true
  String str2 = " ";
  System.out.println(str2.matches("\\w")); // false
  ```

- `\W` 匹配非单词字符。

  ```java
  String str = " ";
  System.out.println(str.matches("\\W")); // true
  String str2 = "a";
  System.out.println(str2.matches("\\W")); // false
  ```

- `\s` 匹配任意空白字符，等价于 `\t\n\x0B\f\r`。

  ```java
  String str = " ";
  System.out.println(str.matches("\\s")); // true
  String str2 = "a";
  System.out.println(str2.matches("\\s")); // false
  ```

- `\S` 匹配任意非空白字符。

  ```java
  String str = "a";
  System.out.println(str.matches("\\S")); // true
  String str2 = " ";
  System.out.println(str2.matches("\\S")); // false
  ```

### 6.小结：手机号与邮箱匹配

判断以下字符串是否为手机或邮箱。

`String phone = "13812345678";`
`String email = "test@example.com";`

```

```



# 14，异常

## 1.认识异常

​	这玩意就是代码出问题了就会炸出来了。

​	异常似乎就是继承于 `Java.lang.Throwable` 类。

​	下属 `error` 和 `Exception`。

​	前者不用管，后者才是写代码会炸出来的报错。

​	写代码炸出来的各种奇怪异常基本就是继承 `Exception` 类了。

​	这玩意下面还有两大类。

​	`RuntimeExcetion` 运行时异常，与编译时异常。

## 2.获取异常

​	抛出或捕获。

​	抛出就是向上级（谁调用的这段代码）丢过去，让上级自己处理去。

```java
方法 throws 异常1, ..., 异常n {
    ...
}
```

​	捕获就是当场抓住，可以选择处理，也可以就地掩埋（不让异常向上级跑，算是把异常藏起来了）。

​	不过这种 “ 屏蔽 ” 异常的操作有点不妥就是了（比如快要展示项目了，藏起来躲一下还是可以的）。

```java
try {
    // 可能炸异常的代码
} catch (异常类型 变量) {
    // 处理
} catch (异常类型 变量) {
    // 处理
}...
```

​	而且，捕获也是挺好玩的。

​	除了上面最基本的捕获结构。

​	先来个 Pro 版。

​	这玩意不管上面怎么搞，finally 中的代码一定会执行（除非 JVM 直接死了，剩下不管什么代码都不会跑了）。

```java
try {
    // 可能炸异常的代码
} catch (异常类型 变量) {
    // 处理
} finally {
    // 语句（一般多用于释放或关闭 try 中使用的资源）
}
```

​	然后就是 ProMax 版。

​	把释放块干到 try 的小括号里，让代码优雅多了。

​	小括号内开启的资源（一般只能是实现了 AutoCloseable 接口的类）会在整个 try 结构执行完后自动关闭释放。

```java
try (使用的资源){
    // 可能炸异常的代码
} catch (异常类型 变量) {
    // 处理
}
```

## 3.自定义异常

​	Java 不会把所有异常都给出预设。

​	有些独特的异常，或自己觉得这算是异常之类的情况下就要使用自定义异常了。

​	可以自己定义何时炸，炸完怎么处理。

​	继承一下 `Exception` 就行。

```java
// 定义自定义异常
class CustomException extends Exception {
    public CustomException(String message) {
        super(message);
    }
}

// 使用自定义异常
public class Main {
    public static void main(String[] args) {
        try {
            divide(10, 0); // 测试自定义异常
        } catch (CustomException e) {
            System.out.println("捕获到自定义异常: " + e.getMessage());
        }
    }

    public static void divide(int a, int b) throws CustomException {
        if (b == 0) {
            throw new CustomException("除数不能为零！");
        }
        System.out.println("结果: " + (a / b));
    }
}
```

## 4.处理异常

​	要么记录异常并告知用户，要么当场试图处理一下。

​	前一种方法通常用于无法直接处理异常的情况。

​	如文件未找到，网络异常啥的。

​	你可以捕获异常并记录错误信息。

​	然后通过某种方式（如日志、消息框、电子邮件等）告知用户。

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ExceptionHandlingExample {

    public static void main(String[] args) {
        String filePath = "file.txt"; // 文件路径

        try {
            printFileContents(filePath);
        } catch (FileNotFoundException e) {
            // 记录异常并告知用户
            System.err.println("错误: 文件未找到 - " + filePath);
            logError(e); // 记录错误信息
        } catch (Exception e) {
            // 捕获其他未知异常
            System.err.println("程序中发生了未知错误: " + e.getMessage());
            logError(e); // 记录错误信息
        } finally {
            // 无论是否发生异常都会执行的代码
            System.out.println("异常处理完成。");
        }
    }

    public static void printFileContents(String filePath) throws FileNotFoundException {
        File file = new File(filePath);
        Scanner scanner = new Scanner(file);

        try {
            // 读取文件内容
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } finally {
            // 文件关闭逻辑
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void logError(Exception e) {
        // 记录错误信息到日志文件或控制台
        System.err.println("错误详情: " + e.getMessage());
        e.printStackTrace(); // 打印堆栈跟踪
    }
}
```

​	后一种方法用于可以直接处理异常的情况。

​	如直接再试一次，默认操作等。

​	你可以在捕获异常后，尝试采取一些补救措施。

​	例如重试操作、提供默认值、回滚事务等。

```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class ExceptionHandlingExample {

    public static void main(String[] args) {
        String filePath = "file.txt"; // 文件路径

        try {
            printFileContents(filePath);
        } catch (FileNotFoundException e) {
            // 当场处理异常
            handleFileNotFoundException(filePath);
        } catch (Exception e) {
            // 捕获其他未知异常
            System.err.println("程序中发生了未知错误: " + e.getMessage());
        } finally {
            // 无论是否发生异常都会执行的代码
            System.out.println("异常处理完成。");
        }
    }

    public static void printFileContents(String filePath) throws FileNotFoundException {
        File file = new File(filePath);
        Scanner scanner = new Scanner(file);

        try {
            // 读取文件内容
            while (scanner.hasNextLine()) {
                System.out.println(scanner.nextLine());
            }
        } finally {
            // 文件关闭逻辑
            if (scanner != null) {
                scanner.close();
            }
        }
    }

    public static void handleFileNotFoundException(String filePath) {
        // 提供默认值或提示用户重新输入文件路径
        System.out.println("文件未找到，使用默认文件路径: " + filePath);
        // 这里可以尝试重新读取文件或使用默认数据
    }
}
```

# 15，集合框架

## 1.集合体系

​	两种，单列集合与双列集合。

​	单列集合（`Collection`）就是只有一组数据。

​	双列集合（`Map`）就是在一组数据外，还有一组一一对应的，类似编号或识别符的标记组。

​	所以单列集合每个元素只包含一个值，双列包含两个值。

## 2.单列集合

​	单列集合派生实现类有：

​	祖宗，`Collection<E>`。

​	`Collection<E>` 派生，`List<E>` 和 `Set<E>`。

​	`List<E>` 派生，`ArrayList<E>` 和 `LinkedList<E>`。

​	`Set<E>` 派生，`HashSet<E>` 和 `TreeSet<E>`。

​	`HashSet<E>` 派生，`LinkedHashSet<E>`。

​	其中，内部属性上的区别有：

​	`ArrayList<E>` ， `LinkedList<E>`：有序，可重复，有索引。

​	`HashSet<E>`：无序，不重复，无索引。

​	`LinkedHashSet<E>`：有序，不重复，无索引。

​	`TreeSet<E>`：按大小默认升序，不重复，无索引。

​	`Collection<E>` 祖宗传下来的方法有：

```java
// public boolean add(E e) 向集合添加一个对象
List<String> list = new ArrayList<>();
list.add("Apple");
System.out.println("集合内容: " + list);

// public void clear() 清空集合所有元素
List<String> list = new ArrayList<>();
list.add("Apple");
list.clear();
System.out.println("清空后的集合内容: " + list);

// public boolean remove(E e) 删除指定对象
List<String> list = new ArrayList<>();
list.add("Apple");
list.remove("Apple")
System.out.println("集合内容: " + list);

// public boolean contains(Object obj) 判断是否包含指定对象
List<String> list = new ArrayList<>();
list.add("Apple");
System.out.println("集合是否包含 'Banana': " + list.contains("Banana"));

// public boolean isEmpty() 判断集合是否为空
List<String> list = new ArrayList<>();
System.out.println("集合是否为空: " + list.isEmpty());

// public int size() 返回集合元素数量
List<String> list = new ArrayList<>();
list.add("Apple");
System.out.println("集合大小: " + list.size());

// public Object[] toArray() 将集合所有元素存到数组中
List<String> list = new ArrayList<>();
list.add("Apple");
Object[] array = list.toArray();
System.out.println("集合转换为数组: " + Arrays.toString(array));

// public static <T> List<T> asList(T... a) 将数组转换成固定大小的List（好用！尤其是初始化List预备值（谁叫List初始化不能像数组一样预填值））
List<String> list = new ArrayList<>(Arrays.asList("广州", "深圳", "佛山"));
System.out.println(list);
```

​	`List<E>` 的方法有（祖宗的它也能用，没有消失）：

```java
// void add (int index, E element) 在指定位置插入元素
// E remove(int index) 删除指定位置元素，返回被删除的元素
// E set(int index, E element) 修改指定位置元素，返回被修改的元素
// E get(int index) 返回指定位置的元素

List<String> list = new ArrayList<>();
    list.add("Apple");
    list.add("Banana");
    list.add("Orange");
    list.add("Grape");

    // 输出初始集合
    System.out.println("初始集合: " + list);

    // 在指定位置插入元素
    list.add(2, "Mango");
    System.out.println("在索引 2 插入 'Mango' 后: " + list);

    // 删除指定位置的元素
    String removed = list.remove(1);
    System.out.println("删除索引 1 的元素 '" + removed + "' 后: " + list);

    // 修改指定位置的元素
    String old = list.set(2, "Pineapple");
    System.out.println("将索引 2 的元素 '" + old + "' 修改为 'Pineapple' 后: " + list);

    // 获取指定位置的元素
    String fruit = list.get(1);
    System.out.println("索引 1 的元素: " + fruit);
}
```

​	`LinkedList<E>` 基于双链表，有增删特化，就是查询慢。

​	反正根据这个增删特化给出了特有方法。

```java
// public void addFirst(E e) 在开头插入元素
// public void addLast(E e) 在末尾追加元素
// public E getFirst() 返回第一个元素
// public E getLast() 返回最后一个元素
// public E removeFirst() 删除第一个元素
// public E removeLast() 删除最后一个元素

LinkedList<String> linkedList = new LinkedList<>();

// 在开头插入元素
linkedList.addFirst("Apple");
linkedList.addFirst("Banana");
System.out.println("链表内容: " + linkedList);

// 在末尾追加元素
linkedList.addLast("Orange");
linkedList.addLast("Grape");
System.out.println("链表内容: " + linkedList);

// 获取第一个和最后一个元素
System.out.println("第一个元素: " + linkedList.getFirst());
System.out.println("最后一个元素: " + linkedList.getLast());

// 删除第一个和最后一个元素
System.out.println("删除第一个元素: " + linkedList.removeFirst());
System.out.println("删除最后一个元素: " + linkedList.removeLast());
System.out.println("链表内容: " + linkedList);
```

​	剩下的 `HashSet<E>`，`LinkedHashSet<E>`，`TreeSet<E>` 似乎就没啥自己的方法了。

​	全是直接用的祖宗类的方法。

​	使用时。

​	若需要记录添加顺序，储存重复元素，频繁调用数据，使用 `ArrayList`。

​	若需要记录添加顺序，首尾操作较多，使用 `LinkedList`。

​	若不管添加顺序，不用重复数据，求 CURD 的效率，使用 `HashSet`。

​	若需要记录添加顺序，不用重复数据，求 CURD 的效率，使用 `LinkedHashSet`。

​	若需要排序元素，不用重复数据，求 CURD 的效率，使用 `TreeSet`。

## 3.单列迭代

​	第一种方法就是 `Iterator` 接口，用于遍历集合中的元素。

​	用于遍历集合（和手写循环结构作用一样）。

​	但比起手写循环结构，这玩意更方便。

```java
// Iterator<E> iterator() 返回集合中的迭代对象，默认指向第一个元素
// boolean hasNext() 检查当前位置是否存在元素
// E next() 获取当前位置的元素，迭代器指向下一个元素

List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Orange");
list.add("Grape");

// 获取迭代器
Iterator<String> iterator = list.iterator();

// 遍历集合并打印长度大于5的元素
while (iterator.hasNext()) {
    String fruit = iterator.next();
    if (fruit.length() > 5) {
        System.out.println(fruit);
    }
}
```

​	然后是增强 for 循环。

​	就是结构变了的 for 循环结构。

​	除了集合，数组也可以用这个。

```java
// for (类型 名称 : 遍历目标) {}

List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Orange");
list.add("Grape");

for (String value : list) {
    System.out.println(value);
}
```

## 4.Collections工具类

​	专门用来操作集合的玩意。

```java
// public static <T> addAll(Collection<? super T> c, T...element) 给集合批量添加元素
// public static void shuffle(List<?> list) 打乱List集合中的元素顺序
// public static <T> void sort(List<T> list) 升序List集合中的元素
// public static <T> void sort(List<T> list, Comparator<? super T> c) 对比Lits集合中的元素，按照指定规则排序

// 创建一个集合
List<String> list = new ArrayList<>();

// 使用 addAll 方法批量添加元素
Collections.addAll(list, "Apple", "Banana", "Orange", "Grape");
System.out.println("初始集合: " + list);

// 使用 shuffle 方法打乱顺序
Collections.shuffle(list);
System.out.println("打乱后的集合: " + list);

// 使用 sort 方法升序排序
Collections.sort(list);
System.out.println("升序排序后的集合: " + list);

// 使用 sort 方法和自定义比较器降序排序
Collections.sort(list, (a, b) -> b.compareTo(a));
System.out.println("降序排序后的集合: " + list);
```

## 5.小结：斗地主

​	**牌的组成**：

​	总共有54张牌。

​	点数：3, 4, 5, 6, 7, 8, 9, 10, J, Q, K, A, 2。

​	花色：♠, ♥, ♦, ♣。

​	大小王：大王, 小王。

​	**游戏规则**：

​	斗地主：发出51张牌，剩下3张作为底牌。

​	**功能实现**：

​	在启动游戏房间时，提前准备好54张牌。

​	完成洗牌、发牌、对牌排序、看牌等功能。

​	**提示：**

​	**创建牌**：

​	生成54张牌，包括点数和花色。

​	包括大小王。

​	**洗牌**：

​	使用随机算法打乱牌的顺序。

​	**发牌**：

​	将51张牌发给玩家（不用分给四个人，全给一个人就行）。

​	剩下的3张牌作为底牌。

​	**对牌排序**：

​	按照一定的规则对玩家的牌进行排序。

​	**看牌**：

​	显示玩家的牌和底牌。

```java
// 洗牌
String[] num = new String[]{
    "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K", "A", "2"
};
String[] type = new String[]{
    "♠", "♥", "♣", "♦"
};
ArrayList<String> cards = new ArrayList<>();
for (int i = 0; i < num.length; i++) {
    for (int j = 0; j < type.length; j++) {
        cards.add(type[j] + num[i]);
    }
}
cards.add("小王");
cards.add("大王");
Collections.shuffle(cards);

// 发牌
ArrayList<String> diPai = new ArrayList<>();
ArrayList<String> yongHuPai = new ArrayList<>();
for (int i = 0; i < 3; i++) {
    diPai.add(cards.get(0));
    cards.remove(0);
}
yongHuPai = cards;

// 排序
Collections.sort(yongHuPai);

// 看牌
System.out.println(yongHuPai);
System.out.println(diPai);
```

## 6.双列集合

​	就是 `Map` 集合。

​	每个数据都是一对，一个键，一个值。

​	所以也叫键值对。

​	`{key1 = value1, key2 = value2}` 大概长这样。

​	键不允许重复，值可以。

​	双列集合派生实现类有：

​	祖宗，`Map<K, V>`。

​	`Map<K, V>` 派生，`HashMap<K, V>` 和 `TreeMap<K, V>`。

​	`HashMap<K, V>` 派生，`LinkedHashMap<K, V>`。

​	其中，内部属性上的区别有：

​	`HashMap<E>` ：无序，不重复，无索引。

​	`LinkedHashMap<E>`：有序，不重复，无索引。

​	`TreeMap<E>`：按大小默认升序排序，不重复，无索引。

​	`Map<K, V>` 祖宗传下来的方法有：

```java
// public V put(K key, V value) 添加元素
// public int size() 获取集合长度
// public void clear() 清空集合
// public boolean isEmpty() 判断集合是否为空
// public V get(Object key) 根据键获取值
// public V remove(Object key) 根据键删除元素
// public boolean containsKey(Object key) 判断是否包含某键
// public boolean containsValue(Object value) 判断是否包含某值
// public Set<K> keySet() 获取全部键的集合
// public Collection<V> values() 获取Map集合的全部值


import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapExample {
    public static void main(String[] args) {
        // 创建一个映射
        Map<String, Integer> map = new HashMap<>();

        // 添加键值对
        System.out.println("添加键值对 'Apple' -> 1: " + map.put("Apple", 1)); // null
        System.out.println("添加键值对 'Banana' -> 2: " + map.put("Banana", 2)); // null
        System.out.println("添加键值对 'Orange' -> 3: " + map.put("Orange", 3)); // null
        System.out.println("添加键值对 'Apple' -> 4: " + map.put("Apple", 4)); // 1

        // 输出映射内容
        System.out.println("映射内容: " + map);

        // 获取映射大小
        System.out.println("映射大小: " + map.size());

        // 清空映射
        map.clear();
        System.out.println("清空后的映射内容: " + map);

        // 判断映射是否为空
        System.out.println("映射是否为空: " + map.isEmpty());

        // 添加键值对
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Orange", 3);

        // 根据键获取值
        System.out.println("获取键 'Banana' 的值: " + map.get("Banana")); // 2

        // 删除键值对
        System.out.println("删除键 'Orange' 的值: " + map.remove("Orange")); // 3

        // 判断是否包含键
        System.out.println("映射是否包含键 'Apple': " + map.containsKey("Apple")); // true

        // 判断是否包含值
        System.out.println("映射是否包含值 2: " + map.containsValue(2)); // true

        // 获取所有键的集合
        Set<String> keys = map.keySet();
        System.out.println("所有键的集合: " + keys);

        // 获取所有值的集合
        Collection<Integer> values = map.values();
        System.out.println("所有值的集合: " + values);
    }
}
```

## 7.双列遍历

​	双列集合有专门的方法。

​	不用单列集合的方法（要用也用不了的，结构都不一样）。

​	键找值：

```java
// public Set<K> keySet() 获取所有键的集合
// public V get(Object key) 根据键获取对应的值

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapExample {
    public static void main(String[] args) {
        // 创建一个映射
        Map<String, Integer> map = new HashMap<>();

        // 添加键值对
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Orange", 3);
        map.put("Grape", 4);

        // 获取所有键的集合
        Set<String> keys = map.keySet();

        // 双列遍历
        for (String key : keys) {
            Integer value = map.get(key);
            System.out.println("键: " + key + ", 值: " + value);
        }
    }
}
```

​	键值对：

```java
// Set<Map.Entery<K, V>> entrySet() 获取所有键值对集合
// K getKey() 获取键
// V getValue() 获取值

import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapExample {
    public static void main(String[] args) {
        // 创建一个映射
        Map<String, Integer> map = new HashMap<>();

        // 添加键值对
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Orange", 3);
        map.put("Grape", 4);

        // 获取所有键值对的集合
        Set<Map.Entry<String, Integer>> entries = map.entrySet();

        // 双列遍历
        for (Map.Entry<String, Integer> entry : entries) {
            String key = entry.getKey();
            Integer value = entry.getValue();
            System.out.println("键: " + key + ", 值: " + value);
        }
    }
}
```

​	最后就是我到写这篇文档为止也没搞懂的死人 Lamdba。

​	但别说，死人 Lamdba 确实语法简介很多很多。

​	看着也舒服。

​	（就是看不懂罢了）。

```java
// default void forEach(BiConsumer<? super K, ? super V> action) 结合Lamdba遍历集合

import java.util.HashMap;
import java.util.Map;

public class MapExample {
    public static void main(String[] args) {
        // 创建一个映射
        Map<String, Integer> map = new HashMap<>();

        // 添加键值对
        map.put("Apple", 1);
        map.put("Banana", 2);
        map.put("Orange", 3);
        map.put("Grape", 4);

        // 使用 forEach 方法遍历键值对
        map.forEach((key, value) -> {
            System.out.println("键: " + key + ", 值: " + value);
        });
    }
}
```

## 8.小结：统计投票结果

​	一个班60人。

​	准备出去玩。

​	选择 A，B，C 三个地方。

​	统计这三个地方分别被投了多少票。

```java
int num = 60;
String[] place = new String[]{"A", "B", "C"};
Map results = new LinkedHashMap();
for (int i = 0; i < num; i++) {
    results.put(i + 1, place[(int)(Math.random() * 4 - 1)]);
}
results.forEach((key, value) -> {
    System.out.println(key + "号学生选择了：" + value);
});
```

## 9.集合嵌套

​	就是集合里面装集合。

​	如需要一套数据。

​	里面保存几个省里面的几个市。

​	可以用 `Map` 套 `List`。

```java
Map<String, ArrayList<String>> a = new LinkedHashMap();
a.put("广东省", new ArrayList<>(Arrays.asList("珠海", "中山")));
a.put("湖南省", new ArrayList<>(Arrays.asList("张家界市", "常德市")));
System.out.println(a);
```

# 16，Stream 流

## 1.获取流

​	用于操作集合的数据。

​	比起集合框架的原生 API，这玩意更简洁，更强大。

​	但还是和 Lamdba 扯上关系了（正则和Lamdba，两个死人玩意）。

​	可以把这玩意比作专门处理集合的流水线。

​	数据源经历过滤，排序，去重等操作，然后取获得理结果。

​	首先就是获取 Stream 流。

```java 
String[] array = {"Apple", "Banana", "Orange"};
List<String> list = new ArrayList<>();
list.add("Apple");
list.add("Banana");
list.add("Orange");
	
// default Stream<E> stream() 获取当前集合对象的Stream流
Stream<String> listStream = list.stream();
listStream.forEach(System.out::println);

// public static<T> Stream<T> of(T... values) 获取当前接收数据的Stream流
Stream<String> stringStream = Stream.of("Apple", "Banana", "Orange");
stringStream.forEach(System.out::println);
```

## 2.操作流

​	这玩意处理完流之后，会返回新的处理后的流。

​	且这玩意支持链式调用，刚使用某个方法处理完就能紧接着使用另一个方法继续处理，不用中断。

```java
// Stream<T> filter(Predicate<? super T> predicate) 过滤
// Stream<T> sorted() 升序排序
// Stream<T> sorted(Comparator<? super ? T> comparator) 制定规则排序
// Stream<T> limit(long maxSize) 获取前几个元素
// Stream<T> skip(long n) 跳过前几个元素
// Stream<T> distinct() 去重
// <R> Stream<R> map(Function<? super T, ? extends R> mapper) 将每个元素映射为新的元素
// Optional<T> reduce(BinaryOperator<T> accumulator) 对流元素进行规约操作，让每个元素（可以指定规则）拼接在一起
// public T orElse(T other) 定义流为空的情况
// static <T> Stream<T> concat(Stream a, Stream b) 合并两个流


import java.util.Arrays;
import java.util.List;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamIntermediateOperations {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Apple", "Banana", "Orange", "Apple", "Grape");

        // 使用 filter 方法过滤出长度大于5的元素
        List<String> filteredList = list.stream()
                .filter(s -> s.length() > 5)
                .collect(Collectors.toList());
        System.out.println("过滤后的列表: " + filteredList);

        // 使用 sorted 方法进行升序排序
        List<String> sortedList = list.stream()
                .sorted()
                .collect(Collectors.toList());
        System.out.println("升序排序后的列表: " + sortedList);

        // 使用 sorted 方法和自定义比较器进行降序排序
        List<String> sortedListDesc = list.stream()
                .sorted((a, b) -> b.compareTo(a))
                .collect(Collectors.toList());
        System.out.println("降序排序后的列表: " + sortedListDesc);

        // 使用 limit 方法获取前3个元素
        List<String> limitedList = list.stream()
                .limit(3)
                .collect(Collectors.toList());
        System.out.println("前3个元素: " + limitedList);

        // 使用 skip 方法跳过前2个元素
        List<String> skippedList = list.stream()
                .skip(2)
                .collect(Collectors.toList());
        System.out.println("跳过前2个元素后的列表: " + skippedList);

        // 使用 distinct 方法去重
        List<String> distinctList = list.stream()
                .distinct()
                .collect(Collectors.toList());
        System.out.println("去重后的列表: " + distinctList);

        // 使用 map 方法将字符串转换为大写
        List<String> upperedList = list.stream()
                .map(String::toUpperCase)
                .collect(Collectors.toList());
        System.out.println("转换为大写后的列表: " + upperedList);

        // 使用 concat 方法合并两个流
        Stream<String> stream1 = Stream.of("Apple", "Banana");
        Stream<String> stream2 = Stream.of("Orange", "Grape");
        List<String> concatenatedList = Stream.concat(stream1, stream2)
                .collect(Collectors.toList());
        System.out.println("合并后的列表: " + concatenatedList);
    }
}
```

## 3.终止流

​	指调用完成后，不会返回新的 Stream 流了，没法继续使用它了。

```java
// void forEach(Consumer action) 遍历流运算后的元素
// long count() 统计流运算后的元素个数
// Optional<T> max(Comparator<? super T> comparator) 获取流运算后的最大值元素
// Optional<T> min(Comparator<? super T> comparator) 获取流运算后的最小值元素

import java.util.Arrays;
import java.util.Comparator;
import java.util.List;
import java.util.Optional;
import java.util.stream.Stream;

public class StreamTerminalOperations {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Apple", "Banana", "Orange", "Grape");

        // 使用 forEach 方法遍历流中的元素
        list.stream()
            .forEach(System.out::println);

        // 使用 count 方法统计流中的元素个数
        long count = list.stream()
            .count();
        System.out.println("元素个数: " + count);

        // 使用 max 方法获取流中的最大值元素
        Optional<String> max = list.stream()
            .max(Comparator.naturalOrder());
        System.out.println("最大值: " + max.orElse("空"));

        // 使用 min 方法获取流中的最小值元素
        Optional<String> min = list.stream()
            .min(Comparator.naturalOrder());
        System.out.println("最小值: " + min.orElse("空"));
    }
}
```

​	最终处理完之后的流就可以把它重新装回集合或数组里了。

```java
// R collect(Collector collector) 把结果装进集合
// Object[] toArray() 把结果装进数组
// public static <T> Collector toList() 把元素装进List集合
// public static <T> Collector toSet() 把元素装进Set集合
// public static Collector toMap(Function keyMapper, Function valueMapper) 把元素装进Map集合

import java.util.*;
import java.util.stream.Collectors;
import java.util.stream.Stream;

public class StreamCollectExamples {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Apple", "Banana", "Orange", "Grape");

        // 使用 collect 方法将流中的元素收集到一个列表中
        List<String> collectedList = list.stream()
                .collect(Collectors.toList());
        System.out.println("收集到的列表: " + collectedList);

        // 使用 collect 方法将流中的元素收集到一个集合中
        Set<String> collectedSet = list.stream()
                .collect(Collectors.toSet());
        System.out.println("收集到的集合: " + collectedSet);

        // 使用 collect 方法将流中的元素收集到一个映射中
        Map<String, Integer> collectedMap = list.stream()
                .collect(Collectors.toMap(
                        s -> s, // 键映射
                        s -> s.length() // 值映射
                ));
        System.out.println("收集到的映射: " + collectedMap);

        // 使用 toArray 方法将流中的元素收集到一个数组中
        Object[] array = list.stream()
                .toArray();
        System.out.println("收集到的数组: " + Arrays.toString(array));

        // 使用 toArray 方法将流中的元素收集到一个指定类型的数组中
        String[] stringArray = list.stream()
                .toArray(String[]::new);
        System.out.println("收集到的字符串数组: " + Arrays.toString(stringArray));
    }
}
```

# 17，阶段案例

## 1.吃枪子

​	**需求**

​	目前有100名囚犯，每个因犯的编号是1-200之间的随机数。

​	现在要求依次随机生成100名因犯的编号(要求这些因犯的编号是不能重复的)。

​	然后让他们依次站成一排。(注:位置是从1开始计数的)。

​	接下来，国王命令手下先干掉全部奇数位置处的人。

​	剩下的人，又从新按位置1开始，再次干掉全部奇数位置处的人，依此类推。

​	直到最后剩下一个人为止，剩下的这个人为幸存者。

​	**具体功能点的要求如下**
​	请输出幸存者的编号，以及他第一次所占的位置值是多少。
​	**评分细则**
​	能生产100个随机编号，且占位成功的，给3分
​	能成功删除奇数位置处的数据的，给5分。
​	能正确获取结果的给2分。

```java
import java.util.ArrayList;
import java.util.Collections;

public class Main {
    public static void main(String[] args) {
        /*
            17.1
        */
        // 1.为100个家伙分配不重复的1-200之间的编号
        ArrayList<Integer> idList = new ArrayList<Integer>();
        int min = 1;
        int max = 200;
        while (idList.size() < 100) {
            int newId = (int)(Math.random() * max - min) + min;
            if (!idList.contains(newId)) {
                idList.add(newId);
            }
        }
        System.out.println("一共" + idList.size() + "人");

        // 升序
        Collections.sort(idList);
        System.out.println("分配的编号：" + idList);

        // 给奇数编号的家伙吃子弹，直到只剩最后一个人
        while (idList.size() > 1) {
            System.out.println();
            // 拉出奇数编号
            ArrayList<Integer> killList = new ArrayList<>();
            for (int i = 0; i < idList.size(); i += 2) {
                killList.add(i);
            }
            System.out.println("本次干掉" + killList.size() + "人");
            // 吃子弹
            for (int i = killList.size() - 1; i >= 0 ; i--) {
                idList.remove(killList.get(i).intValue());
            }
            System.out.println("还剩：" + idList);
        }
    }
}
```

​	就差最后一步就算是自己写出来了。

​	`for (int i = killList.size() - 1; i >= 0 ; i--) {}` ™没给 `killKist.size()` 减一。

​	就这一个地方AI给检查出问题了。

## 2.构建与解析

​	private Long Longid; //用户id 

​	private String name; //用户姓名

​	private String gender; //性别

​	private LocalDate birthday; //生日

​	注意需要提供 set和get方法，以及toString方法

​	**业务一**

​	有如下字符申，里面包含多个用户信息数据。

​	现在需要你解析这个字符申。

​	获取里面的用户数据，并封装到User对象中。

​	多个User对象在添加到List<user>集合中。

```java
String userstrs = "10001:张三:男:1990-01-01#" +
        "10002:李四:女:1989-01-09#" +
        "10003:王五:男:1999-09-09#" +
        "10004:刘备:男:1899-01-01#" +
        "10005:孙悟空:男:1900-01-01#" +
        "10006:张三:女:1999-01-01#" +
        "10007:刘备:女:1999-01-01#" +
        "10008:张三:女:2003-07-01#" +
        "10009:猪八戒:男:1900-01-01";
```

​	字符串中的规则如下。

​	多个用户用 # 拼接。

​	用户的信息之间用:拼接。

​	其中用户id和生日是需要进行类型转换的。

​	其中id需要将String转成Long。

​	生日需要将String转成LocalDate。

​	**业务二**

​	遍历上面获取的List<user>集合，统计里面每个名字出现的次数。

​	封装到Map<String,Integer>集合中，集合的key就是名字，value就是名字出现的次数。

​	最后遍历打印map数据，打印内容如下：

​	张三:3次

​	李四:5次

```java
import java.time.LocalDate;

public class User {
    private long LongId;
    private String name;
    private String gender;
    private LocalDate birthday;

    public User() {
    }

    public User(long longId, String name, String gender, LocalDate birthday) {
        this.LongId = longId;
        this.name = name;
        this.gender = gender;
        this.birthday = birthday;
    }

    public long getLongId() {
        return LongId;
    }

    public void setLongId(long longId) {
        LongId = longId;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getGender() {
        return gender;
    }

    public void setGender(String gender) {
        this.gender = gender;
    }

    public LocalDate getBirthday() {
        return birthday;
    }

    public void setBirthday(LocalDate birthday) {
        this.birthday = birthday;
    }

    @Override
    public String toString() {
        return "User{" +
                "LongId=" + LongId +
                ", name='" + name + '\'' +
                ", gender='" + gender + '\'' +
                ", birthday=" + birthday +
                '}';
    }
}
```

```java
import java.time.LocalDate;
import java.util.*;

public class Main {
    public static void main(String[] args) {
        /*
            17.2
        */
        // 初始字符串
        String userStr = "10001:张三:男:1990-01-01#" +
                "10002:李四:女:1989-01-09#" +
                "10003:王五:男:1999-09-09#" +
                "10004:刘备:男:1899-01-01#" +
                "10005:孙悟空:男:1900-01-01#" +
                "10006:张三:女:1999-01-01#" +
                "10007:刘备:女:1999-01-01#" +
                "10008:张三:女:2003-07-01#" +
                "10009:猪八戒:男:1900-01-01";

        // 把用户数据装进嵌套集合
        ArrayList<ArrayList<String>> userList = new ArrayList<>();
        // 分离用户
        String[] cutUser = userStr.split("#");
        for (int i = 0; i < cutUser.length; i++) {
            // 分离用户信息
            ArrayList<String> userMessage = new ArrayList<>();
            String[] message = cutUser[i].split(":");
            for (int j = 0; j < message.length; j++) {
                userMessage.add(message[j]);
            }
            // 填入集合
            userList.add(userMessage);
        }
        System.out.println("用户信息组为：");
        for (ArrayList<String> user : userList) {
            System.out.println(user);
        }

        // 用这些数据建立对象
        ArrayList<User> users = new ArrayList<>();
        for (ArrayList<String> user : userList) {
            users.add(new User(Long.parseLong(user.get(0)), user.get(1), user.get(2), LocalDate.parse(user.get(3))));
        }
        System.out.println();
        System.out.println("用户对象组为：");
        for (User user : users) {
            System.out.println(user.toString());
        }

        // 统计名字出现次数
        LinkedHashMap<String, Integer> repeat = new LinkedHashMap();
        // 初始化集合
        for (User user : users) {
            if (!repeat.containsKey(user.getName())) {
                repeat.put(user.getName(), 1);
            } else {
                repeat.put(user.getName(), repeat.get(user.getName()) + 1);
            }
        }
        System.out.println("用户名重复次数为：");
        System.out.println(repeat);
    }
}
```

​	字符串转 Long，和字符串转 LocalDate用 AI 查了。

​	Map 修改指定键的对应值也用 AI 查了。

## 3.休息日判断

​	**需求**

​	某护士小花，作息规律为上二天班，休息一天。

​	但经常不确定休息日是否是周末(注:首次休息日是2022年2月3日)。

​	**产具体功能点的要求如下**	

​	1，请你开发一个程序，当小花输入年以及月后，立即显示出该月份的休息日详情。

​	示范(注意:示范信息重点在于参考格式，结果不一定是准确的，请自行确保计算结果正确性)

​	请小花输入查询的月份 (月份必须是2022年2月之后的月份) ：2023-5

​	2023-5-1[休息]，2023-5-2，2023-5-3，2023-5-4[休息]…

​	显示出该月份哪些休息日是周六或周日(请依次列出具体的日期和其星期信息)。

```java
import java.time.DateTimeException;
import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        /*
            17.3
        */
        // 首次休息日
        final LocalDate firstRestDay = LocalDate.of(2022, 2, 3);
        final DateTimeFormatter inputFormatter = DateTimeFormatter.ofPattern("yyyy-M");
        final DateTimeFormatter dateFormatter = DateTimeFormatter.ofPattern("yyyy-M-d");

        // 读取输入
        Scanner scanner = new Scanner(System.in);
        System.out.print("请小花输入查询的月份 (格式为yyyy-M，例如2023-5)：");
        String input = scanner.nextLine().trim();

        try {
            // 解析输入年月
            YearMonth inputYm = YearMonth.parse(input, inputFormatter);
            YearMonth minYm = YearMonth.of(2022, 2);

            // 输入验证
            if (inputYm.isBefore(minYm)) {
                System.out.println("错误：月份必须为2022年2月及之后");
                return;
            }

            // 生成当月所有日期
            List<String> dateDetails = new ArrayList<>();
            List<String> weekendRestDays = new ArrayList<>();
            int daysInMonth = inputYm.lengthOfMonth();

            for (int day = 1; day <= daysInMonth; day++) {
                LocalDate currentDate = inputYm.atDay(day);
                String dateStr = currentDate.format(dateFormatter);

                // 判断是否为休息日
                if (!currentDate.isBefore(firstRestDay)) {
                    long daysBetween = ChronoUnit.DAYS.between(firstRestDay, currentDate);
                    if (daysBetween >= 0 && daysBetween % 3 == 0) {
                        dateStr += "[休息]";
                        // 判断是否为周末
                        if (currentDate.getDayOfWeek() == DayOfWeek.SATURDAY ||
                                currentDate.getDayOfWeek() == DayOfWeek.SUNDAY) {
                            String weekStr = currentDate.getDayOfWeek() == DayOfWeek.SATURDAY ? "周六" : "周日";
                            weekendRestDays.add(dateStr.split("\\[")[0] + " " + weekStr);
                        }
                    }
                }
                dateDetails.add(dateStr);
            }

            // 输出结果
            System.out.println("\n" + inputYm.getYear() + "-" + inputYm.getMonthValue() + "月休息日详情：");
            System.out.println(String.join("\n", dateDetails));

            System.out.println("\n休息日中的周末：");
            if (weekendRestDays.isEmpty()) {
                System.out.println("本月无休息日为周末");
            } else {
                weekendRestDays.forEach(System.out::println);
            }

        } catch (DateTimeException e) {
            System.out.println("输入格式错误，请使用类似2023-5的格式");
        }
    }
}
```

​	™的做不出来，整个用 AI 查。

## 4.模拟构建框架集合

​	**需求**

​	ArrayList集合是很重要的一种集合，请手工书写一个MyArrayList集合模拟ArrayList集合。

​	**具体功能点的要求如下**

​	1、MyArrayList需要支持泛型，内部使用数组作为容器。

​	2、在MyArravList中开发add方法，用于添加数据的，需要遵循ArrayList的扩容机制(自行设计代码，不需要与ArrayList的源代码一样思想一致即可)。

​	3、在MyArrayList中开发根据索引查询数据的get方法。

​	4、在MyArrayList中开发根据索引删除数据的remove方法。

​	5、在MyArrayList中开发一个获取集合大小的size()方法。

​	6、能够在MyArravList集合中开发一个forEach方法，这个方法支持使用Lambda进行遍历，至于函数式接口叫什么名称无所谓。

​	7、编写测试用例对自己编写的MyArrayList集合进行功能正确性测试。

```java

public class Main {
    public static void main(String[] args) {
        /*
            17.4
        */
        MyArrayList myArrayList = new MyArrayList<>();
//        System.out.println(myArrayList);
        myArrayList.add(1);
        myArrayList.add("asd");
        myArrayList.add(666);
//        System.out.println(myArrayList);

//        System.out.println(myArrayList.get(-1));
//        System.out.println(myArrayList.get(0));
//        System.out.println(myArrayList.get(1));
//        System.out.println(myArrayList.get(2));
//        System.out.println(myArrayList.get(3));

//        myArrayList.remove(2);
//        System.out.println(myArrayList);
//        myArrayList.remove(-1);
//        System.out.println(myArrayList);
//        myArrayList.remove(3);
//        System.out.println(myArrayList);

//        System.out.println(myArrayList.size());

        // 定义每个遍历到的元素的操作为->后面的语句
//        myArrayList.forEach(element -> System.out.println(element));
    }
}
```

```java
import java.util.Arrays;
import java.util.function.Consumer;

public class MyArrayList<E> {
    private Object[] core = new Object[]{};

    public MyArrayList() {
    }

    public MyArrayList(Object[] core) {
        this.core = core;
    }

    @Override
    public String toString() {
        return "MyArrayList{" +
                "core=" + Arrays.toString(core) +
                '}';
    }

    /**
     * 添加值至末尾
     * @param e 任意数据类型
     */
    public void add(E e) {
        // 长度加一
        Object[] newCore = new Object[this.core.length + 1];
        // 填充旧值
        System.arraycopy(this.core, 0, newCore, 0, this.core.length);
        // 追加新值
        newCore[newCore.length - 1] = e;
        // 覆盖
        this.core = newCore;
    }

    /**
     * 根据下标返回对应值
     * @param index 指定下标
     * @return 对应值
     */
    public Object get(int index) {
        // 不可超出长度，小于长度
        if (index > this.core.length - 1) {
            System.out.println("超出长度");
            return null;
        } else if (index < 0) {
            System.out.println("未知下标");
            return null;
        }
        // 均没有问题，返回指定下标值
        return this.core[index];
    }

    /**
     * 根据下标删除对应值
     * @param index 指定下标
     */
    public void remove(int index) {
        // 不可超出长度，小于长度
        if (index > this.core.length - 1) {
            System.out.println("超出长度");
            return;
        } else if (index < 0) {
            System.out.println("未知下标");
            return;
        }
        // 长度减一
        Object[] newCore = new Object[this.core.length - 1];
        // 填充旧值，不包括指定下标
        for (int i = 0; i < this.core.length; i++) {
            if (i != index) {
                if (i > index) {
                    newCore[i - 1] = this.core[i];
                } else {
                    newCore[i] = this.core[i];
                }
            }
        }
        // 覆盖
        this.core = newCore;
    }

    /**
     * 获取长度
     * @return 长度
     */
    public int size() {
        return this.core.length;
    }

    /**
     * 使用 Lambda 遍历元素
     * @param action 每个元素
     */
    // 定义了一个允许使用 Lambda 遍历元素的方法
    // Consumer表示接收单个输入参数且不返回结果的操作
    // <? super E>泛型通配符表示允许E类型或它的父类
    public void forEach(Consumer<? super E> action) {
        // 遍历 core 数组
        for (int i = 0; i < this.core.length; i++) {
            // 用于抑制编译器想提示下面可能出现未检查的类型转换的冲动
            @SuppressWarnings("unchecked")
            // 声明一个任意元素类型，赋值为 core 数组里面的 i 位的值（因为众所周知的坏人虚拟机会搞泛型擦除，所以要重新强转为 E（任意元素） 类型）
            E element = (E) core[i];
            // 调用传入的 Lambda 表达式，将取出的元素传递过去
            action.accept(element);
        }
    }
}
```

​	死人 Lamdba 不会用，AI 了。

## 5.检索数组

​	**需求**

​	给你一个按照非递减顺序排列的整数数组 nums，和一个目标值 target。

​	请你找出给定目标值在数组中的开始位置和结束位置。

​	如果数组中不存在目标值 target，返回[-1，-1]。

​	**具体功能点的要求如下**

```java
数组 nums =[5,7,7,8,8,10]，target = 8
得到结果是:[3,4]
```
```java
数组:nums=[5,7,7,8,8,10]，target= 6
得到结果是:[-1，-1]
```

```java
数组:nums=[]，target= 0
得到结果是:[-1,-1]
```

​	请设计一个方法完成以上需求，并编写测试代码完成上述测试。

```java
public class Main {
    public static void main(String[] args) {
        /*
            17.5
        */
        // 初始化
        int[] nums = new int[]{5, 7, 7, 8, 8, 10};
        int target = 7;

        // 遍历检索位置
        int start = -1;
        int end = -1;
        boolean isEnd = false;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                end = i;
                if (!isEnd) {
                    start = i;
                    isEnd = true;
                }
            }
        }
        System.out.println(start);
        System.out.println(end);
    }
}
```

​	简单：）

## 6.反转链表

​	**需求**

​	给你单链表的头指针 head 和两个整数 left 和 right 。

​	其中 left <= right。

​	请你反转从位置 left 到位置 right 的链表节点。

​	并返回反转后的链表。

```
比如 head 指向的链表内容大致是 1, 2, 3, 4, 5，1eft =2，right = 4
反转后的链表就是 1, 4, 3, 2, 5

如果链表只有一个节点:head指向的是5，1eft=1，right=1
反转后的链表就还是5
```

​	**具体功能点的要求如下**

​	1、设计一个Node泛型类，用于代表链表的结点。每个结点包含(数据data，和下一个结点的地址值next)（3分）

​	2、开发一个类叫MyLinkedlist，提供一个add方法可以让用户添加链表的结点，直到用户输入exit，则返回链表(返回链表实际上是返回链表的头结点)（5分）

​	3、提供一个reverse方法，接收头指针 head 和两个整数 left 和 right，其中 left <= right，按上面的要求进行反转。反转后，返回新的链表（9分）
​	4、提供一个forEach方法，接收新链表，并对其进行遍历输出。（5分）

```java
public class Main {
    public static void main(String[] args) {
        /*
            17.6
        */
        // 声明一串玩意
        Node<Integer> C = new Node<>(3, null);
        Node<Integer> B = new Node<>(2, C);
        Node<Integer> A = new Node<>(1, B);
        MyLinkedList.forEach(A);

        // 添加一个节点
        A = MyLinkedList.add(A);
        System.out.println("新表：");
        MyLinkedList.forEach(A);

        // 反转区间
        A = MyLinkedList.reverse(A, 1, 3);
        // 遍历链表
        System.out.println("新表：");
        MyLinkedList.forEach(A);
    }
}
```

```java
import java.util.Scanner;

public class MyLinkedList {
    /**
     * 向链表末尾添加节点
     * @param obj 链表头节点
     * @return 链表头节点
     * @param <E> 任意类型数据
     */
    public static <E> Node<E> add(Node<E> obj) {
        // 备份头节点
        Node<E> startNode = obj;
        Scanner input = new Scanner(System.in);
        while (true) {
            System.out.println("输入下一个值（exit退出添加）：");
            String in = input.nextLine();
            if (in.isEmpty()) {
                System.out.println("别留空");
            } else if (in.equals("exit")) {
                return startNode;
            } else {
                // 深入节点
                while (obj != null) {
                    // 若为最后一个节点
                    if (obj.getNext() == null) {
                        // 给最后一个节点赋值
                        obj.setNext((Node<E>) new Node<>(in, null));
                        break;
                    }
                    // 下一个节点
                    obj = obj.getNext();
                }
            }
        }
    }

    /**
     * 反转链表内区间值
     * @param obj 链表头节点
     * @param left 区间下限
     * @param right 区间上限
     * @return 链表头节点
     * @param <E> 任意类型数据
     */
    public static <E> Node<E> reverse(Node<E> obj, int left, int right) {
        if (obj == null || left == right) {
            return obj;
        }

        Node<E> pre = null;
        Node<E> current = obj;

        // 找到pre节点（left-1位置）
        for (int i = 1; i < left; i++) {
            if (current == null) {
                return obj; // 链表长度不足left，直接返回
            }
            pre = current;
            current = current.next;
        }

        Node<E> end = current;
        // 找到end节点（right位置）
        for (int i = 0; i < right - left; i++) {
            if (end == null) {
                return obj; // 链表长度不足right，直接返回
            }
            end = end.next;
        }

        if (end == null) {
            return obj; // end为null，说明链表长度不足right
        }

        Node<E> post = end.next;

        // 反转current到end之间的节点
        Node<E> prev = null;
        Node<E> curr = current;
        Node<E> next = null;
        Node<E> tail = current; // 保存反转后的尾节点

        while (curr != end) {
            if (curr == null) {
                break; // 防止curr为null时进入循环
            }
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }

        // 处理end节点
        if (curr != null) {
            curr.next = prev;
            prev = curr;
        }

        // 连接pre和反转后的链表
        if (pre != null) {
            pre.next = prev;
        } else {
            // 如果pre是null，说明left=1，此时整个链表的新头是prev（即end节点）
            obj = prev;
        }

        // 连接反转后的尾节点和post
        if (tail != null) {
            tail.next = post;
        }

        return obj;
    }

    /**
     * 遍历链表
     * @param obj 链表头节点
     * @param <E> 任意类型数据
     */
    public static <E> void forEach(Node<E> obj) {
        while (obj != null) {
            System.out.print(obj.getData() + "   ");
            obj = obj.getNext();
        }
        System.out.println();
    }
}
```

```java
public class Node<E> {
    /**
     * 数据
     */
    private E data;
    /**
     * 下一个指向
     */
    public Node<E> next;

    public Node() {
    }

    public Node(E data, Node<E> next) {
        this.data = data;
        this.next = next;
    }

    public E getData() {
        return data;
    }

    public void setData(E data) {
        this.data = data;
    }

    public Node<E> getNext() {
        return next;
    }

    public void setNext(Node<E> next) {
        this.next = next;
    }

    @Override
    public String toString() {
        return "Node{" +
                "data=" + data +
                ", next=" + next +
                '}';
    }
}
```

​	创建链表结构问了 AI。

​	反转链表用了 AI。

# 18，输入输出流

## 1.File

​	用于代表当前操作系统的文件（或文件夹）。

​	可以获取文件信息，创建删除，判断类型等。

​	注意这玩意只对文件本身操作，和文件内部的数据无关。

​	且这玩意只存着路径而已，不存在的路径也行。

​	它就是用保存的路径来找到文件的。

​	下面就是 File 的实例方法。

```java
// public File(String pathname) 根据路径创建File对象
File file1 = new File("C:/Users/Example/Documents/file.txt"); // 绝对路径
File file2 = new File("src/main/resources/file.txt"); // 相对路径

// public File(String parent, String child) 根据父路径和子路径创建File对象
File file3 = new File("C:/Users/Example/Documents", "file.txt");
File file4 = new File("src/main", "resources/file.txt");

// public File(File parent, String child) 根据父路径File对象和子路径创建File对象
File parentDir = new File("C:/Users/Example/Documents");
File file5 = new File(parentDir, "file.txt");

File srcDir = new File("src/main");
File file6 = new File(srcDir, "resources/file.txt");
```

​	然后是 File 的常规工具方法。

```java
// public boolean exists() 判断对象地址是否存在
// public boolean isFile() 判断对象是否为文件
// public boolean isDirectory() 判断对象是否为文件夹
// public String getName() 获取文件名，包括后缀（若有）
// public long length() 获取文件大小（字节）
// public long lastModified() 获取文件最后修改时间
// public String getPath() 获取对象创建时的路径
// public String getAbsolutePath() 获取对象文件的绝对路径

import java.io.File;

public class FileExample {
    public static void main(String[] args) {
        File file = new File("C:/Users/Example/Documents/file.txt");
        
        System.out.println("文件是否存在: " + file.exists());
        System.out.println("是否是文件: " + file.isFile());
        System.out.println("是否是目录: " + file.isDirectory());
        System.out.println("文件名: " + file.getName());
        System.out.println("文件大小: " + file.length() + " 字节");
        System.out.println("最后修改时间: " + new java.util.Date(file.lastModified()));
        System.out.println("文件路径: " + file.getPath());
        System.out.println("绝对路径: " + file.getAbsolutePath());
    }
}
```

​	还有 File 的创建删除方法。

​	delete 删掉的不回去回收站的，直接没咯。

```java
// public boolean createNewFile() 创建一个文件
// public boolean mkdir() 创建一个文件夹
// public boolean mkdirs() 创建多级文件夹
// public boolean delete() 删除文件或空文件夹

import java.io.File;
import java.io.IOException;

public class FileOperations {
    public static void main(String[] args) {
        File file = new File("C:/Users/Example/Documents/newfile.txt");
        File dir = new File("C:/Users/Example/Documents/newdir");
        File multiDir = new File("C:/Users/Example/Documents/newdir/subdir");

        try {
            // 创建文件
            if (file.createNewFile()) {
                System.out.println("文件创建成功");
            } else {
                System.out.println("文件已存在");
            }

            // 创建单级目录
            if (dir.mkdir()) {
                System.out.println("单级目录创建成功");
            } else {
                System.out.println("单级目录创建失败");
            }

            // 创建多级目录
            if (multiDir.mkdirs()) {
                System.out.println("多级目录创建成功");
            } else {
                System.out.println("多级目录创建失败");
            }

            // 删除文件
            if (file.delete()) {
                System.out.println("文件删除成功");
            } else {
                System.out.println("文件删除失败");
            }

            // 删除目录
            if (dir.delete()) {
                System.out.println("目录删除成功");
            } else {
                System.out.println("目录删除失败");
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

​	最后就是遍历文件方法。

​	假设目录 `C:/Users/Example/Documents` 下有以下文件和目录：

- file1.txt
- file2.txt
- subdir

```java
// public String[] list() 获取当前目录下所有的一级文件名
// public File[] listFiles() 获取当前目录下所有的一级文件对象

import java.io.File;

public class DirectoryExample {
    public static void main(String[] args) {
        File dir = new File("C:/Users/Example/Documents");

        // 使用 list() 获取文件名
        String[] filenames = dir.list();
        if (filenames != null) {
            System.out.println("目录下的文件名：");
            for (String filename : filenames) {
                System.out.println(filename);
            }
        } else {
            System.out.println("路径不是目录或目录不存在");
        }

        // 使用 listFiles() 获取文件对象
        File[] files = dir.listFiles();
        if (files != null) {
            System.out.println("\n目录下的文件对象：");
            for (File file : files) {
                System.out.println("文件路径: " + file.getPath());
                System.out.println("是否是文件: " + file.isFile());
                System.out.println("是否是目录: " + file.isDirectory());
            }
        } else {
            System.out.println("路径不是目录或目录不存在");
        }
    }
}
```

​	主要就是第二个 listFiles 方法问题有点多。

- 当主调对象是文件，或路径不存在时，返回 null。
- 当主调对象是空文件夹时，返回长度为0的数组。
- 当主调对象是有内容的文件夹时，将所有一级文件，和一级文件夹路径干进 File 数组里返回。
- 当主调对象是文件夹，且有隐藏文件时，同上一条，且隐藏文件也会进来。
- 当主调文件是文件夹，但没有访问权限时，返回 null。

​	真麻烦。

## 2.递归

​	一种算法，很常用（我不会用）。

​	简单讲就是方法调用自己就算是递归了。

​	但一定要记得给中断条件。

​	又分直接递归和间接递归（自己调自己，A调B后B又调A）。

​	一个比较常见的例子就是算阶乘。

```java
public class Main {
    public static void main(String[] args) {
        System.out.println(go(5));
    }
    public static int go(int num) {
        // 若为1，直接退出（没得乘了）
        if (num == 1) {
            return num;
        } else {
            // 当前数 * 当前数-1（5*4，4*3，3*2，2*1，1）
            return num * go(num - 1);
        }
    }
}
```

​	总之就是：f(n) = f(n - 1) * n。

​	终止标记就是：f(1)。

​	再有一个马楼吃桃子的例子。

​	猴子第一天摘下若干桃子，当即吃了一半，觉得好不过瘾，于是又多吃了一个。

​	第二天又吃了前天剩余桃子数量的一半，觉得好不过瘾，于是又多吃了一个。

​	以后每天都是吃前天剩余桃子数量的一半，觉得好不过瘾，又多吃了一个。

​	等到第10天的时候发现桃子只有1个了。

​	请问猴子第一天摘了多少个桃子?

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("第一天有：" + go(1, 10));
    }
    public static int go(int num, int day) {
        // 若推回第一天，返回数量
        if (day == 1) {
            return num;
        } else {
            // 前一天：（今天剩余 + 1）* 2
            return go((num + 1) * 2, --day);
        }
    }
}
```

## 3.小结：搜索程序，删除文件夹

从D:盘中搜索“QQ.exe”这个文件，找到后直接输出其位置。

先找出D:盘下的所有一级文件对象。

遍历全部一级文件对象，判断是否是文件。

如果是文件，判断是否是自己想要的。

如果是文件夹，需要继续进入到该文件夹，重复上述过程。

```java
import java.io.File;

public class Main {
    public static void main(String[] args) {
        File C = new File("C:\\");
        File[] CList = C.listFiles();
        System.out.println("已搜索" + find(CList) + "个文件或文件夹");
    }

    public static int find(File[] CList) {
        int num = 0;
        if (CList != null) {
            for (File file : CList) {
                if (file.isFile()) {
                    if (file.getName().equals("QQ.exe")) {
                        System.out.println(file.getPath());
                        num++;
                    }
                    num++;
                } else {
                    num += find(file.listFiles());
                }
            }
        }
        return num;
    }
}
```

​	删除文件夹。

​	File 默认不可以删除非空文件夹。

​	我们需要遍历文件夹，先删除里面的内容，再删除自己。

```java
import java.io.File;

public class Main {
    public static void main(String[] args) {
        File target = new File("C:\\Users\\李进峰\\Desktop\\test");
        checkAndDelete(target);
    }

    public static void checkAndDelete(File target) {
        if (target.listFiles() == null) {
            target.delete();
        } else {
            for (File file : target.listFiles()) {
                if (file.isFile()) {
                    file.delete();
                } else {
                    checkAndDelete(file);
                }
            }
            target.delete();
        }
    }
}
```

## 4.字符集

​	字面意思，就是一些字符的集合。

​	每个字符在计算设备中都是有唯一编码用于识别它的。

​	字符集定义了这个字符与它的编码的映射关系。

​	主要有三种字符集。

- ASCII（美国信息交换标准代码），也是最早的字符集

​	范围是0-127（7位二进制），一个字符占1字节（8位）。

​	主要用于表示英文大小写字母，0-9数字，标点，与控制字符（回车，换行啥的）。

​	字符 'A' 的 ASCII 编码是 65，二进制表示为 `01000001`。

- GBK（中国国家标准信息交换代码），做了中文特化。

  0到127（单字节），160到254（双字节），1字节表示 ASCII，2字节表示中文（所以也兼容ASCII）。

  包含约21000个字符，主要用于表示中文。

  字符 '中' 的 GBK 编码是 `D6 D0`。

- UTF-8（Unicode转换格式-8位），能适用很多语言。

  0到127（单字节），192到244（多字节），单字节字符用于表示 ASCII 字符（0到127），多字节字符用于表示其他 Unicode 字符（英文数字1字节，符号中文三字节）。

  支持多种语言，广泛使用。

  字符 'A' 的 UTF-8 编码是 `41`，字符 '中' 的 UTF-8 编码是 `E4 B8 AD`。

  然后就是字符集的编码与解码。

  编码就是把字符编码成字节，解码就是把字节解码成字符。

  先是编码方法。

```java
// byte[] getBytes() 使用平台默认字符集编码字符
// byte[] getBytes(String charsetName) 使用指定字符集编码字符

public class StringEncodingExample {
    public static void main(String[] args) throws java.io.UnsupportedEncodingException {
        String str = "你好，世界！";

        // 使用平台默认字符集
        byte[] defaultBytes = str.getBytes();
        System.out.println("默认字符集编码: " + new String(defaultBytes));

        // 使用 UTF-8 编码
        byte[] utf8Bytes = str.getBytes("UTF-8");
        System.out.println("UTF-8 编码: " + new String(utf8Bytes, "UTF-8"));

        // 使用 GBK 编码
        byte[] gbkBytes = str.getBytes("GBK");
        System.out.println("GBK 编码: " + new String(gbkBytes, "GBK"));
    }
}
```

​	然后是解码方法。

```java
// String(byte[] bytes) 使用平台默认字符集解码字节
// String(byte[] bytes, String charsetName) 使用指定字符集解码字节

public class StringDecodingExample {
    public static void main(String[] args) throws java.io.UnsupportedEncodingException {
        String originalString = "你好，世界！";
        
        // 使用 UTF-8 编码
        byte[] utf8Bytes = originalString.getBytes("UTF-8");
        
        // 使用 GBK 编码
        byte[] gbkBytes = originalString.getBytes("GBK");

        // 使用平台默认字符集解码
        String defaultDecodedString = new String(utf8Bytes);
        System.out.println("默认字符集解码: " + defaultDecodedString);

        // 使用 UTF-8 解码
        String utf8DecodedString = new String(utf8Bytes, "UTF-8");
        System.out.println("UTF-8 解码: " + utf8DecodedString);

        // 使用 GBK 解码
        String gbkDecodedString = new String(gbkBytes, "GBK");
        System.out.println("GBK 解码: " + gbkDecodedString);

        // 错误的解码方式（编码和解码字符集不一致）
        String wrongDecodedString = new String(gbkBytes, "UTF-8");
        System.out.println("错误解码: " + wrongDecodedString);
    }
}
```

## 5.字节，字符流（原始流（低级流））

​	I 是输入流，用于把数据干进程序。

​	O 是输出流，用于把数据输出程序。

​	算是有四种类型（抽象类 / 实现类）。

​	一定注意！所有流类型使用完一定！必须！记得关闭！

​	但是吧，也少用 `close()` 方法，麻烦，丑陋。

​	用新的牛逼 Java 的 `try(...)` ，可以在结束块后自动关闭括号内的资源。

​	还有，小文件用字节流又快又方便，大文件最好用字符流。

​	字节流装不下就溢出了，溢出就毁了。

- 字节输入流（InputStream / FileInputStream）：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流。

```java
// 创建字节输入流通道，打通与文件的连接
// public FileInputStream(File file) 
// public FileInputStream(String pathname)

// 读取文件数据
// public int read() 每次读取一字节并返回，没有数据返回-1
// public int read(byte[] buffer) 每次读取字节数组容量字节并返回，没有数据返回-1
// public byte[] readAllBytes() throws IOException 一次性把整个文件全部读出来

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;

public class FileInputStreamExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 File 对象创建字节输入流
        File file = new File(filePath);
        try (FileInputStream fis = new FileInputStream(file)) {
            // 使用 read() 每次读取一个字节
            System.out.println("使用 read() 每次读取一个字节：");
            int data;
            while ((data = fis.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();

            // 重新打开文件以便再次读取
            fis.close();
            fis = new FileInputStream(file);

            // 使用 read(byte[] buffer) 每次读取字节数组容量大小的字节
            System.out.println("使用 read(byte[] buffer) 每次读取字节数组容量大小的字节：");
            byte[] buffer = new byte[5]; // 每次读取5个字节
            int length;
            while ((length = fis.read(buffer)) != -1) {
                System.out.write(buffer, 0, length);
            }
            System.out.println();

            // 重新打开文件以便再次读取
            fis.close();
            fis = new FileInputStream(file);

            // 使用 readAllBytes() 一次性读取整个文件
            System.out.println("使用 readAllBytes() 一次性读取整个文件：");
            byte[] allBytes = fis.readAllBytes();
            System.out.write(allBytes, 0, allBytes.length);
            System.out.println();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字节输出流（OutputStream / FileOutputStream）：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流。

```java
// 创建字节输出流管道，打通与文件的连接
// public FileOutputStream(File file)
// public FileOutputStream(String filepath)
// public FileOutputStream(File file, boolean append)
// public FileOutputStream(Stirng filepath, boolean append)

// 写入数据至文件
// public void write(int a) 写出一个字节
// public void write(byte[] buffer) 写出一个字节数组
// public void write(byte[] buffer, int pos, int len) 写出一个字节数的某段
// public void close() thorws IOException 关闭流

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;

public class FileOutputStreamExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 File 对象创建字节输出流
        File file = new File(filePath);
        try (FileOutputStream fos = new FileOutputStream(file)) {
            // 使用 write(int a) 写出一个字节
            fos.write('H');
            fos.write('e');
            fos.write('l');
            fos.write('l');
            fos.write('o');

            // 使用 write(byte[] buffer) 写出一个字节数组
            byte[] buffer = " World!".getBytes();
            fos.write(buffer);

            // 使用 write(byte[] buffer, int pos, int len) 写出一个字节数组的某段
            byte[] buffer2 = " Java!".getBytes();
            fos.write(buffer2, 0, 5); // 写出前5个字节

        } catch (IOException e) {
            e.printStackTrace();
        }

        // 使用追加模式写入
        try (FileOutputStream fos = new FileOutputStream(file, true)) {
            // 再次写出一个字节数组
            byte[] buffer3 = " Welcome!".getBytes();
            fos.write(buffer3);

        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("数据已写入文件: " + filePath);
    }
}
```

- 字符输入流（InputStreamReader / FileReader），以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流。

```java
// 创建字符输入流管道，打通与文件的连接
// public FileReader(File file)
// public FileReader(String pathname)

// 读取文件数据
// public int read() 读取一个字符，没有数据返回-1
// public int read(char[] buffer) 读取一个字符数组量的字符，没有数据返回-1

import java.io.File;
import java.io.FileReader;
import java.io.IOException;

public class FileReaderExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 File 对象创建字符输入流
        File file = new File(filePath);
        try (FileReader fr = new FileReader(file)) {
            // 使用 read() 每次读取一个字符
            System.out.println("使用 read() 每次读取一个字符：");
            int data;
            while ((data = fr.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();

            // 重新打开文件以便再次读取
            fr.close();
            fr = new FileReader(file);

            // 使用 read(char[] buffer) 每次读取字符数组容量大小的字符
            System.out.println("使用 read(char[] buffer) 每次读取字符数组容量大小的字符：");
            char[] buffer = new char[5]; // 每次读取5个字符
            int length;
            while ((length = fr.read(buffer)) != -1) {
                System.out.write(buffer, 0, length);
            }
            System.out.println();

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字符输出流（OutputStreamWriter / FileWriter）：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流。

```java
// 创建字符输出流管道，打通与文件的连接
// public FileWriter(File file)
// public FileWriter(String filepath)
// public FileWriter(File file, boolean append)
// public FileWriter(String filepath, boolean append)

// 写入数据至文件
// void write(int c) 写入一个字符
// void write(String str) 写入一个字符串
// void write(String str, int off, int len) 写入一个字符串的某段
// void write(char[] cbuf) 写入一个字符数组
// void write(char[] cbuf, int off, int len) 写入一个字符数组的某段

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

public class FileWriterExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 File 对象创建字符输出流
        File file = new File(filePath);
        try (FileWriter fw = new FileWriter(file)) {
            // 使用 write(int c) 写入一个字符
            fw.write('H');
            fw.write('e');
            fw.write('l');
            fw.write('l');
            fw.write('o');

            // 使用 write(String str) 写入一个字符串
            fw.write(" World!");

            // 使用 write(String str, int off, int len) 写入一个字符串的某段
            String str = " Java!";
            fw.write(str, 0, 5); // 写入前5个字符

            // 使用 write(char[] cbuf) 写入一个字符数组
            char[] chars = " Welcome!".toCharArray();
            fw.write(chars);

            // 使用 write(char[] cbuf, int off, int len) 写入一个字符数组的某段
            char[] chars2 = " Everyone!".toCharArray();
            fw.write(chars2, 0, 9); // 写入前9个字符

        } catch (IOException e) {
            e.printStackTrace();
        }

        // 使用追加模式写入
        try (FileWriter fw = new FileWriter(file, true)) {
            // 再次写入一个字符串
            fw.write(" Have a nice day!");

        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("数据已写入文件: " + filePath);
    }
}
```

## 6.缓冲流（包装流（处理流））

​	就是进一步包装的字节，字符流。

​	有更高的性能。

- 字节缓冲输入流（FileInputStream / BufferedInputStream）

  字节缓冲输出流（FileOutputStream / BufferedOutputStream）：

  均自带了 8KB 的缓冲池，可以一次性搓更大的数据量。

```java
// public BufferedInputStream(InputStream is) 把原始字节输入流包装成缓冲字节输入流
// public BufferedOutputStream(OutputStream os) 把原始字节输出流包装成缓冲字节输出流

import java.io.*;
import java.nio.file.Files;
import java.nio.file.Paths;

public class BufferedStreamExample {
    public static void main(String[] args) {
        // 文件路径
        String inputFilePath = "C:/Users/Example/Documents/example.txt";
        String outputFilePath = "C:/Users/Example/Documents/example_copy.txt";

        // 写入数据到文件
        writeData(outputFilePath);

        // 从文件读取数据
        readData(inputFilePath);

        System.out.println("操作完成！");
    }

    // 写入数据到文件
    public static void writeData(String filePath) {
        try (BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(filePath))) {
            // 使用 BufferedOutputStream 写入数据
            String data = "Hello, World!\nThis is a test.\nBufferedStream Example.";
            bos.write(data.getBytes());
            bos.flush(); // 刷新缓冲区，确保数据写入文件
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 从文件读取数据
    public static void readData(String filePath) {
        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(filePath))) {
            // 使用 BufferedInputStream 读取数据
            int data;
            while ((data = bis.read()) != -1) {
                System.out.print((char) data);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字符缓冲输入流（Reader / BufferedReader）：也是带了 8KB 缓冲池。

```java
// public BufferedReader(Reader r) 把原始字符输入流包装成缓冲字符输入流
// public String readLine() 读取一行数据，没数据返回 null

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;

public class BufferedReaderExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 BufferedReader 读取文件
        readFile(filePath);
    }

    // 读取文件
    public static void readFile(String filePath) {
        try (BufferedReader br = new BufferedReader(new FileReader(filePath))) {
            // 使用 readLine() 每次读取一行
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字符缓冲输出流（Writer / BufferedWriter）：8KB 缓冲池，没啥好说的（所有包装流就是比原始流多了个缓冲池）。

```java
// public BufferedWriter(Writer r) 把原始字符输出流包装成缓冲字符输出流
// public void newLine() 换行

import java.io.BufferedWriter;
import java.io.FileWriter;
import java.io.IOException;

public class BufferedWriterExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用 BufferedWriter 写入文件
        writeFile(filePath);
    }

    // 写入文件
    public static void writeFile(String filePath) {
        try (BufferedWriter bw = new BufferedWriter(new FileWriter(filePath))) {
            // 使用 write() 写入数据
            bw.write("Hello, World!");
            bw.newLine(); // 换行
            bw.write("This is a test.");
            bw.newLine(); // 换行
            bw.write("BufferedWriter Example.");

        } catch (IOException e) {
            e.printStackTrace();
        }

        System.out.println("数据已写入文件: " + filePath);
    }
}
```

## 7.转换流

​	又是两个基于缓冲字符输入输出流做出来的新东西。

​	用于解决输入输出时可能出现的编码不同导致的乱码问题。

- 字符转换输入流（Reader / InputStreamReader）：解决读取数据乱码。

```java
// public InputStreamReader(InputStream is) 把原始输入流按默认编码包装成字符转换输入流
// public InputStreamReader(InputStream is, String charset) 把原始输入流按指定编码包装成字符转换输入流

import java.io.*;

public class InputStreamReaderExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用默认编码
        readFileWithDefaultCharset(filePath);

        // 使用指定编码
        readFileWithSpecifiedCharset(filePath, "UTF-8");
    }

    // 使用默认编码读取文件
    public static void readFileWithDefaultCharset(String filePath) {
        try (InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath))) {
            int data;
            while ((data = isr.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 使用指定编码读取文件
    public static void readFileWithSpecifiedCharset(String filePath, String charset) {
        try (InputStreamReader isr = new InputStreamReader(new FileInputStream(filePath), charset)) {
            int data;
            while ((data = isr.read()) != -1) {
                System.out.print((char) data);
            }
            System.out.println();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字符转换输出流（Writer / OutputStreamWriter）：解决写入数据乱码。

```java
// public OutputStreamWriter(OutputStream os) 把原始输出流按默认编码包装成转换字符转换输出流
// public OutputStreamWriter(OutputStream os, String charset) 把原始输入流按指定编码包装成字符转换输出流

import java.io.*;

public class OutputStreamWriterExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用默认编码写入文件
        writeFileWithDefaultCharset(filePath);

        // 使用指定编码写入文件
        writeFileWithSpecifiedCharset(filePath, "UTF-8");
    }

    // 使用默认编码写入文件
    public static void writeFileWithDefaultCharset(String filePath) {
        try (OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath))) {
            // 写入数据
            osw.write("Hello, World!\n");
            osw.write("This is a test.\n");
            osw.write("Default Charset Example.");
            osw.flush(); // 刷新缓冲区，确保数据写入文件
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    // 使用指定编码写入文件
    public static void writeFileWithSpecifiedCharset(String filePath, String charset) {
        try (OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(filePath), charset)) {
            // 写入数据
            osw.write("Hello, World!\n");
            osw.write("This is a test.\n");
            osw.write("Specified Charset Example.");
            osw.flush(); // 刷新缓冲区，确保数据写入文件
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 8.打印流

​	这是两个基于字节，字符输出流产生的新玩意。

​	用于输出，就是写入数据至文件时，更加方便高效。

- 字节打印输出流（FilterOutputStream / PrintStream）：打印字节的。

```java
// public PrintStream(OutputStream / File / String) 直接指向字节输出流，文件，或文件路径
// public PrintStream(String fileName, Charset charset) 指定写入的编码
// public PrintStream(OutputStream out, boolean autoFlush) 指定自动刷新
// public PrintStream(OutputStream out, boolean autoFlush, String encoding) 指定自动刷新，同时指定编码

// public void println(E e) 打印任意类型数据
// public void writer(int / byte[] / byte[]某段) 写入字节数据

import java.io.*;

public class PrintStreamExample {
    public static void main(String[] args) {
        // 文件路径
        String filePath = "C:/Users/Example/Documents/example.txt";

        // 使用不同的构造方法写入文件
        writeWithPrintStream(filePath);
    }

    // 使用不同的构造方法写入文件
    public static void writeWithPrintStream(String filePath) {
        try {
            // 使用 PrintStream(OutputStream) 构造方法
            try (PrintStream ps1 = new PrintStream(new FileOutputStream(filePath))) {
                ps1.println("Hello, World!");
                ps1.write('!');
            }

            // 使用 PrintStream(String fileName, Charset charset) 构造方法
            try (PrintStream ps2 = new PrintStream(filePath, "UTF-8")) {
                ps2.println("This is a test.");
                ps2.write("UTF-8 encoding".getBytes("UTF-8"));
            }

            // 使用 PrintStream(OutputStream out, boolean autoFlush) 构造方法
            try (PrintStream ps3 = new PrintStream(new FileOutputStream(filePath, true), true)) {
                ps3.println("Auto-flush is enabled.");
                ps3.write('!');
            }

            // 使用 PrintStream(OutputStream out, boolean autoFlush, String encoding) 构造方法
            try (PrintStream ps4 = new PrintStream(new FileOutputStream(filePath, true), true, "UTF-8")) {
                ps4.println("Specified encoding and auto-flush.");
                ps4.write("Specified encoding and auto-flush.".getBytes("UTF-8"));
            }

        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 字符打印输出流（Writer / PrintWriter）：打印字符的。

```java
// public PrintWriter(OutputStream / Writer / File / String)
// public PrintWriter(String fileName, Charset charset)
// public PrintWriter(OutputStream out / Writer, boolean autoFlush)
// public PrintWriter(OutputStream out, boolean autoFlush. String encoding)

// public void println(Xxx xx)
// public void writer(int / String / char[] / ...)

import java.io.*;

public class PrintWriterDemo {
    public static void main(String[] args) {
        // 使用不同的构造方法创建PrintWriter对象
        try (
            // 使用OutputStream构造PrintWriter
            PrintWriter pw1 = new PrintWriter(new FileOutputStream("output1.txt"));
            // 使用File构造PrintWriter
            PrintWriter pw2 = new PrintWriter(new File("output2.txt"));
            // 使用String文件名构造PrintWriter
            PrintWriter pw3 = new PrintWriter("output3.txt");
            // 使用String文件名和字符集构造PrintWriter
            PrintWriter pw4 = new PrintWriter("output4.txt", "UTF-8");
            // 使用OutputStream和自动刷新标志构造PrintWriter
            PrintWriter pw5 = new PrintWriter(new FileOutputStream("output5.txt"), true);
        ) {
            // 使用println方法输出不同类型的数据
            pw1.println("Hello, PrintWriter!");
            pw1.println(123);
            pw1.println(true);
            pw1.println(new Character('A'));
            pw1.println(new Integer(456));
            pw1.println(new Double(3.14));
            pw1.println(new String("Java Programming"));

            // 使用write方法输出数据
            pw2.write("This is written using write method.");
            pw2.write("\nAnother line using write.");

            // 输出字符数组
            char[] chars = "Array of characters".toCharArray();
            pw3.write(chars);

            // 输出部分字符数组
            pw4.write(chars, 0, 5);

            // 输出字符串的一部分
            String str = "Part of this string";
            pw5.write(str, 4, 7);

            // 手动刷新
            pw1.flush();
            pw2.flush();
            pw3.flush();
            pw4.flush();
            pw5.flush();

            System.out.println("Data written to files successfully.");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 9.数据流

​	提供了一种与平台无关的方式读写 Java 中的基本数据类型的数据（没搞懂啥意思，也似乎不咋用）。

- 数据输入流（FilterInputStream / DataInputStream）：读取 Java 基本数据类型的数据。

```java
// public DataInputStream(InputStream is)  创建用这玩意包裹的字节输入流

// public final byte readByte() throws IOException 读取字节数据
// public final int readInt() throws IOException 读取 int 数据
// public final double readDouble() throws IOException 读取 double 数据
// public final String readUTF() throws IOException 读取字符串（UTF-8格式）数据
// public int readInt() / read(byte[]) 直接读

import java.io.*;

public class DataInputStreamDemo {
    public static void main(String[] args) {
        // 从文件读取数据
        try (DataInputStream dis = new DataInputStream(new FileInputStream("data.dat"))) {
            // 读取字节数据
            byte byteValue = dis.readByte();
            System.out.println("读取的字节数据: " + byteValue);

            // 读取int数据
            int intValue = dis.readInt();
            System.out.println("读取的int数据: " + intValue);

            // 读取double数据
            double doubleValue = dis.readDouble();
            System.out.println("读取的double数据: " + doubleValue);

            // 读取UTF字符串数据
            String utfString = dis.readUTF();
            System.out.println("读取的UTF字符串数据: " + utfString);

            // 读取字节数组数据
            byte[] byteArray = new byte[100];
            int bytesRead = dis.read(byteArray);
            System.out.println("读取的字节数组数据: ");
            for (int i = 0; i < bytesRead; i++) {
                System.out.print(byteArray[i] + " ");
            }
            System.out.println();

            // 继续读取其他数据...
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

- 数据输出流（FilterOutputStream / DataOutputStream）：写入 Java 基本数据类型的数据。

```java
// public DataOutputStream(OutputStream out) 创建用这玩意包装的字节输出流

// public final void writeByte(int v) throws IOException 将 byte 类型的数据写入基础的字节输出流
// public final void writeInt(int v) throws IOException 将 int 类型的数据写入基础的字节输出流
// public final void writeDouble(Double v) throws IOException 将 double 类型的数据写入基础的字节输出流
// public final void writeUTF(String str) throws IOException 将字符串以UTF-8编码成字节写入基础的字节输出流
// public void write(int / byte[] / byte[]某段) 直接喷

import java.io.*;

public class DataOutputStreamDemo {
    public static void main(String[] args) {
        // 创建一个 DataOutputStream，包装一个 FileOutputStream
        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream("data.dat"))) {
            // 写入 byte 类型数据
            dos.writeByte(65); // 写入字节 65，对应 ASCII 字符 'A'
            System.out.println("写入 byte 数据: 65");

            // 写入 int 类型数据
            dos.writeInt(12345); // 写入整数 12345
            System.out.println("写入 int 数据: 12345");

            // 写入 double 类型数据
            dos.writeDouble(3.1415926); // 写入双精度浮点数 3.1415926
            System.out.println("写入 double 数据: 3.1415926");

            // 写入 UTF-8 编码的字符串
            dos.writeUTF("Hello, World!"); // 写入字符串 "Hello, World!"
            System.out.println("写入 UTF 字符串: Hello, World!");

            // 写入单个字节
            dos.write(66); // 写入字节 66，对应 ASCII 字符 'B'
            System.out.println("写入单个字节: 66");

            // 写入字节数组
            byte[] byteArray = {67, 68, 69}; // 对应 'C', 'D', 'E'
            dos.write(byteArray);
            System.out.println("写入字节数组: " + new String(byteArray));

            // 写入字节数组的一部分
            dos.write(byteArray, 1, 2); // 写入从索引 1 开始的 2 个字节，即 'D', 'E'
            System.out.println("写入字节数组的一部分: " + new String(new byte[]{68, 69}));

            System.out.println("所有数据写入完成！");
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

## 10.序列化流

​	用于将对象转为字节流的东西。

- 对象字节输入流（InputStream / ObjectInputStream）：把对象序列化存进文件。

```java
// public  ObjectOutputStream(OutputStream out) 创建包装基础字节输出流的这玩意
// public final void writeObject(Object o) throws INException 喷

import java.io.*;

public class SerializationExample {
    public static void main(String[] args) {
        // 创建一个可序列化的对象
        SerializableObject obj = new SerializableObject("Hello, World!", 123);

        // 指定输出文件路径
        String filePath = "object.ser";

        try (ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(filePath))) {
            // 使用writeObject方法将对象写入到文件中
            oos.writeObject(obj);
            System.out.println("对象已成功序列化并写入到文件: " + filePath);
        } catch (FileNotFoundException e) {
            System.err.println("找不到指定的文件: " + filePath);
            e.printStackTrace();
        } catch (IOException e) {
            System.err.println("写入对象到文件时发生错误");
            e.printStackTrace();
        }
    }
}

// 定义一个可序列化的类
class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L; // 序列化版本UID
    private String message;
    private int number;

    public SerializableObject(String message, int number) {
        this.message = message;
        this.number = number;
    }

    // 可以添加getter和setter方法，或者其他业务逻辑
}
```

- 对象字节输出流（OutputStream / ObjectOutputStream）：把文件反序列化读出对象。

```java
// public ObjectInputStream(InputStream is) 创建包装基础字节输入流的这玩意
// public final Object readObject() 喷

import java.io.*;

public class DeserializationExample {
    public static void main(String[] args) {
        // 指定输入文件路径
        String filePath = "object.ser";

        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(filePath))) {
            // 使用readObject方法从文件中读取并反序列化对象
            SerializableObject obj = (SerializableObject) ois.readObject();
            System.out.println("对象已成功反序列化并读取自文件: " + filePath);
            System.out.println("消息: " + obj.getMessage());
            System.out.println("数字: " + obj.getNumber());
        } catch (FileNotFoundException e) {
            System.err.println("找不到指定的文件: " + filePath);
            e.printStackTrace();
        } catch (IOException e) {
            System.err.println("从文件读取对象时发生错误");
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            System.err.println("找不到要反序列化的类");
            e.printStackTrace();
        }
    }
}

// 定义一个可序列化的类
class SerializableObject implements Serializable {
    private static final long serialVersionUID = 1L; // 序列化版本UID
    private String message;
    private int number;

    public SerializableObject(String message, int number) {
        this.message = message;
        this.number = number;
    }

    // 添加getter方法
    public String getMessage() {
        return message;
    }

    public int getNumber() {
        return number;
    }

    // 可以添加setter方法，或者其他业务逻辑
}
```

# 19，特殊文件

## 1.属性文件

​	一般用于保存如账户信息，系统配置之类的。

​	继承 Properties 即可，这玩意又继承 Map 集合，但不会当集合来用。

​	继承了这玩意就可以读写属性文件按里面的内容。

​	当然为啥不用上面的 IO 流读写文件？

​	专事专干嘛。

```java
// public Properties() 用于构建Properties集合对象

// public void load(InputStream is) 通过字节输入流，读取属性文件中的键值对数据
// public void load(Reader reader) 通过字符输入流，读取属性文件中的键值对数据
// public String getProperty(String key) 根据键获取值
// public Set<String> stringPropertyNames() 获取全部键的集合

import java.io.*;
import java.util.Properties;
import java.util.Set;

public class PropertiesExample {
    public static void main(String[] args) {
        // 创建一个Properties对象
        Properties props = new Properties();

        // 加载属性文件
        String filePath = "config.properties";
        try (InputStream is = new FileInputStream(filePath)) {
            props.load(is); // 使用字节输入流加载属性
            System.out.println("属性已成功加载");

            // 获取所有键的集合
            Set<String> keys = props.stringPropertyNames();
            System.out.println("所有键: " + keys);

            // 根据键获取值
            String dbUrl = props.getProperty("db.url");
            String dbUser = props.getProperty("db.user");
            String dbPassword = props.getProperty("db.password");

            System.out.println("数据库URL: " + dbUrl);
            System.out.println("数据库用户: " + dbUser);
            System.out.println("数据库密码: " + dbPassword);

        } catch (IOException e) {
            System.err.println("加载属性文件时发生错误");
            e.printStackTrace();
        }
    }
}
```

​	示例文件：config.properties。

```properties
db.url=jdbc:mysql://localhost:3306/mydatabase
db.user=root
db.password=123456
```

​	上面就是用来读取文件的。

​	下面就是用来写入文件的。

```java
// public Properties() 用于构建Properties集合对象

// public Object setProperty(String key, String value) 保存键值对数据至文件
// public void store(OutputStream os, String comments) 把键值对数据通过字节输出流写入文件
// public void store(Writer w, String comments) 把键值对数据通过字符输出流写入文件

import java.io.*;
import java.util.Properties;

public class PropertiesStoreExample {
    public static void main(String[] args) {
        // 创建一个Properties对象
        Properties props = new Properties();

        // 设置键值对
        props.setProperty("db.url", "jdbc:mysql://localhost:3306/mydatabase");
        props.setProperty("db.user", "root");
        props.setProperty("db.password", "123456");

        // 指定输出文件路径
        String filePath = "config.properties";

        try {
            // 使用字节输出流将键值对写入文件
            try (OutputStream os = new FileOutputStream(filePath)) {
                props.store(os, "Database configuration properties");
                System.out.println("属性已成功保存到文件（字节输出流）: " + filePath);
            }

            // 使用字符输出流将键值对写入文件
            try (Writer w = new FileWriter(filePath)) {
                props.store(w, "Database configuration properties");
                System.out.println("属性已成功保存到文件（字符输出流）: " + filePath);
            }
        } catch (IOException e) {
            System.err.println("保存属性文件时发生错误");
            e.printStackTrace();
        }
    }
}
```

​	然后在当前目录下，理应会出现一个 config.properties 文件。

```properties
#Database configuration properties
#Wed Oct  5 10:30:45 CST 2023
db.password=123456
db.user=root
db.url=jdbc\:mysql\://localhost:3306/mydatabase
```

## 2.XML

​	可扩展标记语言（英文全称自己百度）。

​	也不严格算是语言（不满足图灵完备的算啥语言），算是一种数据格式。

​	用于储存复杂数据结构或关系。

​	很像 HTML。

```xml
<!-- XML声明，指定XML的版本与编码 -->
<?xml version="1.0" encoding="UTF-8"?>
<!-- 根元素，文档最外层（图书馆书籍信息管理系统配置文件） -->
<library>
    <!-- 元素，文档中的基本构建模块（系统基本信息） -->
    <systemInfo>
        <name>图书馆书籍信息管理系统</name>
        <version>2.0</version>
        <developer>某科技有限公司</developer>
        <description>用于管理图书馆书籍信息、借阅记录等</description>
    </systemInfo>

    <!-- 数据库配置 -->
    <database>
        <host>localhost</host>
        <port>3306</port>
        <name>library_db</name>
        <username>root</username>
        <password>secure_password123</password>
        <connectionPoolSize>20</connectionPoolSize>
    </database>

    <!-- 用户界面配置 -->
    <ui>
        <theme>light</theme>
        <language>zh-CN</language>
        <fontFamily>Arial</fontFamily>
        <fontSize>14</fontSize>
    </ui>

    <!-- 功能模块配置 -->
    <modules>
        <!-- 属性，用于提供模块的额外信息 -->
        <module name="书籍管理" enabled="true">
            <description>管理图书馆所有书籍的信息</description>
            <features>
                <feature name="添加书籍" enabled="true"/>
                <feature name="删除书籍" enabled="true"/>
                <feature name="修改书籍信息" enabled="true"/>
                <feature name="查询书籍" enabled="true"/>
            </features>
        </module>

        <module name="借阅管理" enabled="true">
            <description>管理书籍的借阅和归还操作</description>
            <features>
                <feature name="借书" enabled="true"/>
                <feature name="还书" enabled="true"/>
                <feature name="续借" enabled="true"/>
                <feature name="查看借阅记录" enabled="true"/>
            </features>
        </module>

        <module name="用户管理" enabled="true">
            <description>管理图书馆用户的信息和权限</description>
            <features>
                <feature name="添加用户" enabled="true"/>
                <feature name="删除用户" enabled="true"/>
                <feature name="修改用户信息" enabled="true"/>
                <feature name="查看用户借阅情况" enabled="true"/>
            </features>
        </module>
    </modules>

    <!-- 日志配置 -->
    <logging>
        <level>INFO</level>
        <path>/var/log/library_system</path>
        <maxFileSize>10MB</maxFileSize>
        <maxBackupIndex>5</maxBackupIndex>
    </logging>

    <!-- 安全配置 -->
    <security>
        <sessionTimeout>30分钟</sessionTimeout>
        <passwordPolicy>
            <minLength>8</minLength>
            <maxLength>20</maxLength>
            <requireDigit>true</requireDigit>
            <requireLetter>true</requireLetter>
            <requireSpecialChar>true</requireSpecialChar>
        </passwordPolicy>
    </security>

    <!-- 第三方服务集成 -->
    <thirdPartyServices>
        <service name="邮件服务" enabled="true">
            <host>smtp.example.com</host>
            <port>587</port>
            <username>library@example.com</username>
            <password>email_password_456</password>
            <encryption>TLS</encryption>
        </service>

        <service name="短信服务" enabled="false">
            <provider>某云通信</provider>
            <apiKey>abc123def456</apiKey>
            <apiSecret>gh789ijk012</apiSecret>
        </service>
    </thirdPartyServices>

    <!-- 扩展配置 -->
    <extensions>
        <extension name="报表生成" enabled="true">
            <format>PDF, Excel</format>
            <schedule>每日, 每周, 每月</schedule>
        </extension>

        <extension name="数据备份" enabled="true">
            <destination>/backup/library_data</destination>
            <frequency>每日凌晨2点</frequency>
            <retentionPeriod>30天</retentionPeriod>
        </extension>
    </extensions>
</library>
```

​	还有就是关于 XML 的约束规则。

​	一般就是用来定义一个编写规范，强制要求这个文档的格式。

​	首先是内部定义。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library [
    <!ELEMENT library (book+)>
    <!ELEMENT book (title, author, year)>
    <!ATTLIST book id ID #REQUIRED>
    <!ELEMENT title (#PCDATA)>
    <!ELEMENT author (#PCDATA)>
    <!ELEMENT year (#PCDATA)>
]>
<library>
    <book id="1">
        <title>Java编程思想</title>
        <author>Bruce Eckel</author>
        <year>2007</year>
    </book>
</library>
```

​	然后是外部定义。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library SYSTEM "library.dtd">
<library>
    <book id="1">
        <title>Java编程思想</title>
        <author>Bruce Eckel</author>
        <year>2007</year>
    </book>
    <book id="2">
        <title>Effective Java</title>
        <author>Joshua Bloch</author>
        <year>2008</year>
    </book>
</library>
```

```dtd
<!ELEMENT library (book+)>
<!ELEMENT book (title, author, year)>
<!ATTLIST book id ID #REQUIRED>
<!ELEMENT title (#PCDATA)>
<!ELEMENT author (#PCDATA)>
<!ELEMENT year (#PCDATA)>
```

## 3.日志

​	用于保存记录操作，行为，情况，bug等。

​	存储了程序运行产生的东西。

​	可以使用类似 Logback 等第三方框架（Java 没有自带的）。

​	或者自己写一个。

​	第三方框架这里就先不讲了。

# 20，多线程

## 1.创建线程

​	就是程序内的代码执行流程。

​	就像只有一个人在干活。

​	一个人干活就是单线程，一群人分工就是多线程。

​	首先就是第一种找工人的方法。

​	定义一个类，继承 `java.lang.Thread`，然后重写里面的 `run()` 方法。

​	创建这个子类的实例对象。

```java
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        myThread.start(); // 启动线程
    }
}
```

​	然后就是第二种找工人的方法。

​	还是定义一个类，但这次要实现 `Runnable` 接口，然后重写 `run()` 方法。

​	创建这个子类的对象。

​	把这个对象交给 Thread 处理（ `public Thread(Runnable target)` 方法）。

​	最后调用对象的 `start()` 方法就可以启动了。

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

public class Main {
    public static void main(String[] args) {
        MyRunnable myRunnable = new MyRunnable();
        Thread thread = new Thread(myRunnable);
        thread.start(); // 启动线程
    }
}
```

​	第一种方法就是简单快速方便，但因为是继承，所以扩展性就差一些。

​	第二种方法因为不是继承而是实现，所以根据多实现单继承的问题，让它的扩展性还是很好。

​	但第二种方法需要多一个 `Runnable` 对象

​	但这两种方法执行完内部代码后均不能返回结果。

​	那就要用第三种方法，实现 `Callable` 接口，`FutureTask` 类来实现了。

​	首先，定义类实现 `Callable` 接口，重写 `call` 方法（把要做的事和返回结果重写上去）。

​	然后把任务交给 `Thread` 对象。

​	调用 `Thread` 对象的 `start()` 方法启动。

​	确认执行完毕后，通过 `FutureTask` 对象的 get 方法获取结果。

```java
// public FutureTask<>(Callable call) 把Callable对象封装成FutureTask对象
// public V get() throws Exception 获取线程执行call方法的返回结果

import java.util.concurrent.Callable;
import java.util.concurrent.FutureTask;

public class Main {
    public static void main(String[] args) {
        // 定义 Callable 任务
        Callable<Integer> callableTask = new Callable<Integer>() {
            @Override
            public Integer call() throws Exception {
                // 模拟耗时操作
                Thread.sleep(2000);
                return 42; // 返回结果
            }
        };

        // 将 Callable 任务包装到 FutureTask 对象中
        FutureTask<Integer> futureTask = new FutureTask<>(callableTask);

        // 创建线程并启动
        Thread thread = new Thread(futureTask);
        thread.start();

        try {
            // 等待线程执行完毕并获取结果
            Integer result = futureTask.get();
            System.out.println("Task result: " + result);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

​	第三种方法的优点就是在第二种方法的基础上，还能返回执行结果。

## 2.常用方法	

```java
// 方法
// public void run() 线程任务
class MyThread extends Thread {
    @Override
    public void run() {
        System.out.println("Thread is running");
    }
}

// public void start() 启动线程
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            @Override
            public void run() {
                System.out.println("Thread is running");
            }
        };
        thread.start(); // 启动线程
    }
}

// public String getName() 获取线程名称
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread();
        System.out.println("Thread name: " + thread.getName());
    }
}

// public void setName(String name) 设置线程名称
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread();
        thread.setName("MyThread");
        System.out.println("Thread name: " + thread.getName());
    }
}

// public static Thread currentThread() 获取当前执行的线程对象
public class Main {
    public static void main(String[] args) {
        Thread currentThread = Thread.currentThread();
        System.out.println("Current thread: " + currentThread.getName());
    }
}

// public static void sleep(long time) 让当前执行的线程休眠指定时间（毫秒）
public class Main {
    public static void main(String[] args) {
        try {
            Thread.sleep(2000); // 休眠 2000 毫秒
            System.out.println("Thread woke up");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// public final void join() 会让当前所在线程等待这个方法所在的线程执行完毕
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread() {
            @Override
            public void run() {
                try {
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                System.out.println("Thread is done");
            }
        };
        thread.start();
        try {
            thread.join(); // 等待 thread 执行完毕
            System.out.println("Main thread continues");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

// 构造器
// public Thread(String name) 指定线程名称
public class Main {
    public static void main(String[] args) {
        Thread thread = new Thread("MyThread");
        System.out.println("Thread name: " + thread.getName());
    }
}

// public Thread(Runnable target) 封装Runnable对象为线程对象
public class Main {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running");
            }
        };
        Thread thread = new Thread(runnable);
        thread.start(); // 启动线程
    }
}

// public Thread(Runnable target, String name) 封装Runnable对象为线程对象，并指定线程名称
public class Main {
    public static void main(String[] args) {
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread is running");
            }
        };
        Thread thread = new Thread(runnable, "MyThread");
        System.out.println("Thread name: " + thread.getName());
        thread.start(); // 启动线程
    }
}
```

## 3.线程安全

​	当多个线程使用同一个资源时，就会出现线程安全问题。

​	如两个人共同操作一个银行账户时，若余额100，两人同时都想取100，怎么办？

​	下面就是一个例子，运行后**理应**因为同时取前导致余额重复扣款，结果为-100。

​	（写的应该没问题啊？运行后为啥总被判断拦下来？？？你不是不安全嘛？？？）。

```java
// main
import java.math.BigDecimal;

public class Main {
    public static void main(String[] args) {
        Bank bank = new Bank(new BigDecimal("100"));
        new OperateThread(bank, "100").start();
        new OperateThread(bank, "100").start();
    }
}
```

```java
// Bank
import java.math.BigDecimal;

public class Bank {
    private BigDecimal money;

    public Bank() {
    }

    public Bank(BigDecimal money) {
        this.money = money;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public void quQian(String num) {
        System.out.println(Thread.currentThread().getName() + "来取钱");
        try {
            Thread.sleep(100); // 模拟耗时操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (this.money.compareTo(new BigDecimal(num)) < 0) {
            System.out.println("余额不足");
        } else {
            this.money = this.money.subtract(new BigDecimal(num));
            System.out.println("还剩" + this.money);
        }
    }
}
```

```java
// OperateThread
public class OperateThread extends Thread {
    private String num;
    private Bank bank;

    public OperateThread(Bank bank, String num) {
        this.bank = bank;
        this.num = num;
    }

    @Override
    public void run() {
        bank.quQian(num);
    }
}
```

​	有三种方法。

​	先是同步代码块，通过给共享资源核心代码上锁来解决问题。

​	实现每次只允许一个线程加锁后进入访问，结束出去后再解锁。

​	当然，这把锁必须是共用的，不能一人一把锁。

​	给 Bank 类的核心代码加锁就好了。

```java
// Bank
import java.math.BigDecimal;

public class Bank {
    private BigDecimal money;

    public Bank() {
    }

    public Bank(BigDecimal money) {
        this.money = money;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public void quQian(String num) {
        // 同步代码块，确保同一时间只有一个线程可以执行此块代码
        synchronized (this) {
            System.out.println(Thread.currentThread().getName() + "来取钱");
            try {
                Thread.sleep(100); // 模拟耗时操作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (this.money.compareTo(new BigDecimal(num)) < 0) {
                System.out.println("余额不足");
            } else {
                this.money = this.money.subtract(new BigDecimal(num));
                System.out.println("还剩" + this.money);
            }
        }
    }
}
```

​	第二种方法是同步方法。

​	这回就不只是锁代码块了，直接把整个方法锁上。

```java
// Bank
import java.math.BigDecimal;

public class Bank {
    private BigDecimal money;

    public Bank() {
    }

    public Bank(BigDecimal money) {
        this.money = money;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public synchronized void quQian(String num) {
        System.out.println(Thread.currentThread().getName() + "来取钱");
        try {
            Thread.sleep(100); // 模拟耗时操作
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        if (this.money.compareTo(new BigDecimal(num)) < 0) {
            System.out.println("余额不足");
        } else {
            this.money = this.money.subtract(new BigDecimal(num));
            System.out.println("还剩" + this.money);
        }
    }
}
```

​	第三种是使用三种常量锁。

​	字符串锁，Object 锁，和 Class 锁。

```java
// Bank
import java.math.BigDecimal;

public class Bank {
    private BigDecimal money;
//    private String Lock = "";
//    private static Object LOCK = new Object();
//    private Class LOCK = Class.class;

    public Bank() {
    }

    public Bank(BigDecimal money) {
        this.money = money;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public void quQian(String num) {
        synchronized (LOCK) {
            System.out.println(Thread.currentThread().getName() + "来取钱");
            try {
                Thread.sleep(100); // 模拟耗时操作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (this.money.compareTo(new BigDecimal(num)) < 0) {
                System.out.println("余额不足");
            } else {
                this.money = this.money.subtract(new BigDecimal(num));
                System.out.println("还剩" + this.money);
            }
        }
    }
}
```

​	最后的方法就是使用 Lock 操作。

​	用这个接口的实现类 `ReentrantLock` 来声明对象。

​	用对象进行加锁和解锁操作。

```java
// Bank
import java.math.BigDecimal;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Bank {
    private BigDecimal money;
    private final Lock lock = new ReentrantLock();

    public Bank() {
    }

    public Bank(BigDecimal money) {
        this.money = money;
    }

    public BigDecimal getMoney() {
        return money;
    }

    public void setMoney(BigDecimal money) {
        this.money = money;
    }

    public void quQian(String num) {
        lock.lock(); // 获取锁
        try {
            System.out.println(Thread.currentThread().getName() + "来取钱");
            try {
                Thread.sleep(100); // 模拟耗时操作
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if (this.money.compareTo(new BigDecimal(num)) < 0) {
                System.out.println("余额不足");
            } else {
                this.money = this.money.subtract(new BigDecimal(num));
                System.out.println("还剩" + this.money);
            }
        } finally {
            lock.unlock(); // 释放锁
        }
    }
}
```

## 4.线程通信

​	比起一群人抢一个资源，可以让它们互相告知自己的状态。

​	可以用以相互协调，避免争端。

​	某个东西叫生产消费者模型。

​	生产者负责生产数据（处理数据）。

​	消费者负责使用数据。

​	且生产者生产完之后不要继续生产，要通知消费者过来消费。

​	同样消费者消费完也不要继续消费，要通知生产者继续生产。

​	而它们的等待与唤醒也有专用方法（建议用当前挂载的同步锁调用这些方法）。

```java
// void wait() 让当前线程等待并释放锁，直到另一个线程唤醒它
// void notify() 唤醒某个线程
// void notifyAll() 唤醒所有线程

import java.util.LinkedList;
import java.util.Queue;

public class ProducerConsumerExample {
    private Queue<Integer> queue = new LinkedList<>();
    private final int capacity = 5; // 缓冲区容量
    private final Object lock = new Object();

    // 生产者
    public void producer() {
        for (int i = 0; i < 10; i++) {
            synchronized (lock) {
                while (queue.size() == capacity) {
                    try {
                        lock.wait(); // 缓冲区满，生产者等待
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                queue.add(i);
                System.out.println("生产者生产了: " + i);
                lock.notify(); // 通知消费者
            }
        }
    }

    // 消费者
    public void consumer() {
        for (int i = 0; i < 10; i++) {
            synchronized (lock) {
                while (queue.isEmpty()) {
                    try {
                        lock.wait(); // 缓冲区空，消费者等待
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                }
                int data = queue.poll();
                System.out.println("消费者消费了: " + data);
                lock.notify(); // 通知生产者
            }
        }
    }

    public static void main(String[] args) {
        ProducerConsumerExample example = new ProducerConsumerExample();

        Thread producerThread = new Thread(() -> example.producer());
        Thread consumerThread = new Thread(() -> example.consumer());

        producerThread.start();
        consumerThread.start();
    }
}
```

## 5.线程池

​	就是一堆线程。

​	里面的线程可以复用，运行不同的方法。

​	就像从贩卖商（买断，且一次性用品）变成了服务商（租用）。

​	若没有线程池，当请求过多时，创建与销毁线程的开销会把设备毁掉：）

​	池子里有几个定义好的常驻线程。

​	还有一个任务队列。

​	任务通过任务接口（`Runnable` 或 `Callable`）进入任务队列排队。

​	池子里的常驻按顺序处理队列中的任务。

​	JDK 有专门的线程池接口，`ExecutorService`。

​	使用 `ExecutorService` 的实现类 `ThreadPoolExecutor` 创建线程池对象。

​	然后使用对应方法处理任务和线程池的关闭策略。

​	还有任务拒绝策略。

```java
// 超级长的构造方法：
// corePoolSize 指定线程池的核心线程数量（常驻线程）
// maximumPoolSize 指定线程池的最大线程数量（最大线程，常驻不够了就拉临时工）
// keepAliveTime 指定临时线程存活时间（临时工雇佣多久）
// unit 指定临时线程的存活时间单位（秒，分，时，天）
// workQueue 指定线程池的任务队列
// threadFactory 指定线程池的线程工厂
// handler 指定线程池的任务拒绝策略（连临时工都满了，新单子拒接）
public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize,
                         long keepAliveTime, TimeUnit unit,
                         BlockingQueue<Runnable> workQueue,
                         ThreadFactory threadFactory,
                         RejectedExecutionHandler handler)
```

```java
// void execute(Runnable command) 执行Runnable任务
ExecutorService executorService = Executors.newFixedThreadPool(5);
executorService.execute(() -> {
    System.out.println("Executing task");
});
    
// Future<T> submit(Callable<T> task) 执行Callable任务，返回未来任务对象，用于取得结果
ExecutorService executorService = Executors.newFixedThreadPool(5);
Future<Integer> future = executorService.submit(() -> {
    return 42;
});
System.out.println(future.get()); // 输出：42
    
// void shutdown() 全部任务完成后再关闭池子
ExecutorService executorService = Executors.newFixedThreadPool(5);
executorService.execute(() -> {
    System.out.println("Executing task");
});
executorService.shutdown();
    
// List<Runnable> shutdownNow() 返回等待处理的任务，停止正在执行的任务，立刻关掉池子
ExecutorService executorService = Executors.newFixedThreadPool(5);
executorService.execute(() -> {
    System.out.println("Executing task");
});
List<Runnable> unfinishedTasks = executorService.shutdownNow();
System.out.println("Unfinished tasks: " + unfinishedTasks.size());
```

```java
// ThreadPoolExecutor.AbortPolicy 丢弃任务并抛出RejectedExecutionException（默认）
import java.util.concurrent.*;

public class AbortPolicyExample {
    public static void main(String[] args) {
        // 创建线程池，设置最大线程数为 5，队列容量为 10
        ThreadPoolExecutor executorService = new ThreadPoolExecutor(
            5, 5, 10, TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(10),
            new ThreadPoolExecutor.AbortPolicy()
        );

        // 提交 15 个任务
        for (int i = 0; i < 15; i++) {
            try {
                executorService.execute(() -> {
                    System.out.println("Executing task");
                });
            } catch (RejectedExecutionException e) {
                System.out.println("Task rejected: " + e.getMessage());
            }
        }

        // 关闭线程池
        executorService.shutdown();
    }
}

// ThreadPoolExecutor.DiscardPolicy 丢弃任务，不抛异常
import java.util.concurrent.*;

public class DiscardPolicyExample {
    public static void main(String[] args) {
        // 创建线程池，设置最大线程数为 5，队列容量为 10
        ThreadPoolExecutor executorService = new ThreadPoolExecutor(
            5, 5, 10, TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(10),
            new ThreadPoolExecutor.DiscardPolicy()
        );

        // 提交 15 个任务
        for (int i = 0; i < 15; i++) {
            executorService.execute(() -> {
                System.out.println("Executing task");
            });
        }

        // 关闭线程池
        executorService.shutdown();
    }
}

// ThreadPoolExecutor.DiscardOldestPolicy 抛弃队列中等待最久的，再把当前任务加入队列
import java.util.concurrent.*;

public class DiscardOldestPolicyExample {
    public static void main(String[] args) {
        // 创建线程池，设置最大线程数为 5，队列容量为 10
        ThreadPoolExecutor executorService = new ThreadPoolExecutor(
            5, 5, 10, TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(10),
            new ThreadPoolExecutor.DiscardOldestPolicy()
        );

        // 提交 15 个任务
        for (int i = 0; i < 15; i++) {
            executorService.execute(() -> {
                System.out.println("Executing task");
            });
        }

        // 关闭线程池
        executorService.shutdown();
    }
}

// ThreadPoolExecutor.CallerRunsPolicy 由主线程调用任务的run()方法（绕过线程池）
import java.util.concurrent.*;

public class CallerRunsPolicyExample {
    public static void main(String[] args) {
        // 创建线程池，设置最大线程数为 5，队列容量为 10
        ThreadPoolExecutor executorService = new ThreadPoolExecutor(
            5, 5, 10, TimeUnit.MILLISECONDS,
            new ArrayBlockingQueue<>(10),
            new ThreadPoolExecutor.CallerRunsPolicy()
        );

        // 提交 15 个任务
        for (int i = 0; i < 15; i++) {
            executorService.execute(() -> {
                System.out.println("Executing task");
            });
        }

        // 关闭线程池
        executorService.shutdown();
    }
}
```

​	还有一个线程池工具类 `Executors`。

​	提供了四种静态方法用于返回不同特点的线程池。

```java
// public static ExecutorService newFixedThreadPool(int nThreads) 创建固定线程数量的线程池，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程替代它

// public static ExecutorService newSingleThreadExecutor() 创建只有一个线程的线程池对象，如果该线程出现异常而结束，那么线程池会补充一个新线程

// public static ExecutorService newCachedThreadPool() 线程数量随着任务增加而增加，如果线程任务执行完毕且空闲了60s则会被回收掉

// public static ScheduledExecutorService new ScheduledThreadPool(int corePoolSize) 创建一个线程池，可以实现在给定的延迟后运行任务或者定期执行任务
```

​	看一下就好，不举例。

​	用这个工具类创建的线程池对象不太安全。

​	最好用上面的实现类手动创建。

​	这个工具类很容易堆积大量请求或创建大量线程导致设备暴毙。

​	手动定义限制一下就不会出现这种破事。

## 6.程序，进程，线程

​	简单来说，用一个软件举例子。

​	软件还没启动就算是一个程序，任务管理器也找不到它。

​	而启动之后就变成进程了，任务管理器也会出现它。

​	线程又属于进程，一个进程内可以包含多个线程。

​	而这堆线程是可以并发或者并行执行的。

## 7.并发，并行

​	进程中的线程均是由CPU调度执行的。

​	但CPU同时处理的能力是有上限的。

​	为了不会有任务因为其它玩意没搞完而排一辈子队。

​	所以CPU会轮询切换不同的任务，尽量不让某个任务半天没人管。

​	又因为切换的速度飞快，给人的感觉就像是同时执行的。

​	这一行为就叫并发。

​	而并行就是同一时刻，多个任务，也就是多个线程同时被CPU处理。

## 8.线程的生命周期

​	Java 里的线程有6中状态。

​	均被定义在 `Thread` 类的内部枚举类中。

```java
// 从 Thread 类里面爬出来的
public enum State {
    /**
     * Thread state for a thread which has not yet started.
     */
    NEW,

    /**
     * Thread state for a runnable thread.  A thread in the runnable
     * state is executing in the Java virtual machine but it may
     * be waiting for other resources from the operating system
     * such as processor.
     */
    RUNNABLE,

    /**
     * Thread state for a thread blocked waiting for a monitor lock.
     * A thread in the blocked state is waiting for a monitor lock
     * to enter a synchronized block/method or
     * reenter a synchronized block/method after calling
     * {@link Object#wait() Object.wait}.
     */
    BLOCKED,

    /**
     * Thread state for a waiting thread.
     * A thread is in the waiting state due to calling one of the
     * following methods:
     * <ul>
     *   <li>{@link Object#wait() Object.wait} with no timeout</li>
     *   <li>{@link #join() Thread.join} with no timeout</li>
     *   <li>{@link LockSupport#park() LockSupport.park}</li>
     * </ul>
     *
     * <p>A thread in the waiting state is waiting for another thread to
     * perform a particular action.
     *
     * For example, a thread that has called {@code Object.wait()}
     * on an object is waiting for another thread to call
     * {@code Object.notify()} or {@code Object.notifyAll()} on
     * that object. A thread that has called {@code Thread.join()}
     * is waiting for a specified thread to terminate.
     */
    WAITING,

    /**
     * Thread state for a waiting thread with a specified waiting time.
     * A thread is in the timed waiting state due to calling one of
     * the following methods with a specified positive waiting time:
     * <ul>
     *   <li>{@link #sleep Thread.sleep}</li>
     *   <li>{@link Object#wait(long) Object.wait} with timeout</li>
     *   <li>{@link #join(long) Thread.join} with timeout</li>
     *   <li>{@link LockSupport#parkNanos LockSupport.parkNanos}</li>
     *   <li>{@link LockSupport#parkUntil LockSupport.parkUntil}</li>
     * </ul>
     */
    TIMED_WAITING,

    /**
     * Thread state for a terminated thread.
     * The thread has completed execution.
     */
    TERMINATED;
}
```

- 状态：

  - `New` 新建状态通过调用 `start()` 方法进入 `Runnable` 可运行状态。

  - `Runnable` 可运行状态若未取得锁对象，进入 `Blocked` 阻塞状态。

    取得锁对象则回到 `Runnable` 可运行状态。

  - `Runnable` 可运行状态若取得锁对象并调用 `wait()` 方法，则进入 `Waiting` 等待状态。

    其它线程调用 `notify()` 方法并获得锁对象，则回到 `Runnable` 可运行状态。

  - `Runnable` 可运行状态若调用 `sleep()` 或 `wait()` 方法，则进入 `Timed Waiting` 计时等待状态。

    `sleep()` 方法时间到，或 `wait()` 方法时间到并取得锁对象，或 `wait()` 方法时间没到但其它线程调用 `notify()` 方法并取得锁对象，都会回到`Runnable` 可运行状态。

  - `Timed Waiting` 计时等待状态若 `wait()` 方法时间到但没有取得锁对象，或 `wait()` 方法时间没到就被其它线程调用 `notify()` 方法且还是没有锁对象，则进入 `Blocked` 阻塞状态。

  - `Waiting` 等待状态若被其它线程调用 `notify()` 方法且未获得锁对象，则进入 `Blocked` 阻塞状态。

  - `Runnable` 可运行状态若执行完毕但出现异常，则进入 `Teminated` 被终止状态。

## 9.死锁

​	死锁是指两个或多个线程在执行过程中，因争夺资源而造成的一种互相等待的现象。

​	即每个线程都占有对方所需的资源，同时又都在等待对方释放资源，导致程序无法继续执行。

​	比如：

```java
public class Main {
    public static void main(String[] args) throws InterruptedException {
        Object lockA = new Object();
        Object lockB = new Object();

        // 线程 A
        Thread threadA = new Thread(() -> {
            synchronized (lockA) {
                System.out.println("线程 A 已获取锁 A");
                System.out.println("线程 A 尝试获取锁 B");
                synchronized (lockB) {
                    System.out.println("线程 A 已获取锁 B");
                }
            }
        });

        // 线程 B
        Thread threadB = new Thread(() -> {
            synchronized (lockB) {
                System.out.println("线程 B 已获取锁 B");
                System.out.println("线程 B 尝试获取锁 A");
                synchronized (lockA) {
                    System.out.println("线程 B 已获取锁 A");
                }
            }
        });

        threadA.start();
        threadB.start();
        threadA.join();
        threadA.join();

        System.out.println("程序结束");
    }
}
```

​	**产生情况：**

1. 互斥条件：资源不能被共享，只能被一个线程占用。

2. 持有并等待：一个线程已经占有了至少一个资源，但又提出了新的资源请求，而该资源已被其他线程占有。

3. 不剥夺：资源请求者无法被强制剥夺资源，只有在该线程释放资源的时候其他线程才能使用资源。

4. 循环等待：存在一个进程等待链，链中的每一个进程都在等待下一个进程所占有的资源。

   **解决方法：**

1. 预防死锁
   - 破坏互斥条件：尽量减少资源的独占性，增加资源共享的可能性。
   - 破坏持有并等待条件：线程在获取新资源前必须释放已占有的资源。
   - 破坏不剥夺条件：允许线程强制性地从其他线程中夺取资源。
   - 破坏循环等待条件：规定线程申请资源的顺序，避免循环等待。
2. 避免死锁
   - 银行家算法：在资源分配之前，先判断该分配是否会导致系统进入不安全状态，如果是，则拒绝分配资源。
3. 检测与恢复
   - 死锁检测：定期检查系统中是否存在死锁。
   - 死锁恢复：一旦检测到死锁，采取措施恢复，如撤销线程、剥夺资源等。
4. 减少死锁的可能性
   - 减少锁的粒度：尽可能减少锁的范围，降低多个线程竞争同一锁的概率。
   - 使用超时机制：在尝试获取锁时设置超时时间，避免线程无限期等待。
   - 使用高级并发工具：如 `ReentrantLock`，它提供了更多的控制选项，如尝试非阻塞获取锁。

## 10.小结：银行账户管理

​	题目描述：

​	模拟一个银行账户管理系统，支持多个用户同时进行存款和取款操作。系统需要确保线程安全，并处理可能出现的线程通信问题。

​	功能需求（1，2为初始化 / 3为实现1 / 4为实现2 / 5为实现3）：

1. 创建一个 `BankAccount` 类，包含以下方法：

   - `deposit(int amount)`：存款方法。
   - `withdraw(int amount)`：取款方法。
   - `getBalance()`：获取当前余额。

2. 使用两种不同的方法创建线程，模拟多个用户同时进行存款和取款操作：

   - 一种方法是通过继承 `Thread` 类。
   - 另一种方法是通过实现 `Runnable` 接口。

3. 使用同步代码块或同步方法解决线程安全问题，确保在多线程环境下，账户余额不会出现负值或不一致的情况。

4. 使用线程池管理线程，限制同时运行的线程数量。

5. 实现线程通信，模拟生产者和消费者模型。例如，可以模拟一个场景，其中存款操作是生产者，取款操作是消费者。

   #### 输入输出要求：

   - 输入：模拟多个用户进行存款和取款操作。
   - 输出：显示每个操作的结果，包括操作类型、操作金额、操作后的余额等。

   #### 提示：

   - 可以使用 `synchronized` 关键字或 `ReentrantLock` 实现线程安全。
   - 可以使用 `ExecutorService` 和 `ThreadPoolExecutor` 管理线程池。
   - 可以使用 `wait()` 和 `notify()` 方法实现线程通信。

​	注意事项：

1. 确保线程安全，避免出现负余额或余额不一致的情况。
2. 使用线程池管理线程，限制同时运行的线程数量。
3. 实现线程通信，模拟生产者和消费者模型。

```java
import java.math.BigDecimal;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

public class Main {
    public static void main(String[] args) {
        // 1.初始化账户与两种线程
        BankAccount A = new BankAccount("1", "A", 123, new BigDecimal("100"));
        OperateUseThread thread = new OperateUseThread(A);
        OperateUseRunnable runnable = new OperateUseRunnable(A);
        // 2.模拟两个用户一起操作一个账户
//        thread.start();
//        runnable.run();





        // 1.创建线程池：2个常驻线程，4个最大线程，临时线程最久存活1，分钟，队列上限为10个任务，使用默认工厂，丢弃剩余任务并抛出报错
//        ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(
//                2, 4, 1,
//                TimeUnit.MILLISECONDS,
//                new ArrayBlockingQueue<>(5),
//                new ThreadPoolExecutor.AbortPolicy()
//        );
        // 4.将 Thread 打包成 Runnable 任务包
//        Runnable runnable1 = new Runnable() {
//            @Override
//            public void run() {
//                // 5.既然知道了 Thread 对象的 start() 方法为启动线程，那么当然不能打包这个启动方法，要不然进到循环重复调用时，还是相当于多次启动
//                // thread.start();
//                // 6.虽然常规需要用 start() 启动 Thread，但是这种需要装成任务包时，可以干脆使用 run() 方法，不直接启动，只定义任务，执行交给线程池
//                thread.run();
//            }
//        };
        // 2.模拟两个用户同时发了疯的持续操作一个账户
//        for (int i = 0; i < 10; i++) {
//            try {
//                threadPoolExecutor.execute(() -> {
//                    // 3.Thread 对象的 start() 方法用于启动线程，所以不能让一个线程重复启动多次
//                    // thread.start();
//                    // 7.这样就可以了
//                    runnable1.run();
//                    // 8.Runnable 相当于任务包，既然已经把任务打包，就可以直接丢给线程处理，多丢几个也可以
//                    runnable.run();
//                });
//            } catch (RejectedExecutionException e) {
//                System.out.println("Task rejected: " + e.getMessage());
//            }
//        }





        // 1.这里用消费者先提出需求，生产者再进行生产的顺序
        Main main = new Main();

        Thread consumerThread = new Thread(() -> main.consumer());
        Thread producerThread = new Thread(() -> main.producer(runnable));

        consumerThread.start();
        producerThread.start();
    }

    // 2.初始化锁对象，状态标识
    private final Object lock = new Object();
    private boolean flag = false;

    /**
     * 消费者
     */
    public void consumer() {
        for (int i = 0; i < 10; i++) {
            synchronized (lock) {
                while (!flag) {
                    try {
                        lock.wait();
                        flag = true;
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                lock.notify();
            }
        }
    }

    /**
     * 生产着
     */
    public void producer(OperateUseRunnable operateUseRunnable) {
        for (int i = 0; i < 10; i++) {
            synchronized (lock) {
                while(flag) {
                    try {
                        lock.wait();
                        flag = false;
                    } catch (InterruptedException e) {
                        throw new RuntimeException(e);
                    }
                }
                System.out.println("用户申请取款操作\n银行后台执行了一次操作\n");
                operateUseRunnable.run();
                System.out.println();
                System.out.println("——————————————————————————————");
                System.out.println();
                lock.notify();
            }
        }
    }
}
```

```java
import java.math.BigDecimal;

/**
 * 账户
 */
public class BankAccount {
    /**
     * 账户id
     */
    private String id;
    /**
     * 账户名
     */
    private String userName;
    /**
     * 账户密码
     */
    private Integer passWord;
    /**
     * 账户余额
     */
    private BigDecimal balance;

    public BankAccount() {
    }

    /**
     * 创建账户
     * @param id 账户id
     * @param userName 账户名
     * @param passWord 账户密码
     * @param balance 账户余额
     */
    public BankAccount(String id, String userName, Integer passWord, BigDecimal balance) {
        this.id = id;
        this.userName = userName;
        this.passWord = passWord;
        this.balance = balance;
    }

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getUserName() {
        return userName;
    }

    public void setUserName(String userName) {
        this.userName = userName;
    }

    public Integer getPassWord() {
        return passWord;
    }

    public void setPassWord(Integer passWord) {
        this.passWord = passWord;
    }

    public BigDecimal getBalance() {
        return balance;
    }

    public void setBalance(BigDecimal balance) {
        this.balance = balance;
    }

    @Override
    public String toString() {
        return "BankAccount{" +
                "id='" + id + '\'' +
                ", userName='" + userName + '\'' +
                ", passWord=" + passWord +
                ", balance=" + balance +
                '}';
    }

    /**
     * 存款
     * @param amount 量
     */
    public void deposit(String amount) {
        System.out.println("A");
    }

    /**
     * 取款
     * @param amount 量
     */
    public synchronized void withdraw(String amount, String userName) {
        System.out.println(userName + "来取款：" + amount + "元");
        /*
        模拟延迟
        故意让两次操作撞上
        （为了体现锁的效果）
         */
        try {
            Thread.sleep(100);
        } catch (InterruptedException e) {
            throw new RuntimeException(e);
        }
        if (this.balance.compareTo(new BigDecimal(amount)) < 0) {
            System.out.println("余额不足");
        } else {
            this.balance = this.balance.subtract(new BigDecimal(amount));
            System.out.println("成功，当前余额：" + this.balance);
        }
        System.out.println();
    }
}
```

```java
/**
 * 使用 Thread 进行操作
 */
public class OperateUseThread extends Thread{
    private BankAccount bankAccount;

    public OperateUseThread(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }

    @Override
    public void run() {
        // 模拟用户取款
        bankAccount.withdraw("50", "张三");
    }
}
```

```java
/**
 * 使用 Runnable 进行操作
 */
public class OperateUseRunnable implements Runnable{
    private BankAccount bankAccount;

    public OperateUseRunnable(BankAccount bankAccount) {
        this.bankAccount = bankAccount;
    }

    @Override
    public void run() {
        // 模拟用户取款
        bankAccount.withdraw("50", "李四");
    }
}
```

# 21，反射

## 1.简述

​	允许在程序运行时，动态的获取，加载，使用类与其内部的数据或方法。

​	以往需要在编写代码时，提前的，静态的加载这些东西。

​	而有了反射后，就不用这么难受了，可以实现更加灵活多变的（牛逼的，跟天书一样的）程序了。

​	主要就是四种操作。

- 加载类（Class 对象）。

- 获取类的构造器（Constructor 对象）。

- 获取类的成员变量（Field 对象）。

- 获取类的成员方法（Method 对象）。

  一般就是用来破坏封装性，强行获取类资源。

  尤其在构建框架时用的多。

## 2.加载类

​	首先就是获取到这个类。

```java
// 任意实例.getClass();
Class<?> a = obj.getClass();
System.out.println(a);

// Class.forName("类名")
Class<?> b = Class.forName("Student");
System.out.println(b);

// 类名.class
Class<?> c = Student.class;
System.out.println(c);

// 实例对象.getClass()
Student student = new Student();
Class<?> d1 = student.getClass();
System.out.println(d1);

// Class.getSuperclass()
Class<?> d2 = c1.getSuperclass();
System.out.println(d2);

// 引用数据类型.TYPE
Class<?> e = Integer.TYPE;
System.out.println(e);
```

## 3.获取类的构造器

​	拿到类之后，就可以动态的实例这个类了。

​	那为了实例类，首先就要获取类的构造器了。

​	假设有个Student类。

```java
public class Student {
    private String name;
    private Integer age;
    private Double weight;

    public Student() {
    }

    public Student(String name, Integer age, Double weight) {
        this.name = name;
        this.age = age;
        this.weight = weight;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Double getWeight() {
        return weight;
    }

    public void setWeight(Double weight) {
        this.weight = weight;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", weight=" + weight +
                '}';
    }

    public void show() {
        System.out.println("学生信息: " + this.toString());
    }
    public void a(Integer age, String name) {
        System.out.println("学生信息: " + this.toString());
    }
}

```

```java
// Constructor<?>[] getConstructors() 获取类的全部构造器（只获取修饰为公有的）
// Constructor<?>[] getDeclaredConstructors() 获取类的全部构造器（有就拿）
// Constructor<T> getConstructors(Class<?>... parameterTypes) 获取类的某个构造器（只获取修饰为公有的）
// Constructor<T> getDeclaredConstructors(Class<?>... parameterTypes) 获取类的某个构造器（有就拿）

// T newInstance(Object... initarge) 调用这个构造器对象表示的构造器，并传入参数，完成构造并返回对象
// public void setAccessible(boolean flag) 设置true，用于禁止检查访问控制（暴力反射，无视访问修饰）

import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;

public class ReflectionConstructorExample {
    public static void main(String[] args) {
        try {
            // 获取 Student 类的 Class 对象
            Class<?> studentClass = Class.forName("Student");

            // 1. 获取所有公共构造器
            Constructor<?>[] publicConstructors = studentClass.getConstructors();
            System.out.println("公共构造器：");
            for (Constructor<?> constructor : publicConstructors) {
                System.out.println(constructor);
            }

            // 2. 获取所有构造器（包括私有）
            Constructor<?>[] declaredConstructors = studentClass.getDeclaredConstructors();
            System.out.println("\n所有构造器：");
            for (Constructor<?> constructor : declaredConstructors) {
                System.out.println(constructor);
            }

            // 3. 获取指定参数类型的公共构造器
            Constructor<?> publicConstructor = studentClass.getConstructor(String.class, Integer.class, Double.class);
            System.out.println("\n指定参数类型的公共构造器：");
            System.out.println(publicConstructor);

            // 4. 获取指定参数类型的构造器（无论访问权限）
            Constructor<?> declaredConstructor = studentClass.getDeclaredConstructor(String.class, Integer.class, Double.class);
            System.out.println("\n指定参数类型的构造器（无论访问权限）：");
            System.out.println(declaredConstructor);

            // 5. 使用构造器创建对象
            Student student1 = (Student) publicConstructor.newInstance("张三", 18, 60.5);
            System.out.println("\n通过公共构造器创建的对象：");
            System.out.println(student1);

            // 6. 使用私有构造器创建对象（需要设置 accessible 为 true）
            Constructor<?> privateConstructor = studentClass.getDeclaredConstructor();
            privateConstructor.setAccessible(true);
            Student student2 = (Student) privateConstructor.newInstance();
            System.out.println("\n通过私有构造器创建的对象：");
            System.out.println(student2);

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
```

## 4.获取类的成员变量

​	构造完，就可以拉成员了。

​	先是获取成员变量的方法。

```java
// public Field[] getFields() 获取类的全部成员变量（只获取公开修饰的）
// public Field[] getDeclaredFields() 获取类的全部成员变量（全部获取）
// public Field getField(String name) 获取类的某个成员变量（只获取公开修饰的）
// public Field getDeclaredField(String name) 获取类的某个成员变量（全部获取）

// void set(Object obj, Object value) 赋值
// Object get(Object obj) 取值
// public void setAccessible(boolean flag) 设置true，用于禁止检查访问控制（暴力反射，无视访问修饰）

import java.lang.reflect.Field;

public class ReflectionFieldExample {
    public static void main(String[] args) {
        try {
            // 获取 Student 类的 Class 对象
            Class<?> studentClass = Class.forName("Student");

            // 创建 Student 对象
            Student student = new Student("张三", 18, 60.5);

            // 1. 获取所有公共字段
            Field[] publicFields = studentClass.getFields();
            System.out.println("公共字段：");
            for (Field field : publicFields) {
                System.out.println(field);
            }

            // 2. 获取所有字段（包括私有）
            Field[] declaredFields = studentClass.getDeclaredFields();
            System.out.println("\n所有字段：");
            for (Field field : declaredFields) {
                System.out.println(field);
            }

            // 3. 获取指定名称的公共字段
            Field publicField = studentClass.getField("name");
            System.out.println("\n指定名称的公共字段：");
            System.out.println(publicField);

            // 4. 获取指定名称的字段（无论访问权限）
            Field declaredField = studentClass.getDeclaredField("age");
            System.out.println("\n指定名称的字段（无论访问权限）：");
            System.out.println(declaredField);

            // 5. 给公共字段赋值
            publicField.set(student, "李四");
            System.out.println("\n给公共字段赋值后：");
            System.out.println("name: " + publicField.get(student));

            // 6. 获取私有字段的值
            declaredField.setAccessible(true);
            System.out.println("\n获取私有字段的值：");
            System.out.println("age: " + declaredField.get(student));

            // 7. 给私有字段赋值
            declaredField.set(student, 20);
            System.out.println("\n给私有字段赋值后：");
            System.out.println("age: " + declaredField.get(student));

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchFieldException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        }
    }
}
```

## 5.获取类的成员方法

​	还有就是获取类的成员方法。

```java
// Method[] getMethods() 获取类的全部成员方法（只获取公开修饰的）
// Method[] getDeclaredMethod() 获取类的全部成员方法（全部获取）
// Method getMethod(String name, Class<?>... parameterypes) 获取类的某个成员方法（只获取公开修饰的）
// Method getDeclaredMethod(String name, Class<?>... parameterypes) 获取类的某个成员方法（全部获取）

// public Object invoke(Object obj, Object... args) 执行某个方法
// public void setAccessible(boolean flag) 设置true，用于禁止检查访问控制（暴力反射，无视访问修饰）
// public int getModifiers() 获取方法的修饰符
// public String getName() 获取方法的名字
// public Class<?>[] getParameterTypes() 获取方法的参数组
// public Class<?> getReturnType() 获取方法的返回值

import java.lang.reflect.Method;
import java.lang.reflect.InvocationTargetException;

public class ReflectionMethodExample {
    public static void main(String[] args) {
        try {
            // 获取 Student 类的 Class 对象
            Class<?> studentClass = Class.forName("Student");

            // 创建 Student 对象
            Student student = new Student("张三", 18, 60.5);

            // 1. 获取所有公共方法
            Method[] publicMethods = studentClass.getMethods();
            System.out.println("公共方法：");
            for (Method method : publicMethods) {
                System.out.println(method);
            }

            // 2. 获取所有方法（包括私有）
            Method[] declaredMethods = studentClass.getDeclaredMethods();
            System.out.println("\n所有方法：");
            for (Method method : declaredMethods) {
                System.out.println(method);
            }

            // 3. 获取指定名称和参数类型的公共方法
            Method publicMethod = studentClass.getMethod("setName", String.class);
            System.out.println("\n指定名称和参数类型的公共方法：");
            System.out.println(publicMethod);

            // 4. 获取指定名称和参数类型的方法（无论访问权限）
            Method declaredMethod = studentClass.getDeclaredMethod("setAge", Integer.class);
            System.out.println("\n指定名称和参数类型的方法（无论访问权限）：");
            System.out.println(declaredMethod);

            // 5. 调用公共方法
            publicMethod.invoke(student, "李四");
            System.out.println("\n调用公共方法后：");
            System.out.println("name: " + student.getName());

            // 6. 调用私有方法
            declaredMethod.setAccessible(true);
            declaredMethod.invoke(student, 20);
            System.out.println("\n调用私有方法后：");
            System.out.println("age: " + student.getAge());

            // 7. 调用有返回值的方法
            Method getWeightMethod = studentClass.getMethod("getWeight");
            Double weight = (Double) getWeightMethod.invoke(student);
            System.out.println("\n调用有返回值的方法：");
            System.out.println("weight: " + weight);
            
            // 8. 获取指定方法的修饰符
            Method method = studentClass.getMethod("a", Integer.class, String.class);
            System.out.println("a方法的修饰符：" + Modifier.toString(method.getModifiers()));
            
            // 9. 获取指定方法的方法名
            System.out.println("a方法的名字" + method.getName());
            
            // 10. 获取指定方法的参数类型组
            System.out.println("a方法的参数类型" + Arrays.toString(method.getParameterTypes()));
            
            // 11. 获取指定方法的返回值类型
            System.out.println("a方法的返回值类型" + method.getReturnType());

        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (NoSuchMethodException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (InvocationTargetException e) {
            e.printStackTrace();
        }
    }
}
```

## 6.小结：保存任意对象的成员变量

​	定义一个方法，允许接收任意对象。

​	接收到的对象，使用反射获取对象的Class对象，然后获取所有的成员变量。

​	遍历成员变量，然后提取成员变量在对象中的值。

​	把成员变量名和对应值都写到文件中。

```java
public class Main {
    public static void main(String[] args) {
        Test.outputObjValue(new Student("studentA", 18));
        Test.outputObjValue(new Student("studentB", 18));
        Test.outputObjValue(new Teacher("teacherA", 38));
    }
}
```

```java
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.lang.reflect.Field;
import java.util.Properties;

public class Test {
    public static <T> void outputObjValue(T obj) {
        Class<?> objClass = obj.getClass();
        Field[] fields = objClass.getDeclaredFields();
        Properties properties = new Properties();
        for (Field field : fields) {
            field.setAccessible(true);
            try {
                Object value = field.get(obj);
                properties.setProperty(System.identityHashCode(obj) + "@" + field.getName(), String.valueOf(value));
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        }
        try(OutputStream outputStream = new FileOutputStream("./Object.properties", true)) {
            properties.store(outputStream, objClass.getName());
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }
}
```

# 22，注解

## 1.简述

​	一种作用于代码的标记。

​	告诉程序这里应该用什么方法执行（只是告诉你怎么执行，不会真的帮你执行）。

​	类，构造器，方法，成员变量，甚至参数等很多地方都能用。

​	注解就是实现了Annotation接口的玩意。

## 2.常用注解

### @Override

​	表示重写父类或接口中的方法。

```java
class Animal {
    void makeSound() {
        System.out.println("Some sound");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}
```

### @Deprecated

​	标记类，方法，或字段已过时，不建议使用。

```java
@Deprecated
void oldMethod() {
    System.out.println("This method is deprecated");
}
```

### @SupperessWarnings

​	抑制警告，好东西：）

​	再也看不到满地黄波浪了（确定写完代码，且功能没问题再用）。

```java
@SuppressWarnings("unused")
private int unusedVariable = 0;
```

## 3.自定义与元注解

​	自定义注解就是自己定义一个应用于程序的规则。

​	哪里要应用这个规则，就在哪里使用这个自定义注解。

```java
@元注解
public @interface 注解名{
    数据类型 成员名() [default 默认值];
    ...
}
```

​	而元注解又用于修饰其它注解。

​	一般常用的就两个。	

- `@Target`，声明被修饰的注解只能在哪些位置使用。

```java
// 可取值：
/*
	ElementType.ANNOTATION_TYPE：注解
    ElementType.CONSTRUCTOR：构造器
    ElementType.FIELD：字段
    ElementType.LOCAL_VARIABLE：局部变量
    ElementType.METHOD：方法
    ElementType.PACKAGE：包
    ElementType.PARAMETER：参数
    ElementType.TYPE：类、接口、枚举
*/

// 这个自定义注解仅可在类，接口，或枚举中使用
@Target(ElementType.TYPE)
public @interface MyAnnotation {
    String value();
}
```

- `@Retention`，声明注解的保留周期。

```java
// 可取值：
/*
	RetentionPolicy.SOURCE：注解仅保留在源代码中，编译时会被忽略
    RetentionPolicy.CLASS：注解保留在编译后的字节码文件中，但运行时无法获取
    RetentionPolicy.RUNTIME：注解保留在运行时，可以通过反射获取
*/

// 这个自定义注解在运行时也可用
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation {
    String value();
}
```

## 4.注解解析

​	用于判断类，方法，或成员变量等玩意有没有被注解标记过。

​	并可以把注解的内容拉出来。

​	谁的注解就先拿谁的class对象（如方法注解，就先拿Method的class）。

​	Class，Method，Field，和 Construtor 都实现了 AnnotatedElement 接口。

​	都能解析注解。

```java
// public Annotation[] getDeclaredAnnotations() 获取当前对象上应用的所有注解
// public T getDeclaredAnnotation(Class<T> annotationClass) 获取当前对象上的指定注解
// public boolean isAnnotationPresent(Class<Annotation> annotationClass) 判断当前对象上是否存在某个注解

import java.lang.annotation.*;
import java.lang.reflect.AnnotatedElement;
import java.lang.reflect.Field;
import java.lang.reflect.Method;

// 定义一个注解
@Target({ElementType.TYPE, ElementType.METHOD, ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@interface MyAnnotation {
    String value() default "";
}

// 应用注解的类
@MyAnnotation(value = "类注解")
public class AnnotationExample {
    @MyAnnotation(value = "字段注解")
    private String annotatedField;

    @MyAnnotation(value = "方法注解")
    public void annotatedMethod() {
        System.out.println("这是一个被注解的方法");
    }

    public static void main(String[] args) {
        try {
            // 获取类的 Class 对象
            Class<?> clazz = Class.forName("AnnotationExample");

            // 获取类上的所有注解
            System.out.println("类上的所有注解：");
            Annotation[] classAnnotations = clazz.getDeclaredAnnotations();
            for (Annotation annotation : classAnnotations) {
                System.out.println(annotation);
            }

            // 获取类上的指定注解
            System.out.println("\n类上的指定注解：");
            MyAnnotation classAnnotation = clazz.getDeclaredAnnotation(MyAnnotation.class);
            if (classAnnotation != null) {
                System.out.println(classAnnotation);
            }

            // 判断类上是否存在指定注解
            System.out.println("\n类上是否存在指定注解：" + clazz.isAnnotationPresent(MyAnnotation.class));

            // 获取方法上的所有注解
            System.out.println("\n方法上的所有注解：");
            Method method = clazz.getMethod("annotatedMethod");
            Annotation[] methodAnnotations = method.getDeclaredAnnotations();
            for (Annotation annotation : methodAnnotations) {
                System.out.println(annotation);
            }

            // 获取方法上的指定注解
            System.out.println("\n方法上的指定注解：");
            MyAnnotation methodAnnotation = method.getDeclaredAnnotation(MyAnnotation.class);
            if (methodAnnotation != null) {
                System.out.println(methodAnnotation);
            }

            // 判断方法上是否存在指定注解
            System.out.println("\n方法上是否存在指定注解：" + method.isAnnotationPresent(MyAnnotation.class));

            // 获取字段上的所有注解
            System.out.println("\n字段上的所有注解：");
            Field field = clazz.getDeclaredField("annotatedField");
            Annotation[] fieldAnnotations = field.getDeclaredAnnotations();
            for (Annotation annotation : fieldAnnotations) {
                System.out.println(annotation);
            }

            // 获取字段上的指定注解
            System.out.println("\n字段上的指定注解：");
            MyAnnotation fieldAnnotation = field.getDeclaredAnnotation(MyAnnotation.class);
            if (fieldAnnotation != null) {
                System.out.println(fieldAnnotation);
            }

            // 判断字段上是否存在指定注解
            System.out.println("\n字段上是否存在指定注解：" + field.isAnnotationPresent(MyAnnotation.class));

        } catch (ClassNotFoundException | NoSuchMethodException | NoSuchFieldException e) {
            e.printStackTrace();
        }
    }
}
```

## 5.小结：非空判断

​	定义一个自定义注解。

​	用于检查对象字段是否为空。

```java
// 一个自定义注解
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// 只应用于字段
@Target({ElementType.FIELD})
// 运行时也生效
@Retention(RetentionPolicy.RUNTIME)
// 定义一个自定义注解：NotNull
public @interface NotNull {
    // 定义了一个叫message的String类型的属性，并给了默认值
    String message() default "字段不能为空";
}
```

```java
// 用户对象
public class User {
    // 应用注解
    @NotNull(message = "用户名不能为空")
    private String username;
    private int age;
    // ...
}
```

```java
// 验证方法
import java.lang.reflect.Field;

public class ValidationUtils {
    // 创建一个方法，用于验证是否满足注解
    public static void validate(Object obj) throws IllegalAccessException {
        // 获取实例的 class 对象
        Class<?> clazz = obj.getClass();
        // 获取这个 class 对象指向的类的所有字段
        Field[] fields = clazz.getDeclaredFields();
        // 遍历字段
        for (Field field : fields) {
            // 强制访问！
            field.setAccessible(true);
            // 检查字段是否被 NotNull 注解标记
            if (field.isAnnotationPresent(NotNull.class)) {
                // 若被标记，则获取字段的 NotNull 注解的 class 对象
                NotNull notNull = field.getAnnotation(NotNull.class);
                // 获取传入对象的值
                Object value = field.get(obj);
                // 检查是否为空
                if (value == null) {
                    // 若为空，抛出注解中的 message
                    throw new IllegalArgumentException(notNull.message());
                }
            }
        }
    }
}
```

```java
// main方法
public class Main {
    public static void main(String[] args) {
        User user = new User();
        user.setUsername(null); // 设置 username 为 null

        try {
            ValidationUtils.validate(user);
        } catch (IllegalAccessException | IllegalArgumentException e) {
            System.out.println("验证失败: " + e.getMessage());
        }
    }
}
```
