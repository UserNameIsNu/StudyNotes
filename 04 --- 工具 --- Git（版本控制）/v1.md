[TOC]

# Git

# 1，简介与概念

## 1.这是啥

​	免费开源的分布式版本控制系统。

​	个人觉得是一个类似数据库的东西保存管理目标文件的变化。

​	每个被管理的文件都有独立的版本历史记录。

​	 可以看到谁在啥时候干了啥。

​	还能恢复记录避免爆炸。

## 2.为啥用

​	个人来说，一句话。

​	我是非常不想（害怕）出现文件记录乱掉，甚至是团队项目时有手贱玩意把代码毁了（还tm不认）。

## 3.急速认识两个大分类（集中式，分布式）

​	集中式的版本控制就是一个服务器，所有东西都在服务器里。

​	所以核心问题就是服务器炸了，谁也别想拿到代码（不用干活咯）。

​	分布式就是把所有东西在每个人的设备中均保存一个完整版本，不怕炸。

# 2，正常使用

## 1.检查这玩意是否安装

​	别想着我这里还教你安装，网上全是。

​	反正安装完之后打开控制台输入下面的检查。

​	蹦出版本号就算是安装好了。

```powershell
git -v
```

​	我这里会蹦出 `git version 2.47.1.windows.2`。

​	安装之后再设置用户名和邮箱，用于追踪提交的代码是谁干的。

```powershell
git config --global user.name "yourName"
git config --global user.email "yourEmailAddress"  
```

​	使用下面的检查配好没。

```powershell
git config --global --list
```

## 2.建立仓库（版本库）

​	选择你要管理的文件夹，进去，在这个文件夹里打开命令行，输入下面的命令。

```powershell
git init
```

​	这样就算创建了一个本地仓库。

​	去这个文件打开显示隐藏文件，如果有一个 .git 文件夹那就确定算是创建成功了。

 	或者使用克隆远程仓库来直接建立一个仓库。

```powershell
git clone remoteRepositoryUrl
```

## 3.三个区域（工作区，暂存区与仓库）

​	Git 管理时会默认产生三个区域。

​	就是章节题目说的三个。

​	工作区简单说就是文件夹里面的，你可以随便乱玩的，可以直接看到的。

​	暂存区就是把当前工作区的文件全部列出来，表示这些玩意准备好产生版本了。

​	仓库就是仓库，保存了所有产生的版本的记录。

​	工作区类似工厂，产生结果。

​	暂存区类似卡车，准备把东西运走。

​	仓库就是仓库，把东西存起来。

## 4.四种状态（未跟踪，未修改，已修改，已暂存）

​	第一个就是新建的，刚拖进来的，Git 没见过的。

​	第二个就是已经见过了，且进了仓库的。

​	第三个就是进了仓库，且发生了变化。

​	最后就是变化之后的，且已经暂存了的。

## 5.产生版本组合技（status，add，commit，log，ls-files）

​	先使用第一个查看仓库中文件的状态（不用也行，反正这个就是用来检查状态的，要用的时候再用 ）。

​	就是上面讲的四种状态。

```powershell
git status
```

​	然后使用第二个把文件上货，就是放进暂存区。

​	第一个用来把某个文件暂存。

​	第二个就是嫌麻烦就直接把所有文件暂存。

```powershell
git add fileName
git add .
```

​	添加完检查一下卡车，是不是装了我想要的货。

```powershell
git li-files
```

​	确认卡车装完货就可以运到仓库里了。

​	这样就会把所有暂存区里的东西存进仓库，并产生记录。

​	或者有个偷懒办法，后一个可以一句同时暂存并提交（不建议就是了）。

```powershell
git commit -m "commitMessage"
git commit -am "commitMessage"
```

​	最后可以检查一下仓库的记录。

​	第一个是显示作者，版本号，日期和版本描述的详细版。

​	第二个是只显示版本描述和版本号的简略版。

```powershell
git log
git log --oneline
```

​	注意，如果记录太多可能出现显示不完，左下角有一个 `:` 符号。

​	可以点一下 `q` 结束浏览。

​	或回车继续显示，知道出现 `end` 再按 `q`。

​	所有显示不完的都可以这样处理。

## 6.忽略文件

​	有些烦人玩意你可能不想被 Git管理。

​	一些支持包，资源文件等大得很的玩意，或者编译器的识别文件这种跟项目根本没关系的玩意。

​	但凡被管理了，每个版本都会出现一次这堆资源文件的”备份“。

​	尤其是上传远程仓库时，好几个 G 的文件也是要传死。

​	反正就是把这些不需要的，非核心的东西排除掉，隔离掉。

​	使用 `.gitignore` 文件就可以了（记得只能忽略新来的，已经进了版本库的不能忽略的）。

​	把不想要的文件名写到这个文件里面，不同文件换行分隔。

​	第一个表示忽略所有 `.xxx` 结尾的文件。

​	第二个表示哪怕忽略了 `.xxx` 结尾的文件，但对 `A.xxx` 无效。

​	第三个表示忽略所有名字叫 `xxx` 的文件夹。

​	第四个表示忽略  `zzz` 文件夹内的所有 `.xxx` 结尾的文件，路径不同的无效。

​	这四个就算是用的多的了（其它的百度）。

```powershell
*.xxx
!A.xxx
xxx/
zzz/*.xxx
```

# 3，出问题了

## 1.回退版本（reset）

​	有个傻鸟还是写了破烂代码把项目毁了怎么办？

​	用上面的 `log` 找出来他是谁，好好聊聊。

​	然后使用 `reset` 回退版本，回到他祸害之前的版本。

​	回退有三种模式，`--soft` ，`--hard` 和 `--mixed`。

​	第一个表示回退的同时，保留当前工作区与暂存区的内容。

​	第二个表示回退的同时，丢弃当前工作区与暂存区的内容。

​	第三个表示回退的同时，保留当前工作区的内容，但丢弃当前暂存的内容。

​	第三个同时也是默认参数，就是不加参数时就用这套方案执行了。

```powershell
git reset --soft versionID
git reset --hard versionID
git reset --mixed versionID
git reset versionID
```

## 2.回退操作（reflog）

​	你想挽救被傻鸟毁掉的代码，使用了 `reset` ，但是用坏了。

​	本就破烂的代码变得更加不堪入目，混乱至极。

​	但 Git 还有可以挽救你的命令。

​	使用 `reflog` 查看所有提交操作的记录。

​	找到最早的，没被任何人污染的版本，召唤它的归来。

```powershell
git reflog
```

​	用这个翻出记录之后选中目标版本，然后用上面的 `reset` 就可以退回去了。

## 3.检查差异（diff）

​	可以检查文件在工作区，暂存区和版本库，就是仓库的差异。

​	还能看文件在两个特定版本，或两个特定分支之间的差异。

​	一般就是变化的文件与变化的信息（细节）。

​	直接用默认显示工作区和暂存区差异。

​	加个 `HEAD` 就是显示工作区和版本库的差异。

​	加个 `--cached` 就是显示暂存区和版本库的差异。

​	跟两个版本的 ID 就能显示这两个版本的差异。

​	也可以最后跟一个文件名，表示只要看这个文件在选中规则下的差异。

```powershell
git diff
git diff HEAD
git diff --cached
git diff versionAID versionBID
git diff HEAD versionID fileName
```

## 4.HEAD关键字

​	`HEAD` 一般就是表示当前提交的最新版本。

​	`HEAD~` 就是当前最新版本的前一个版本。

​	`HEAD~n` 就是当前最新版本的前 n 个版本。

## 5.删除文件（rm）

​	如果有个文件想要删掉，可以直接删，然后用 `add` 更新暂存区。

​	或者使用 `rm`，在删除工作区文件的同时把暂存区也一并删掉。

​	两步并一步。

​	或者不想删除工作区的，只把暂存区的删掉，那就加个参数即可。

​	再加个 `-r` 可以把全部文件或文件夹也删掉。

​	删文件夹直接写名字就行，删文件要加后缀。

```powershell
git rm fileName
git rm --cached fileName
git rm -r --cached fileName
```

# 4，远程仓库使用

## 1.关联与推送（remote，push）

​	ps：远程仓库就是例如 Github，Gitee这些玩意，自己百度怎么用，都是图形化界面，不难。	

​	上面建立仓库的地方讲过了使用 `clone` 拉取远程仓库的版本并原地建立一个本地仓库。

​	但是本地仓库的版本怎么干到远程仓库里？

​	使用推送就好了。

​	推送前先关联一下远程仓库，确保我推送的目标是我想要的。

```powershell
git remote add remoteRepositoryName remoteRepositoryUrl
```

​	然后一下是不是关联到了。

```powershell
git remote -v
```

​	上面只是关联地址，还要关联分支。

​	前一个是将本地仓库的某分支推到远程仓库的某分支，适用于两个分支名字不一样的情况。

​	名字一样的话用第二个就好。

​	其实说是关联分支，`push` 实际上是用于推送本地仓库的。

​	所以说，下面代码的完成意思算是推送本地仓库的同时，关联分支。

```powershell
git push -u remoteRepositoryName localBranchName:remoteRepositoryBranchName
git push -u remoteRepositoryName branchName
```

​	去远程仓库刷新一下就能看到更新了。

​	上面检查关联检查的是仓库间的关联，还能检查分支间的关联。

```powershell
git branch -vv
```

## 2.拉取（pull）

​	如果远程仓库出现变化了咋办？

​	比如在线修改，或是有人推送了新的代码。

​	那么拉取一下，更新本地仓库就行了。

​	有些时候本地仓库想推送时，提示版本落后了，也是拉取一下，更新一下就可以正常推送了。

​	如果关联过分支，直接 `pull` 都可以了。

```powershell
git pull remoteRepositoryName remoteRepositoryBranchName:localBranchName
git pull
```

## 3.强制推送

当你气急败坏时（后果自负）。

无视警告报错，把本地记录覆盖上远程。

```powershell
git push -f
```

# 5，分支

## 1.快速了解分支与其基本操作（branch，switch）

​	en...

​	就像不同的工作台，可以保存不同的工作状态，且互不干扰（一个分支炸了，其它分支一点事没有）。

​	主要用于并行开发或测试功能（火速赶工和避免项目爆炸）。

​	默认就是master分支。

​	可以创建分支。

```powershell
git branch branchName
```

​	查看分支。

```powershell
git branch
```

​	切换到某个分支。

​	注意分支的定义，不同的工作台嘛，切换之后工作区，暂存区甚至版本库都是不同的。

```powershell
git switch branchName
```

​	也能删除分支。

​	注意前一个只能删除合并后的分支。

​	后一个可以删除未合并的分支。

​	合并是啥，看下一节。

```powershell
git branch -d branchName
git branch -D branchName
```

## 2.常规分支合并（merge）

​	假设我写完了一个功能，分支本身又是相互隔离的，我就需要把我的东西合并到主分支上。

​	合并前先切换到合并的目标分支。

​	然后使用 `merge` 就好了。

​	后面跟的分支名就是要合并的分支名。

​	即，我需要将 B 分支合并到 A 分支。

​	先切换到 A 分支。

​	使用下面的语句，语句内的分支名写 B 分支名。

​	然后就好啦，B 就并到 A 里面啦。

​	不过合并分支只是合并内容，不代表 B 直接融入 A。

​	B 还在，不会消失。

```powershell
git merge branchName
```

​	虽说图形化操作页面可以清晰舒服的看到分支图。

​	但是命令行其实也可以（极端简陋罢了，到也能看）。

```powershell
git log --graph --oneline --decorate --all
```

​	注意合并后是会自动产生一个版本的（其实有个特殊情况是不会出现版本的，懒得提了，实在少见）。

## 3.手动解决合并冲突（diff）

​	两个傻鸟修改了同一个文件，合并之后就冲突咯。

​	那可不就要解决一下（人和文件都解决一下，正常开发动了别人文件属实该死）。

​	可以用很上面提到的 `git status` 查看冲突文件的列表。

​	或者用直接看冲突的具体内容。

```powershell
git diff
```

​	一般就是一排小于号，一排等于号，一排大于号。

​	小于号等于号和等于号大于号之间分别都会夹着东西，就是冲突的部分了。

​	手动打开这个文件，修改一下（保留要的，那堆乱七八糟的符号全都删掉），然后重新暂存提交版本。

​	这就算解决了。

​	当然，如果想先中断这次合并也是可以的。

```powershell
git merge --abort
```

​	如果命令行解决太难受了，那就用图形化页面解决吧。

​	人家又好看又直观，还方便操作。

​	命令行解决能避免就避免的说。

## 4.分支命名与管理

​	简单来说。

​	版本分支，给个版本号

​	功能分支，feature-name

​	补丁分支，fix-name

​	弄完的分支及时合并，没用的分支火速删除。

# 6，标签

## 1.快速认识

​	一般多用于发布版本，里程碑式节点等重要时刻。

## 2.简单使用（tag）

​	创建标签一般是要指明目标版本的。

​	虽然不指明倒也可以。

​	第一个是不指明版本，默认最新一个版本。

​	第二个就是指定版本。

​	单是标签名不够吗？

​	第三个还能给标签再加上描述。

​	第四个就是集大成者了。

```powershell
git tag tagName
git tag tagName versionID
git tag -a testTag -m "message"
git tag -a testTag versionID -m "message"
```

​	创建完就要看看嘛。

​	第一个是展示所有标签，不过只显示名字。

​	第二个就能展示某一个标签的详细信息，甚至指向的版本信息。

```powershell
git tag
git show tagName
```

​	最后就是删除标签。

```powershell
git tag -d tagName
```

# 7，SSH配置与双推送

我最常用的配置。

其实还是突然开始需要推github，但是hub不认HTTP，只能是折腾一下怎么用SSH了。

双推送就是push的时候同时往两个远程仓库推。

## 1.SSH生成与配置

先删除旧的密钥对（鬼知道有没有，删就对了）。

下面的地址按实际存放，可能存放过密钥对的位置。

```bash
rm -rf ~/.ssh
```

```bash
rm -rf "/c/Users/李进峰/.ssh"
```

```bash
rm -rf /c/Users/Public/.ssh
```

指定一个位置创建目录，定义权限，路径不能有中文！

后续git读密钥就从这里读了。

```bash
export HOME=/c/Users/Public
```

```bash
mkdir -p ~/.ssh
```

```bash
chmod 700 ~/.ssh
```

然后生成密钥对。

最后的双引号里面的是密钥对的注释。

一路回车就行，啥都不用管。

```bash
ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -C "multi-remote"
```

然后看看有没有生成出来。

理应会出来两个文件：

- id_ed25519
- id_ed25519.pub

```bash
ls -l ~/.ssh
```

拿到公钥内容。

去远程仓库网站配置一下。

```bash
cat ~/.ssh/id_ed25519.pub
```

最后警告傻逼Git，必须从这个创建好的目录里面拿密钥对。

不要去什么奇怪的或者默认地址，可能会跑进中文路径，这就炸了。

```bash
git config --global core.sshCommand \
"ssh -i ~/.ssh/id_ed25519 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null"
```

## 2.配置本地仓库

先清空连接配置（也是删就对了，弄干净点）。

检查已有配置，输出是空的就不用删，直接下一步。

```bash
git remote -v
```

否则就删一下。

上面会输出类似：

- master  git@gitee.com:你的用户名/仓库.git
- master  git@github.com:你的用户名/仓库.git

```bash
git remote remove master
```

然后添加主要推送地址。

```bash
git remote add origin git@gitee.com:你的用户名/仓库.git
```

然后添加两个仅推送地址。

```bash
git remote set-url --add --push master git@gitee.com:你的用户名/仓库.git
```

```bash
git remote set-url --add --push master git@github.com:你的用户名/仓库.git
```

再检查一下。

应该类似：

- origin  git@gitee.com:你的用户名/仓库.git (fetch)
- origin  git@gitee.com:你的用户名/仓库.git (push)
- origin  git@github.com:你的用户名/仓库.git (push)

```bash
git remote -v
```

最后关联上游并推送。

```bash
git push --set-upstream master master
```

这就算可以了。

以后直接git push就行。
