[TOC]

# JavaScript

# 1，简介与概念

## 1.这是啥

​	JavaScript 是一种轻量级、解释型、面向对象的脚本语言。

​	它主要被设计用于在网页上实现动态效果，增加用户与网页的交互性。

​	作为一种客户端脚本语言，JavaScript 可以直接嵌入 HTML，并在浏览器中执行。

​	与 HTML 和 CSS 不同，JavaScript 使得网页不再是静态的，而是可以根据用户的操作动态变化的。

​	乱七八糟是吧，之前说 HTML 是毛坯，CSS 是装修，这 JS 就算是购置家电了。

## 2.干嘛的

​	一般吧，有三种用途。	

​	客户端脚本：用于在用户浏览器中执行，实现动态效果和用户交互。

​	网页开发：与 HTML 和 CSS 协同工作，使得网页具有更强的交互性和动态性。

​	后端开发：使用 Node.js，JavaScript 也可以在服务器端运行，实现服务器端应用的开发。

## 3.使用 JS

​	JS 一般还是搭配 HTML 等用于开发前端页面较多的样子（我自己就是学过这玩意）。	

​	算是有两种使用方法吧。

​	第一种就是用 script 标签嵌在 HTML 文档中，可以放在 head 标签中，也可以放在 body 标签中。

​	放在这两个地方其实是有一个执行顺序问题的。

​	不细讲，反正顺序就是：head 标签资源 > body 标签元素

​	而 body 标签元素也是按顺序执行的。

​	所以一些配置方面的可以放在 head。

​	而页面加载等需要关联标签元素的最好就放在 body 的最后一行等元素加载完成。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>文档标题</title>
        <meta charset="UTF-8">
        <script>
            console.log('hello');
        </script>
    </head>
    <body>
        <p>123</p>
        <script>
            console.log('hello');
        </script>
    </body>
</html>
```

​	第二种就是引入外部文件了。

```javascript
// 因为已经在 JS 文件中了，直接写 JS 代码就好。
alert('hello');
```

# 2，基本语法

## 1.快速了解变量常量

​	可以变化的值和不能变化的值。

​	主要就是 var 与 let 的区别。

​	简单讲就是 var 作用范围更大，更容易和不知道啥玩意冲突。

​	let 作用范围小，更加灵活安全。

​	关于作用范围吧，就是这个值可以被使用到的范围？

​	就当作信号塔吧，var 塔信号范围更大，let 塔更小。

​	反正别管这些，建议少用 var 就是了。

```javascript
var a = 1;
let b = 2;
const c = 3;
```

## 2.基本的数据类型简述

​	四个（还有个常用的是数组，这里先不讲）。

​	数字，字符串，undefined，null。

​	undefined 表示变量被声明但未赋值，或对象属性不存在（就是空着，占了个位置）。

​	null 表示确定为空或不存在（也算一种值，不能算空着）。

​	undefined 可能将来会被赋值或尚未计算出结果。

​	null 就明确标识就是没东西了。

```javascript
// 数字类型
let a = 1;

// 字符串类型
let b = '1';

// undefined
let c;

// null
let d = null;
```

## 3.认识三种常见流程控制语句

​	分为条件和循环两种。

​	先是 if 条件语句。

​	三个关键字分别是：if （如果），else if （否则如果），else（否则）

​	会按照顺序依次判断，若出现匹配项，会执行内部语句，然后退出判断流程，继续执行后续代码。

```javascript
// 这里会判断变量 a 的值
let a = 1;
if (a == 1) {
    alert('1');
} else if (a == 2) {
    alert('2');
} else {
    alert('3');
}
```

​	再就是 for 和 while 循环语句。

​	用于按照条件循环（迭代）指定次数。

​	个人来说，次数较少或需要精细操作时使用 for，大量重复时使用 while。

​	注意使用 while 循环时，因为容易忘记迭代器（就是 ‘ i++ ‘ 这种玩意）所以容易造成死循环（卡死罢了）。

```javascript
// 这里会从0开始，若小于10，加一，弹出一次消息提示当前数字，重复10次
for (let i = 0; i < 10; i++) {
    alert(i);
}

// 这里会从0开始，若小于10，弹出一次消息提示当前数字，重复十次
let a = 0;
while (a < 10) {
    alert(a);
    a++;
}
```

​	循环中还有两个关键字，分别是 break 和 continue。

​	前者用于中断退出循环，后者用于跳过本次迭代。

```javascript
// 这里在上面例子的基础上新增判断，若迭代至5，即中断循环
for (let i = 0; i < 10; i++) {
    if (i == 5) {
        break;
    }
    alert(i);
}

// 这里也是在上面例子的基础上新增判断，若迭代至5，跳过这次输出，继续后面的
for (let i = 0; i < 10; i++) {
    if (i == 5) {
        continue;
    } else {
        alert(i);
    }
}
```

## 4.认识函数与它的参数和返回值

​	函数是一堆可重复使用的代码块。

​	可以将大量重复的代码打包成一个函数，当遇到相同问题时，只需使用这个函数，不用重新编写代码。

​	相当于为某件事情制造了一件工具，可以重复方便快速的使用，而不用每次都费力费时的想办法。

​	函数可以选择传入参数，也可以不传入参数（给不给初始值或原料，前提条件等）。

​	函数也可以选择返回结果（产出），当然也可以不返回结果。

​	没有结果也是可以的（但这一般是出问题了吧）。

​	注意函数返回的结果是需要接收的。

​	直接调用只是产出了结果，你总要从产线上把东西拿下来用嘛。

```javascript
// 这是一个传入参数，且不返回结果的函数
function functionNameA(text) {
    alert(text);
}
// 这是一个不传入参数，但是返回结果的函数
function functionNameB() {
    return 'hello';
}

// 调用函数
functionNameA('hello');
console.log(functionNameB());
```

# 3，开始深入

## 1.了解作用域

​	和上面的 var 与 let 的区别不一样。

​	作用域指某个东西，比如变量生效的范围。

​	下面这个例子，a 是全局变量，b 则是局部变量，可见 b 被包裹在函数中。

​	执行函数时，函数内均可以获取到两个变量。

​	而在函数外部试图再次输出两个变量时，a 还是可以的，b 就无法识别了。

​	因为 b 的作用域仅仅位于所在函数内，函数外是无法直接获取到的。

```javascript
let a = 1;
function functionName() {
    let b = 2;
    console.log(a);
    console.log(b);
}
functionName();
console.log(a);
console.log(b);
```

## 2.简单事件处理

​	开始上一点难度咯。

​	首先理解一下事件。

​	事件指文档或页面，发生了特定操作的的瞬间，这个瞬间算是发生了一个事件。

​	如鼠标的点击，页面的滚动，页面的加载等等。

​	而事件处理当然就是处理发生这些事情是要做的事情了。

​	一般有7个常用的事件（不要和 CSS 伪类搞混，虽然功能类似，但不是一个东西）：

​	onclick（鼠标点击时）。

​	onMouseOver（鼠标经过时）。

​	onMouseOut（鼠标离开时）。

​	onChange（文本内容改变时）。

​	onSelect（文本框被选中时）。

​	onFocus（获得焦点时（鼠标点击后即为得到了焦点））。

​	onBlur（失去焦点（同时只能有一个焦点，有一个获取了，原来的就没了））

​	现在知道了事件，那就可以开始获取（捕捉）它们了。

​	一般使用事件绑定的方法获取事件的发生。

​	而事件绑定也分三种：

​	HTML 属性绑定，DOM 属性绑定，addEventListener 监听事件。

​	这里先用 HTML 属性绑定，绑定一个点击事件这个最简单的开始。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>文档标题</title>
        <meta charset="UTF-8">
        <style>
            #box {
                width: 100px;
                height:100px;
                background-color: red;
            }
        </style>
        <script>
            function clickEvent() {
                alert('hello');
            }
        </script>
    </head>
    <body>
        <!-- 这个结构标签被点击时，理应页面会弹出提示框，显示‘hello’ -->
        <div id="box" onclick="clickEvent()"></div>
    </body>
</html>
```

## 3.认识DOM（不是那个游戏）

​	当网页被加载时，浏览器会创建页面的文档对象模型，也就是 DOM（Document Object Model）。

​	每个 HTML 或 XML, 文档都可以被视为一个文档树，文档树是整个文档的层次结构表示。

​	文档节点是整个文档树的根节点。

​	DOM 为这个文档树提供了一个编程接口，开发者可以使用JavaScript 来操作这个树状结构。

​	抽象是吧。

​	从作用上来说，最直观的就是可以使用 JS 随意控制增减修改 HTML 文档中的任何标签，内容或样式等。

​	关于下面获取元素时出现的 ‘ [0] ’ ，简单解释一下。

​	类名不唯一嘛，所以需要添加索引，表示我需要这个结果表中的第几个。

​	注意下标从0开始（数组下标规则也是一样的，虽说我这里不讲数组）。

​	下面有两种修改方式， innerHTML 和 innerText。

​	前者可以解析内容，如输入  `<a href="#">123</a>` 时，可以直接被解析成 `123` 的超链接。

​	而后者会直接显示  `<a href="#">123</a>`，会当成字符串，就是文本处理。

​	下面还涉及了匿名函数，也先不讲了（还有箭头函数，更后面的东西了）。

​	DOM 的标签，也就是元素节点的操作就不写了。

​	从下面的案例来看，DOM还是挺厉害的，这还远远不是它的能力上限（就是纯手写麻烦，多）。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>文档标题</title>
        <meta charset="UTF-8">
    </head>
    <body> 
        <div id="box1">hello</div>
        <div class="box2">你好</div>
        <div>不想整理笔记啊</div>
        
        <script>
            // 获取元素
            let box1 = document.getElementById('#box1');
            let box2 = document.getElementsByClassName('.box2')[0];
            let box3 = document.getElementsByTagName('div')[2];
            // 修改文本
            box1.innerHTML = 'new text';
            box2.innerText = 'new text';
            // 修改样式
            box3.style.color = 'red';
            // 操作事件（事件处理提到的剩下两种绑定方式）
            // DOM 属性绑定方法
            box3.onclick = function() {
                alert('hello');
            }
            // 监听事件方法
            box3.addEventListener('click', function() {
                alert('hello');
            });
            // or
            box3.addEventListener('click', functionName);
            function functionName() {
                alert('hello');
            }
        </script>
    </body>
</html>
```

## 4.请求统一

前端发送请求有很多种方法。

如AJAX，axios，Fetch等各种方法。

### Promise对象

JS中有一个叫Promise的玩意，是异步编程的一种解决方案。

就是用它，或基于它实现的一些东西来解决前端请求的多样性。

再顺便解决一下回调地狱的问题（回调多了看的头发晕的）。

首先就是基本的Promise。

```javascript
// 声明Promise对象
let p = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve("成功结果");  // 或 reject("失败原因");
    }, 1000);
});

// 调用（启动）Promise对象
p.then(result => console.log(result)) // 成功返回
 .catch(error => console.log(error)); // 失败返回
```

### 链式调用

Promise对象也可以将多次请求合并。

完成一个请求后将它的返回紧接着甩进下一个请求。

每个then发送的东西就是上一个then接收到的返回。

```javascript
orderCoffee()
  .then(coffee => addMilk(coffee))
  .then(milkcoffee => addSugar(milkcoffee))
  .then(result => console.log(result))
  .catch(error => console.log(error));
```

### async / await简化

是Promise对象的进一步封装简化。

async就用于声明异步函数。

await就用于让函数后续部分暂停执行，直到Promise收到返回。

语法直接搞得跟一般的函数没啥区别。

看着更舒服。

```javascript
// 创建一个异步函数（这块玩意被调用后不会卡在JS的执行流中堵着，和JS各跑个的）
async function makeCoffee() {
    try {
        let coffee = await orderCoffee(); // 在被调用的方法返回数据前不让这个异步函数继续执行。
        let milkCoffee = await addMilk(coffee); 
        let sugarMilkCoffee = await addSugar(milkCoffee);
        console.log(sugarMilkCoffee);
    } catch (error) {
        console.log(error);
    }
}

makeCoffee();
```

### fetch简化

上面的async / await封装虽然更好理解，但是fetch写起来更简洁。

下面就是效果相同的两组请求方式，fetchAPI看起来就是更简短好看的了（没有A/A一眼看上去好理解而已）。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>文档标题</title>
        <meta charset="UTF-8">
    </head>
    <body>
        <script>
            async function getSomeThing() {
                const response = await fetch('http://localhost:8080/list/city?pageNum=1&pageSize=10');
                const jsonData = await response.json();
                console.log(jsonData);
            }
            getSomeThing();


            
            fetch('http://localhost:8080/list/city?pageNum=1&pageSize=10')
            .then(response => response.json())
            .then(jsonData => console.log(jsonData))
            .catch(error => console.log('some thing is wrong'));
        </script>
    </body>
</html>
```

### 请求案例

下面给出一个常见的请求写法。

```html
<!DOCTYPE html>
<html>
    <head>
        <title>文档标题</title>
        <meta charset="UTF-8">
    </head>
    <body>
        <!--  假表单  -->
        <form id="a">
            <label>city</label><input type="text" name="name"/>
            <label>code</label><input type="text" name="code"/>
            <input type="button" value="submit"/>
        </form>
        <script>
            // 做一个A/A模式的异步方法
            async function pushSomeThing() {
                // 获取表单并拉出数据
                const form = document.getElementById('#a');
                const data = new FormData(form);

                // 打成JSON格式（可选）
                // let json = {'name':'name', 'code':'1'}; 
                // json = JSON.stringify(json);

                // 拍请求出去
                const response = await fetch('http://localhost:8080/list/city', {
                    // 请求方式
                    method: 'POST',
                    // 请求头
                    headers: {
                        'Content-type': 'application/json'
                    },
                    body: data
                    // body: json
                });
            }
        </script>
    </body>
</html>
```

