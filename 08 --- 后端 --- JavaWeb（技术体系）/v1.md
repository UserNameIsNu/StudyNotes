[TOC]

# JavaWeb

# 1，简介

## 1. 这是啥

在 Java 中，动态 web 资源开发的技术统称为 JavaWeb。

- 静态 web：
  - html， css。
  - 提供给所有人看的数据始终不会发生变化。
  - 不会与数据库进行交互。
- 动态 web：
  - Servlet，JSP，ASP，PHP。
  - 提供给所有人看的数据始终会发生变化，每个人在不同的时间，不同的地点看到的信息各不相同。
  - 可动态更新数据，并与数据库进行交互。

## 2. Web 应用

web 应用程序就是可以提供浏览器访问的程序。

一个 web 应用由多部分组成：

- html，css，js。
- jsp，servlet。
- Java 程序。
- jar 包。
- 配置文件。

Web 应用若需要给外部用户访问与使用，一般都需要一个服务器来部署管理它。

正因为需要部署到服务器，若 Web 应用需要修改时，服务器就需要停机了。

那么网页也就进不去了（这玩意可不能即时修改立刻变更的）。

## 3. 技术栈迭代

- ASP：
  - 最早期用的就是这玩意（没听过）。
  - 效率相比现在奇低，且代码量巨大，复杂。
  - 完全依赖 Windows。
- PHP：
  - 实现跨平台。
  - 且降低语法复杂程度。
  - 就是性能还是捉急。
- JSP / Servlet：
  - 更好的支持大型，高性能网站的开发。
  - 结合 Java，功能与可移植性非常之可以。
  - 当然还是被前后端分离与各种框架薄纱的说。

## 4. HTTP 协议

超文本传输协议，用于传输网页、图片、视频等超文本数据。

蛮常用的一个玩意。

- **无连接**：每次请求独立建立连接，请求结束连接即断开。
- **无状态**：服务器不保存请求间的状态信息，状态管理需靠Cookie、Session等实现。
- **灵活性**：支持多种数据类型传输，如文本、图片、视频等。

### 请求

一个基本的 HTTP 请求似乎是这样：

```http
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64)
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate
Connection: keep-alive
```

- **请求行**：
  - **方法**：`GET`、`POST`、`PUT`、`DELETE`等。
  - **URL路径**：`/index.html`。
  - **协议版本**：`HTTP/1.1`。
- **消息头**：
  - **Host**：目标服务器域名。
  - **User-Agent**：客户端信息。
  - **Accept**：客户端可接受的响应内容类型。
  - **Accept-Language**：客户端可接受的语言。
  - **Accept-Encoding**：客户端可接受的压缩编码。
  - **Connection**：连接管理（如`keep-alive`保持连接）。

### 响应

一个基本的 HTTP 响应似乎是这样：

```http
HTTP/1.1 200 OK
Date: Mon, 27 Mar 2023 12:34:56 GMT
Server: Apache/2.4.41 (Ubuntu)
Content-Type: text/html; charset=UTF-8
Content-Length: 12345
{
  "name": "John Doe",
  "age": 30,
  "email": "john.doe@example.com"
}
```

- **状态行**：
  - **协议版本**：`HTTP/1.1`。
  - **状态码**：`200`表示成功。
  - **状态消息**：`OK`。
- **消息头**：
  - **Date**：响应生成时间。
  - **Server**：服务器信息。
  - **Content-Type**：响应内容类型。
  - **Content-Length**：响应体长度。
- **响应体**：
  - 实际返回的内容，如HTML网页、图片等。

## 5. 状态码



# 2，Servlet

关于一个 Web 应用，肯定是要有一个服务支持并部署这个应用的。

所以使用 Servlet 这玩意之前肯定是要配一下服务的。

一般（反正我）就是用 Tomcat 这玩意了。

咋配百度去。

Servlet 本身就是运行在服务器端的 Java 小程序。

一般用于接收客户端请求，处理请求并生成动态响应内容返回给客户端。

## 1. 包名倒置

例如 “ com.xx.xx ”。

其中 “ com ” 表示顶级域名，后面的 “ xx.xx ” 可以表示公司的名称或项目的名称等。

这种倒置的形式可以避免包名的命名冲突，因为域名是全球唯一的。

通过将域名作为包名的前缀，可以确保在不同的项目和组织中包名的唯一性。

## 2. Web 项目结构示例

```
src/
└── main/
    ├── java/
    │   └── com/
    │       └── example/
    │           ├── controller/
    │           │   ├── LoginServlet.java
    │           │   └── RegisterServlet.java
    │           ├── model/
    │           │   ├── User.java
    │           │   └── Product.java
    │           ├── dao/
    │           │   ├── UserDao.java
    │           │   └── ProductDao.java
    │           └── service/
    │               ├── UserService.java
    │               └── ProductService.java
    ├── resources/
    │   ├── config.properties
    │   └── log4j.properties
    └── webapp/
        ├── index.html
        └── WEB-INF/
            ├── web.xml
            └── lib/
```

## 3. 请求流程

- **客户端发起请求** ：
  - 用户在浏览器中输入 URL 或点击链接、提交表单等操作，浏览器根据 URL 向服务器发送 HTTP 请求。
  - 请求中包含请求方法（如 GET、POST 等）、请求头信息（如客户端信息、请求资源的 MIME 类型等）以及可能的请求体（如表单数据）。
- **服务器接收请求** ：
  - Web 服务器（如 Tomcat）监听特定端口（默认通常是 8080）。
  - 接收到客户端的 HTTP 请求后，解析请求信息，包括请求行（请求方法、URL、HTTP 版本）、请求头和请求体。
- **请求映射到 Servlet** ：
  - 服务器根据请求的 URL 和部署的 Web 应用配置，找到与该 URL 映射的 Servlet。
  - 如果使用注解方式配置 Servlet 映射，则根据 `@WebServlet` 注解中指定的映射路径来确定对应的 Servlet 类。
- **Servlet 容器加载和实例化 Servlet** ：
  - Servlet 容器（如 Tomcat 的 Catalina）负责管理 Servlet 的生命周期。
  - 当第一个请求到达映射到某个 Servlet 的 URL 时，容器会加载并实例化该 Servlet 类（如果该 Servlet 尚未被实例化）。
  - 然后调用 Servlet 的 `init()` 方法进行初始化操作，如加载配置文件、建立数据库连接等。
- **Servlet 处理请求** ：
  - 容器调用 Servlet 的 `service()` 方法来处理客户端请求。
  - `service()` 方法根据请求的 HTTP 方法（如 GET、POST 等）调用相应的 `doGet()`、`doPost()` 等方法。
  - 在这些方法中，Servlet 可以通过 `HttpServletRequest` 对象获取请求数据，如请求参数、请求头信息等。
  - 并根据业务逻辑进行处理，如验证用户输入、查询数据库、调用其他服务等。
- **生成响应** ：
  - Servlet 处理完请求后，通过 `HttpServletResponse` 对象生成响应数据。
  - 这包括设置响应状态码（如 200 表示成功、404 表示未找到资源等）、响应头信息（如 Content-Type 指定响应内容的 MIME 类型）以及响应体（如 HTML 页面、JSON 数据等）。
  - 可以使用 `PrintWriter` 或 `ServletOutputStream` 来向响应体中写入数据。
- **响应客户端** ：
  - Servlet 容器将生成的响应数据发送回客户端浏览器。
  - 浏览器接收到响应后，根据响应内容进行渲染和显示，如呈现 HTML 页面、处理 JavaScript 脚本等。
- **销毁 Servlet** ：
  - 当 Web 应用停止或服务器关闭时，Servlet 容器调用 Servlet 的 `destroy()` 方法来销毁该 Servlet 实例，释放资源，如关闭数据库连接等。

## 4. Servlet 接收方法

- doGet() 方法 ：

  - 用于处理客户端的 GET 请求，GET 请求通常用于向服务器获取资源。

  - GET 请求会将请求参数追加在 URL 后面，以问号（?）分隔，参数之间用 amp; 符号分隔。例如：`http://example.com/page?param1=value1&param2=value2`。

  - 由于 URL 长度有限制，GET 请求携带的数据量有限，一般不超过 1KB。

  - ```java
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取请求参数
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        // 处理请求并生成响应
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>GET 请求处理</h3>");
        out.println("姓名：" + name + "<br>");
        out.println("年龄：" + age);
        out.println("</body></html>");
    }
    ```

- doPost() 方法 ：

  - 用于处理客户端的 POST 请求，POST 请求通常用于向服务器提交数据以创建或更新资源。

  - POST 请求的请求参数包含在请求体中，不像 GET 请求那样直接显示在 URL 中。

  - 因此 POST 请求的数据量没有 GET 请求的限制，可以传输大量数据。

  - ```java
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置请求体的编码方式，防止中文乱码
        request.setCharacterEncoding("UTF-8");
        // 获取请求参数
        String name = request.getParameter("name");
        String age = request.getParameter("age");
        // 处理请求并生成响应
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>POST 请求处理</h3>");
        out.println("姓名：" + name + "<br>");
        out.println("年龄：" + age);
        out.println("</body></html>");
    }
    ```

- service() 方法 ：

  - 是 Servlet 的核心方法，用于接收和处理客户端请求。

  - 每次服务器收到客户端请求时，都会调用 service() 方法。

  - service() 方法会根据请求的类型（如 GET、POST、PUT、DELETE 等）调用相应的 doXXX() 方法来处理请求。

  - 如果请求类型不支持，则会抛出 `HttpMediaTypeNotSupportedException` 异常。

  - ```java
    public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        String method = request.getMethod();
        if (method.equals("GET")) {
            doGet(request, response);
        } else if (method.equals("POST")) {
            doPost(request, response);
        } else {
            response.sendError(HttpServletResponse.SC_METHOD_NOT_ALLOWED, "请求方法不支持");
        }
    }
    ```

- doPut() 和 doDelete() 方法 ：

  - 分别用于处理客户端的 PUT 和 DELETE 请求。

  - PUT 请求通常用于向服务器更新资源，而 DELETE 请求用于删除服务器上的资源。

  - ```java
    protected void doPut(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 处理 PUT 请求的逻辑
    }
    
    protected void doDelete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 处理 DELETE 请求的逻辑
    }
    ```

## 5. 重定向与转发

就是两种最常用的页面流转的方法。

### 定义与原理

- **重定向** ：
  - 是一种客户端行为。
  - 当使用重定向时，服务器会向客户端（浏览器通常是）发送一个状态码（如 302），告诉客户端重新向另一个 URL 发起请求。
  - 浏览器收到这个响应后，会向新的 URL 发出新的请求，服务器再对该请求进行处理并返回相应的资源。

- **转发** ：
  - 是一种服务器端行为。
  - 服务器在内部将请求和响应对象转交给另一个资源进行处理.
  - 客户端并不知道这个过程，浏览器地址栏显示的仍然是原来的 URL 。

### 请求次数

- **重定向** ：
  - 客户端会向服务器发出两次请求。
  - 一次是原始请求，另一次是浏览器根据服务器返回的重定向 URL 发起的请求。
- **转发** ：
  - 客户端只发出一次请求。
  - 服务器内部直接将请求到转发目标资源，不会产生新的 HTTP 请求。

### 数据共享

- **重定向** ：
  - 由于是两次不同的请求，原请求中的请求参数和请求属性无法直接传递给目标页面。
  - 但可以通过在 URL 后面附加参数（像 `response.sendRedirect("newPage.jsp?param=value");`）或者使用 HttpSession 对象来共享数据。
- **转发** ：
  - 目标页面可以获取原请求中的请求参数和请求属性，因为它们是在同一个请求过程中。

### 浏览器地址栏

- **重定向** ：
  - 浏览器地址栏会显示新的 URL。
- **转发** ：
  - 浏览器地址栏显示的仍然是原来的 URL。

### 应用场景

- **重定向**
  - 当需要从一个页面转发到另一个页面，并且希望浏览器地址栏显示新的 URL 时，例如用户登录成功后，从登录页面重定向到主页。 
  - 当让客户端记录两次请求，或者需要将请求转发到一个和当前服务器不同的服务器上的资源时，可以利用重定向来避免表单重复提交。例如在处理完表单数据后，将页面重定向到另一个结果页面，这样即使用户刷新页面，也不会再次提交表单。
- **转发**
  - 当需要在一个页面内完成多个步骤的处理，并且希望保持浏览器地址栏不变时，例如在一个 Servlet 中处理完后数据，转发到一个 JSP 页面来展示结果。
  - 当需要在服务器内部快速地将请求转交给另一个资源进行处理，并且共享需要原请求中的数据时。

### 示例

下面展示一个简单案例。

可以手动修改 index 页面的超链接标签的布尔取值来切换重定向或转发。

若为 true（重定向）时，地址栏理应会变为例如 `http://localhost:8080/target.html` 这样直接定位至目标页面的地址。

为 false（转发）时，地址栏理应会变为例如 `http://localhost:8080/testServlet?redirect=false`  这样仅显示携带值（因为超链接标签使用 GET 方式，所以显示值）而不是地址。

```html
<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>index</title>
    </head>
    <body>
        <a href="/testServlet?redirect=false">点击</a>
    </body>
</html>
```

```html
<!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>target</title>
    </head>
    <body>
        123
    </body>
</html>
```

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        response.setContentType("text/html;charset=UTF-8");
        // 判断是否需要重定向
        if ("true".equals(request.getParameter("redirect"))) {
            // 重定向
            response.sendRedirect("target.html");
        } else {
            // 转发
            request.getRequestDispatcher("target.html").forward(request, response);
        }
    }
}
```

## 6. 数据接收与响应

这里仅用 JSON 格式做示例（基本也就用这个的，别的格式很少用的样子）。

### 依赖

去项目 Maven 里面依赖一下 GSON。

```xml
<dependency>
    <groupId>com.google.code.gson</groupId>
    <artifactId>gson</artifactId>
    <version>2.13.1</version>
</dependency>
```

### 发送与接收请求

然后修改一下 index 页面。

这里用原生 JS 打请求。

发送与接收是放在一起的。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
        <button id="sendJson">发送 JSON 数据</button>
        <div id="response"></div>
        <script>
            // 当指定按钮被点击时，监听点击事件，执行方法
            document.getElementById("sendJson").addEventListener("click", function() {
                // JSON格式的数据
                var data = {
                    name: "John Doe",
                    age: 30,
                    email: "john.doe@example.com"
                };

                // 创建 XMLHttpRequest 对象
                var xhr = new XMLHttpRequest();

                // 配置请求
                xhr.open("POST", "testServlet", true);
                xhr.setRequestHeader("Content-Type", "application/json;charset=UTF-8");

                // 处理响应
                xhr.onreadystatechange = function() {
                    if (xhr.readyState === 4 && xhr.status === 200) {
                        // 解析 JSON 响应
                        var response = JSON.parse(xhr.responseText);
                        document.getElementById("response").innerHTML =
                            "服务器响应: <br>" +
                            "名称: " + response.name + "<br>" +
                            "年龄: " + response.age + "<br>" +
                            "邮箱: " + response.email + "<br>" +
                            "服务器消息: " + response.message;
                    } else if (xhr.readyState === 4) {
                        document.getElementById("response").innerHTML = "错误: " + xhr.status;
                    }
                };

                // 发送请求
                xhr.send(JSON.stringify(data));
            });
        </script>
    </body>
</html>
```

### 返回数据对象

给需要返回的所有数据封装成一个对象。

方便操作。

```java
package com.nf.test.controller;

public class JsonData {
    private String name;
    private int age;
    private String email;
    private String message;

    public String getName() { return name; }

    public void setName(String name) { this.name = name; }

    public int getAge() { return age; }

    public void setAge(int age) { this.age = age; }

    public String getEmail() { return email; }

    public void setEmail(String email) { this.email = email; }

    public String getMessage() { return message; }

    public void setMessage(String message) { this.message = message; }
}
```

### 编写 Servlet

主要步骤就是：

- 设置编码
- 接收数据
- 解析数据
- 其它逻辑
- 创建响应对象
- 响应

```java
package com.nf.test.controller;

import com.google.gson.Gson;
import com.nf.test.json.JsonData;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.BufferedReader;
import java.io.IOException;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置请求和响应的字符编码
        request.setCharacterEncoding("UTF-8");
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");

        // 接收 JSON 数据
        BufferedReader reader = request.getReader();
        StringBuilder jsonBuffer = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            jsonBuffer.append(line);
        }
        String jsonInput = jsonBuffer.toString();

        // 使用 GSON 解析 JSON 数据
        Gson gson = new Gson();
        JsonData jsonData = gson.fromJson(jsonInput, JsonData.class);

        // 创建响应数据
        JsonData responseData = new JsonData();
        responseData.setName(jsonData.getName());
        responseData.setAge(jsonData.getAge());
        responseData.setEmail(jsonData.getEmail());
        responseData.setMessage("数据已成功接收并处理");

        // 使用 GSON 将响应数据转换为 JSON 格式并发送
        String jsonResponse = gson.toJson(responseData);
        response.getWriter().write(jsonResponse);
    }
}
```

## 7. ServletContext

它代表了 Servlet 所在的 Web 应用程序的运行环境。

Servlet 可以用这玩意获取应用范围内的资源和信息。

或与其他 Servlet 或 JSP 页面共享数据。

又或访问服务器的相关信息。

一般就是三个作用：

### 读取配置

可以获取在 `web.xml` 中为整个 Web 应用程序设置的初始化参数。

给个主页。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
    	<a href="/initparam">点击</a>
    </body>
</html>
```

然后搓 xml 配置，用于一会儿读取。

```xml
<web-app>
    <context-param>
        <param-name>adminEmail</param-name>
        <param-value>admin@example.com</param-value>
    </context-param>
</web-app>
```

最后在 Servlet 中，使用 ServletContext 读取这个配置。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/initparam")
public class InitParamServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取 ServletContext
        ServletContext context = getServletContext();

        // 获取初始化参数
        String adminEmail = context.getInitParameter("adminEmail");

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>获取初始化参数示例</p>");
        out.println("<p>管理员邮箱: " + adminEmail + "</p>");
    }
}
```

### 共享数据

可以在不同的 Servlet 和 JSP 页面之间共享数据。

当然还是先整个主页。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
    <a href="/sharedata">发起共享的Servlet</a>
    <a href="/other">使用共享的Servlet</a>
    </body>
</html>
```

然后给某个 Servlet 的某些数据设置共享。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/sharedata")
public class ShareDataServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取 ServletContext
        ServletContext context = getServletContext();

        // 设置共享数据
        context.setAttribute("sharedData", "这是一个在应用范围内共享的数据");

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>被共享的数据: " + context.getAttribute("sharedData") + "</p>");
    }
}
```

最后在另一个 Servlet 中获取这个共享的数据。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/other")
public class OtherServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        ServletContext context = getServletContext();
        String sharedData = context.getAttribute("sharedData").toString();

        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>拿到的数据: " + sharedData + "</p>");
    }
}
```

在主页分别点两个按钮试试就好。

### 获取服务器信息

可以获取服务器的相关信息，如服务器名称、版本等。

步骤已经大差不差了。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
    <a href="/sharedata">获取服务器信息</a>
    </body>
</html>
```

```java
package com.nf.test.controller;

import jakarta.servlet.ServletContext;
import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/sharedata")
public class ShareDataServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取 ServletContext
        ServletContext context = getServletContext();

        // 获取服务器信息
        String serverInfo = context.getServerInfo();

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>服务器信息: " + serverInfo + "</p>");
    }
}
```

## 8. HttpServetRequest

客户端的 HTTP 请求。

它可以获取请求的相关信息，包括请求头、请求参数、请求体等。

### 获取请求参数

- `String getParameter(String name)`：获取指定名称的请求参数值。
- `String[] getParameterValues(String name)`：获取指定名称的请求参数的所有值。
- `Map<String, String[]> getParameterMap()`：获取所有请求参数的映射。

做个表单。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
    <form action="/testServlet" method="post">
        用户名: <input type="text" name="username"><br>
        密码: <input type="password" name="password"><br>
        爱好:
        <input type="checkbox" name="hobbies" value="reading"> 阅读
        <input type="checkbox" name="hobbies" value="gaming"> 游戏
        <input type="checkbox" name="hobbies" value="sports"> 运动<br>
        <input type="submit" value="提交">
    </form>
    </body>
</html>
```

然后接收表单数据。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Map;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取单个请求参数
        String username = request.getParameter("username");
        String password = request.getParameter("password");

        // 获取多个相同名称的请求参数
        String[] hobbies = request.getParameterValues("hobbies");

        // 获取所有请求参数的映射
        Map<String, String[]> parameterMap = request.getParameterMap();

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>用户名: " + username + "</p>");
        out.println("<p>密码: " + password + "</p>");
        out.println("<p>爱好:</p>");
        for (String hobby : hobbies) {
            out.println("<p> - " + hobby + "</p>");
        }
    }
}
```

### 获取请求头

- `String getHeader(String name)`：获取指定名称的请求头值。
- `Enumeration<String> getHeaderNames()`：获取所有请求头的名称。

index 主页不用动。

改一下 Servlet。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;
import java.util.Enumeration;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取指定名称的请求头
        String userAgent = request.getHeader("User-Agent");
        String host = request.getHeader("Host");

        // 获取所有请求头的名称
        Enumeration<String> headerNames = request.getHeaderNames();

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>User-Agent: " + userAgent + "</p>");
        out.println("<p>Host: " + host + "</p>");
        out.println("<p>所有请求头:</p>");
        while (headerNames.hasMoreElements()) {
            String headerName = headerNames.nextElement();
            String headerValue = request.getHeader(headerName);
            out.println("<p> - " + headerName + ": " + headerValue + "</p>");
        }
    }
}
```

### 获取请求路径

- `String getRequestURI()`：获取请求的 URI。
- `String getContextPath()`：获取应用程序的上下文路径。

还是只动 Servlet 就好。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取请求的 URI
        String requestURI = request.getRequestURI();

        // 获取应用程序的上下文路径
        String contextPath = request.getContextPath();

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<p>请求 URI: " + requestURI + "</p>");
        out.println("<p>上下文路径: " + contextPath + "</p>");
    }
}
```

### 获取输入流

- `ServletInputStream getInputStream()`：获取请求体的输入流，用于读取二进制数据（如文件图片啥的）。

小改一下 index。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
        <form action="testServlet" method="post" enctype="multipart/form-data">
            选择文件: <input type="file" name="file"><br>
            <input type="submit" value="上传">
        </form>
    </body>
</html>
```

然后在 Servlet 中读取二进制输入流。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.ServletInputStream;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取请求体的输入流
        ServletInputStream inputStream = request.getInputStream();
        byte[] buffer = new byte[1024];
        int length;
        ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();

        // 读取请求体中的二进制数据
        while ((length = inputStream.read(buffer)) != -1) {
            byteArrayOutputStream.write(buffer, 0, length);
        }
        byte[] fileBytes = byteArrayOutputStream.toByteArray();

        // 保存文件到服务器
        String uploadDir = getServletContext().getRealPath("/uploads");
        File dir = new File(uploadDir);
        if (!dir.exists()) {
            dir.mkdirs();
        }
        String fileName = "uploaded_file_" + System.currentTimeMillis() + ".bin";
        File file = new File(dir, fileName);
        FileOutputStream fos = new FileOutputStream(file);
        fos.write(fileBytes);
        fos.close();

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>文件上传成功</h1>");
        out.println("<p>文件已保存到: " + file.getAbsolutePath() + "</p>");
    }
}
```

## 9. HttpServletResponse

客户端的 HTTP 响应。

它可以设置响应的状态码、响应头和响应体。

### 设置响应状态码

- `void setStatus(int status)`：设置响应的状态码，例如 200（成功）、404（未找到）、500（服务器错误）等。

继续小改一下 index。

```html
<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>index</title>
    </head>
    <body>
        <a href="/testServlet">点击</a>
    </body>
</html>
```

然后改 Servlet。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置响应状态码为 404（未找到）
        response.setStatus(HttpServletResponse.SC_NOT_FOUND);

        // 发送响应
        response.setContentType("text/html");
        PrintWriter out = response.getWriter();
        out.println("<h1>404 - 页面未找到</h1>");
        out.println("<p>您请求的页面不存在。</p>");
    }
}
```

### 设置响应头

- `void setHeader(String name, String value)`：设置指定名称的响应头值。
- `void addHeader(String name, String value)`：添加一个响应头，如果该头已存在则追加值。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置响应头
        response.setHeader("Content-Type", "text/html");
        response.setHeader("Cache-Control", "no-cache, no-store, must-revalidate");
        response.setDateHeader("Last-Modified", System.currentTimeMillis());

        // 添加响应头
        response.addHeader("X-Frame-Options", "DENY");

        // 发送响应
        PrintWriter out = response.getWriter();
        out.println("<h1>响应头示例</h1>");
        out.println("<p>响应头已设置。</p>");
    }
}
```

### 设置响应内容类型

- `void setContentType(String type)`：设置响应的内容类型，例如 `text/html`、`application/json` 等。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置响应内容类型为 JSON
        response.setContentType("application/json");
        response.setCharacterEncoding("UTF-8");

        // 发送 JSON 响应
        PrintWriter out = response.getWriter();
        out.print("{\"name\":\"John\", \"age\":30}");
    }
}
```

### 获取输出流

- `ServletOutputStream getOutputStream()`：获取响应体的输出流，用于发送二进制数据。

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.ServletOutputStream;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 设置响应内容类型为图片
        response.setContentType("image/png");

        // 获取图片文件的路径
        String imagePath = getServletContext().getRealPath("/img/A2290934BF2AC38B70216491CD38E229.jpg");
        File imageFile = new File(imagePath);

        // 获取输出流
        ServletOutputStream out = response.getOutputStream();

        // 读取图片文件并写入输出流
        try (InputStream input = new FileInputStream(imageFile)) {
            byte[] buffer = new byte[4096];
            int length;
            while ((length = input.read(buffer)) > 0) {
                out.write(buffer, 0, length);
            }
        } finally {
            out.close();
        }
    }
}
```

# 3，足迹

## 1. Cookie

### 简介

Cookie 是存储在客户端的小段文本信息。

由服务器端生成，发送给浏览器。

浏览器会将 Cookie 保存下来，在后续的请求中会自动将 Cookie 发送给服务器。

它主要用于跟踪用户的浏览信息，如用户的登录状态（简单的未加密的登录信息）、购物车中的商品等。

### 示例

#### 主页

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Cookie 示例</title>
    </head>
    <body>
        <h2>Cookie 操作示例</h2>

        <h3>创建 Cookie</h3>
        <form action="/testServlet" method="get">
            用户名: <input type="text" name="username" required>
            <br><br>
            <input type="submit" value="创建 Cookie">
        </form>

        <h3>查看 Cookie</h3>
        <a href="/other">查看 Cookie 信息</a>
        <br><br>

        <h3>销毁 Cookie</h3>
        <a href="/del">销毁 Cookie</a>
    </body>
</html>
```

#### 创建

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		// 获取用户名
        String username = request.getParameter("username");

        // 创建 Cookie
        Cookie cookie = new Cookie("username", username);
        // 设置 Cookie 的最大年龄为 60 秒
        cookie.setMaxAge(60);
        // 设置 Cookie 的路径
        cookie.setPath("/");

        // 添加 Cookie 到响应
        response.addCookie(cookie);

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Cookie 创建成功！</h3>");
        out.println("<p>用户名: " + username + "</p>");
        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

#### 查看

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/other")
public class OtherServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取所有 Cookie
        Cookie[] cookies = request.getCookies();

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Cookie 信息</h3>");

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                // 获取 Cookie 名称和值
                String name = cookie.getName();
                String value = cookie.getValue();
                out.println("<p>" + name + ": " + value + "</p>");
            }
        } else {
            out.println("<p>没有找到 Cookie</p>");
        }

        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

#### 销毁

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/del")
public class InitParamServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取所有 Cookie
        Cookie[] cookies = request.getCookies();

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Cookie 销毁结果</h3>");

        if (cookies != null) {
            for (Cookie cookie : cookies) {
                // 销毁 Cookie
                cookie.setMaxAge(0);
                cookie.setPath("/");
                response.addCookie(cookie);
                out.println("<p>Cookie '" + cookie.getName() + "' 已销毁</p>");
            }
        } else {
            out.println("<p>没有找到 Cookie</p>");
        }

        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

## 2. Session

### 简介

Session 是服务器端用于存储用户会话信息的技术。

服务器为每个用户分配一个唯一的 Session 对象，用于存储特定于用户的数据。

当用户与服务器进行交互时，服务器通过 Session 来跟踪用户的会话状态。

例如在一个电商购物网站中，用户登录后，服务器会为该用户创建一个 Session。

它将用户的购物车信息、登录状态等存储在 Session 中。

### 示例

#### 主页

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Session 示例</title>
    </head>
    <body>
        <h2>Cookie 操作示例</h2>

        <h3>创建 Cookie</h3>
        <form action="/testServlet" method="get">
            用户名: <input type="text" name="username" required>
            <br><br>
            <input type="submit" value="创建 Cookie">
        </form>

        <h3>查看 Cookie</h3>
        <a href="/other">查看 Cookie 信息</a>
        <br><br>

        <h3>销毁 Cookie</h3>
        <a href="/del">销毁 Cookie</a>
    </body>
</html>
```

#### 创建

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.*;

@WebServlet("/testServlet")
public class Servlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取用户名
        String username = request.getParameter("username");

        // 获取当前请求的 Session，如果不存在则创建一个新的
        HttpSession session = request.getSession();

        // 存储数据到 Session
        session.setAttribute("username", username);

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Session 创建成功！</h3>");
        out.println("<p>用户名: " + username + "</p>");
        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

#### 查看

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/other")
public class OtherServlet extends HttpServlet {
    @Override
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取当前请求的 Session
        HttpSession session = request.getSession(false);

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Session 信息</h3>");

        if (session != null) {
            // 从 Session 获取数据
            String username = (String) session.getAttribute("username");
            out.println("<p>用户名: " + username + "</p>");
            out.println("<p>Session ID: " + session.getId() + "</p>");
            out.println("<p>Session 创建时间: " + new java.util.Date(session.getCreationTime()) + "</p>");
            out.println("<p>上次访问时间: " + new java.util.Date(session.getLastAccessedTime()) + "</p>");
        } else {
            out.println("<p>没有找到 Session</p>");
        }

        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

#### 销毁

```java
package com.nf.test.controller;

import jakarta.servlet.ServletException;
import jakarta.servlet.annotation.WebServlet;
import jakarta.servlet.http.HttpServlet;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;

import java.io.IOException;
import java.io.PrintWriter;

@WebServlet("/del")
public class InitParamServlet extends HttpServlet {
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        // 获取当前请求的 Session
        HttpSession session = request.getSession(false);

        // 设置响应内容类型
        response.setContentType("text/html;charset=UTF-8");
        PrintWriter out = response.getWriter();
        out.println("<html><body>");
        out.println("<h3>Session 销毁结果</h3>");

        if (session != null) {
            // 销毁 Session
            session.invalidate();
            out.println("<p>Session 已销毁</p>");
        } else {
            out.println("<p>没有找到 Session</p>");
        }

        out.println("<a href='index.html'>返回主页</a>");
        out.println("</body></html>");
    }
}
```

# 4，WebSocket

## 1.啥玩意

双向实时的通信协议。

如http协议就是发一次消息，发送前握手，发送后断开。

这玩意连接前握手，在单次会话关闭前不会自己断开。

握手时发送的也是一个http协议的请求，一个升级请求。

让后续通信均升级为WebSocket协议。

## 2.基本

### 依赖

在项目meven中赖两个包。

一个WebSocket的服务端依赖，另一个就是用户端依赖。

```xml
<!--  服务端  -->
<dependency>
    <groupId>jakarta.websocket</groupId>
    <artifactId>jakarta.websocket-api</artifactId>
    <version>2.2.0</version>
    <scope>provided</scope>
</dependency>

<!--  客户端  -->
<dependency>
    <groupId>jakarta.websocket</groupId>
    <artifactId>jakarta.websocket-client-api</artifactId>
    <version>2.1.1</version>
</dependency>
```

### 服务类

用于处理WebSocket的事件。

@ServerEndpoint用于标记这个类是个WebSocket服务端。

里面的值标记的是服务端的端点地址，前端发送的请求就要干进这里。

主要的也就三个方法。

- onOpen：连接成功时触发。
- onMessage：收到消息时触发。
- onClose：连接断开时触发。

```java
package edu.ljf.ws.server;

import jakarta.websocket.OnClose;
import jakarta.websocket.OnMessage;
import jakarta.websocket.OnOpen;
import jakarta.websocket.Session;
import jakarta.websocket.server.ServerEndpoint;

import java.io.IOException;

@ServerEndpoint("/connect")
public class WebSocketServer {
    /*
    * 打开新连接时触发
    * session是web服务为每个连接的客户端创建的唯一会话，所有WebSocket方法都有这个session参数
    * 主要用于服务端区分不同的客户端
    */
    @OnOpen
    public void onOpen() {
        System.out.println("客户端连接");
    }

    /*
    * 接收到客户端的消息时触发
    */
    @OnMessage
    public void onMessage(String message, Session session) throws IOException {
        System.out.println("接收的消息：" + message);
        session.getBasicRemote().sendText("你也6");
    }

    /*
    * 客户端断开连接时触发
    */
    @OnClose
    public void onClose() {
        System.out.println("客户端断开");
    }
}
```

### 页面

前端中，JS是有WebSocket的原生支持的。

三个方法也一样是有的。

创建WebSocket对象时，给定的路径末尾就是要补上上面设置的服务端端点名。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 创建WebSocket对象
    // WebSocket连接握手时会先用http协议发起连接升级请求
    // 服务端确认后后续通信才会用WebSocket协议
    const ws = new WebSocket("ws://localhost:8080/connect");
    // 连接时触发
    ws.onopen = function (){
        console.log("客户端与服务器建立连接");
        ws.send("6");
    };
    // 接收时触发
    ws.onmessage = function (event){
        console.log("接收的消息：" + event.data);
    };
    // 断开时触发
    ws.onclose = function (){
        console.log("连接断开");
    };
</script>
</body>
</html>
```

## 3.聊天室

这里做一个模拟群发情况。

上面的例子会出现一个问题。

两个或以上用户连接时，怎么判断哪条信息是谁发的。

这里就解决一下。

引入一个会话管理队列（就个Map）。

所有被连接的会话都丢进来。

List没有key，不能区分成员，所以用Map。

```java
package edu.ljf.ws.server;

import jakarta.websocket.OnClose;
import jakarta.websocket.OnMessage;
import jakarta.websocket.OnOpen;
import jakarta.websocket.Session;
import jakarta.websocket.server.ServerEndpoint;

import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

@ServerEndpoint("/connect")
public class WebSocketServer {
    // 用户会话管理队列
    // 先整个空Map
    private final static Map<String, Session> userMap = new HashMap<>();

    @OnOpen
    public void onOpen(Session session) {
        System.out.println(session.getId() + "连接");
        // 每有一个新用户连接，就把这个用户会话塞进Map
        userMap.put(session.getId(), session);
    }

    @OnMessage
    public void onMessage(Session session, String message) throws IOException {
        System.out.println(session.getId() + "发送：" + message);
        // 群发方法
        sendAll(session.getId() + ":" + message);
    }

    @OnClose
    public void onClose(Session session) {
        System.out.println(session.getId() + "断开");
        // 每有一个用户断开连接，就把这个用户从Map中删掉
        userMap.remove(session.getId());
    }

    public void sendAll(String message) throws IOException {
        // 以key遍历，这样就可以给所有在线的用户转发这一条信息
        Set<String> keys = userMap.keySet();
        for (String key : keys) {
            // 从用户列表中，根据key取出一个对应会话
            Session s = userMap.get(key);
            // 给这个会话发信息
            s.getBasicRemote().sendText(message);
        }
    }
}
```

